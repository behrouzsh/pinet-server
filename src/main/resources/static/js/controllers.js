/**
 * Created by chojnasm on 11/9/15.
 * Modified by Behrouz on 9/2/16.
 */
var appModule = angular.module('plnModule', ['rzSlider', 'ui.bootstrap', 'angular.filter', 'angularUtils.directives.dirPagination', 'mgcrea.ngStrap']);


//function appModule($scope) {

//$scope.exportItems = [{a:1,b:10},{a:2,b:20},{a:3,b:30}];
//};

//This is for being able to download PLN
appModule.config(['$compileProvider',
    function ($compileProvider) {
        $compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|file|blob):/);
    }]);

appModule.directive('fileModel', ['$parse', function ($parse) {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            var model = $parse(attrs.fileModel);
            var modelSetter = model.assign;

            element.bind('change', function(){
                scope.$apply(function(){
                    modelSetter(scope, element[0].files[0]);
                });
            });
        }
    };
}]);

//
// appModule.directive('slider', function() {
//     return {
//         restrict: 'A',
//         scope: {
//             ngModel: '='
//         },
//         link: function(scope, elem, attrs) {
//
//             //console.log(scope.ngModel);
//
//             return $(elem).slider({
//                 range: "min",
//                 animate: true,
//                 value: scope.ngModel,
//                 slide: function(event, ui) {
//                     return scope.$apply(function(){
//                         scope.ngModel = ui.value;
//                     });
//                 }
//             });
//         }
//     };
// });


appModule.directive('combineHorizontalScrolls', [function () {
    var scrollTop = 0;

    function combine(elements) {
        elements.on('scroll', function (e) {
            if (e.isTrigger) {
                debugger;
                e.target.scrollTop = scrollTop;
            } else {
                scrollTop = e.target.scrollTop;
                elements.each(function (element) {
                    if (!this.isSameNode(e.target)) {
                        $(this).trigger('scroll');
                    }
                });
            }
        });
    }

    return {
        restrict: 'A',
        replace: false,
        compile: function (element, attrs) {
            combine(element.find('.' + attrs.combineHorizontalScrolls));
        }
    };
}]);




appModule.filter('treeJSON', function () {
    function prettyPrintJson(json) {
        return JSON ? '\n' + JSON.stringify(json, null, ' ') : 'your browser does not support JSON so can not show the Json format.';
    }

    return prettyPrintJson;
});

appModule.filter('inline', function () {
    function inlinePLN(plnArray) {
        var output = '\n';
        var layerSep;
        var groupSep;
        var itemSep;
        var FormatREF;
        var FormatSYM;
        var FormatDES;
        var FormatVAR;
        var FormatPTM;
        var FormatProteoForm;
        for (var i = 0; i < plnArray.length; i++) {
            var plnLocal = plnArray[i];

            var plnKey = Object.keys(plnLocal.PLN)[0];
            var plnValue = plnLocal.PLN[plnKey];

            var refKey = Object.keys(plnLocal.REF)[0];
            var refValue = plnLocal.REF[refKey];

            var symKey = Object.keys(plnLocal.SYM)[0];
            var symValue = plnLocal.SYM[symKey];

            var PTM = [];
            var ProteoForm = [];
            itemSep = "&";
            if (plnValue == "InChl-like") {
                layerSep = "/";
                groupSep = ";";
                FormatREF = "r=";
                FormatSYM = "s=";
                FormatDES = "d=";
                FormatVAR = "v=";
                FormatPTM = "m=";
            } else if (plnValue == "ProteoForm") {
                layerSep = "/";
                groupSep = ";";
                FormatREF = "r=";
                FormatSYM = "s=";
                FormatDES = "d=";
                FormatVAR = "v=";
                FormatPTM = "m=";
                FormatProteoForm = "f=";
            } else{
                layerSep = ";";
                groupSep = ",";
                FormatREF = "REF=";
                FormatSYM = "SYM=";
                FormatDES = "DES=";
                FormatVAR = "VAR=";
                FormatPTM = "PTM=";

            }


            plnLocal.PTM.map(function (ptmGroup) {
                    ////console.log(ptmGroup);

                    var ptmForHit = [];

                    for (var index = 0; index < ptmGroup.length; index++) {
                        ptmForHit.push(ptmGroup[index].identifier + "@" + ptmGroup[index].location);
                    }

                    PTM.push(ptmForHit.join(itemSep));
                }
            );


            if (plnValue == "ProteoForm") {
                output = output +
                    "PLN=" + plnKey + ":" + plnValue + layerSep +
                    FormatREF + refKey + ":" + refValue.join(groupSep + refKey + ":") + layerSep +
                    FormatSYM + symKey + ":" + symValue.join(groupSep + symKey + ":") + layerSep +
                    FormatDES + layerSep +
                    FormatVAR + layerSep +
                    FormatPTM + PTM.join(groupSep)
                    + layerSep +
                    FormatProteoForm + ProteoForm + "#" + "\n";
            }
            else {
                output = output +
                    "PLN=" + plnKey + ":" + plnValue + layerSep +
                    FormatREF + refKey + ":" + refValue.join(groupSep + refKey + ":") + layerSep +
                    FormatSYM + symKey + ":" + symValue.join(groupSep + symKey + ":") + layerSep +
                    FormatDES + layerSep +
                    FormatVAR + layerSep +
                    FormatPTM + PTM.join(groupSep) + "#" + "\n";

            }
        }
        return output;
    }

    return inlinePLN;
});

appModule.factory('SharedService', function( $http, $q, $location, NgTableParams) {
    //Defining Start point variables
    var self = this;
    var vars = {};
    vars.textArea = "IYQ[pY]IQSR[+42.010] 1.3\n[aK]AYSFCGTVEY(UNIMOD:21)MAP -2.14\nKAY[+79.966]SF[myC]GTVEY[+79.966]MAPEVVNR[+42.010] -0.5, SVDLIKTY(MOD:00259)K(MOD:00723)HINEVYY(UNIMOD:21)AKKKRRHQ -0.33";
        //"\nC[me2K]ISPEERR[pS]PPAPGL -2.11";
    //vars.textAreaFormatMD = "IYQY[+80]IQSR[+42.010] 1.3\nK[+112.1]SAPATGGVK[+42.010]K[+56]PHR -0.5";
    //vars.textAreaFormatSN = "IYQ[pY]IQS[aR] 1.3\n[aK]SAPATGGVK[meK]PHR -0.5";
    vars.showSplash = true;
    vars.firstVisit = true;
    vars.genes =
        "WAPAL	0.582765 \n\
    LNPEP	0.608463333 \n\
    ZBTB4	0.449427083\n\
    CDK5	-0.651827917\n\
    EIF3I	0.311225\n\
    HVCN1	2.6447025\n\
    ATP2B1	1.39054125\n\
    PALM	-0.163905833\n\
    INPP5B	0.590265833\n\
    TTC38	-0.679287083\n\
    ATXN10	0.652995833\n\
    CMTR1	0.492184583\n\
    MYBPC2	-1.412605417\n\
    CD53	1.715054167\n\
    GNPTAB	0.520569167\n\
    LINC00852	0.42628875\n\
    GYPB	-0.27026875\n\
    TAF4	-0.659011667\n\
    CCDC136	-0.44600125\n\
    ANAPC5	0.222421667\n\
    VPS53	0.48754375\n\
    SIRT5	0.811704583\n\
    GPR52	0.897875417\n\
    SYNE2	1.529765833\n\
    EGLN1	-0.876005\n\
    DCP1B	-1.481000833\n\
    EVI2B	2.559157083\n\
    CCDC71	0.763645833\n\
    FAM78A	-0.739273333\n\
    SLC7A5	-0.684393333\n\
    RFESD	0.90562875\n\
    NOB1	-0.39840625\n\
    CDRT1	-0.653400833\n\
    TCTN1	1.0469225\n\
    ZNF441	0.65255\n\
    HTRA2	0.427227917\n\
    NLRP1	0.672475\n\
    UBR4	0.369267917\n\
    RAPGEF3	-0.23748375\n\
    PLXDC2	-0.13522\n\
    MLX	-0.301622917\n\
    FABP6	-0.655844167\n\
    COASY	-0.43384875\n\
    FCRL5	1.741222083\n\
    MBD3L2	-0.125533333\n\
    ASIC2	-0.2065225\n\
    RPA2	0.506745833\n\
    SIX1	-0.374199167\n\
    MEIS1	-0.813935833\n\
    PCTP	-1.572920417\n\
    BIK	0.961908333\n\
    AHCYL2	-0.623029167\n\
    RAB8B	1.237324583\n\
    TLR4	2.018860417\n\
    DYNLL2	-0.3616775\n\
    USP7	0.5759675\n\
    MSS51	0.273085\n\
    PTPN22	2.632131667\n\
    SLAMF1	2.271535\n\
    ARHGEF40	-0.150840833\n\
    DISC1	-0.241928333\n\
    ARRDC3	1.463494167\n\
    NMNAT3	-0.31732\n\
    GDF3	0.164861667\n\
    IQCE	-0.3644825\n\
    CCDC148-AS1	-0.32879125\n\
    SRR	0.781120833\n\
    FGB	-0.1569775\n\
    PARP6	-0.413099583\n\
    TOMM40L	0.27411125\n\
    DTNB	0.295823333\n\
    S100A13	-0.291324583\n\
    ZRSR1	-0.34518\n\
    TPI1	-0.440325\n\
    CHCHD3	-0.985430833\n\
    DCAF7	-0.30202125\n\
    RASEF	-0.161737917\n\
    VTCN1	-0.203435417\n\
    MYH7	-0.201917083\n\
    CRYGB	0.234997083\n\
    ASB2	1.914900833\n\
    GSTO1	-1.972381667\n\
    TRIM47	-0.375892917\n\
    CD33	-0.47027125\n\
    SLFN5	2.18537\n\
    KIAA0430	0.339397917\n\
    PRR4	-0.52012875\n\
    TLR10	2.561315833\n\
    REPIN1	-1.027269583\n\
    CECR1	-0.83928875\n\
    RUNX2	0.66571125\n\
    IQSEC1	-1.12799875\n\
    PIGL	0.6745275\n\
    CCNL2	0.628422917\n\
    PDE7A	0.915685417\n\
    ETNK1	-0.46183375\n\
    CAMKMT	-0.714247083\n\
    CDYL2	0.925801667\n\
    GOLGA7B	-0.195238333\n\
    ASCC2	0.291145833\n\
    PRR14L	0.386724167\n\
    RALGDS	-0.39905375\n\
    ASB14	0.116145833\n\
    ABHD12	-0.35705875\n\
    USP42	-0.4293225\n\
    DMXL2	-1.610239167\n\
    KLF10	1.041207083\n\
    C2orf76	1.100731667\n\
    LPGAT1	-1.30080625\n\
    MIR155HG	2.48753625\n\
    SCO2	0.296974167\n\
    NIPSNAP3B	1.556337917\n\
    MKRN9P	-0.301214167\n\
    PIGF	-0.571012917\n\
    PIGF	-0.571012917\n\
    SNRPN	0.633652083\n\
    CEP126	-0.676147083\n\
    EVI2A	1.56335\n\
    CCNL2	0.611158333";





    //    "OCIAD1 1.2, NCOR2 3.3, ZC3HC1 -1.5, RPS6KA3 -2.2, PDPK1 -0.02, PDPK2P 0.77, HN1 2.2, BRAF 3.4, TP53 -0.9";
    //vars.organism = "9606";
    vars.uniprotFoundNum = 0;
    vars.waiting = false;
    vars.showOutput = false;
    //Q13627[acK@105][phY@145]Q810A7[phS@897]

    vars.inputMassPtmProteins = "Q05826{[pT]@220} -1.33,Q6P788{K[+42.010]@29}{[snC]@101} -1.08,Q9Y463{K(MOD:00663)@256}{Y[+79.966]@273} -0.2,Q13627{[aK]@105}{Y[+79.966]@145} 2.7, Q5TA31{[meR]@109} 2.11, Q13627{K(MOD:00723)@105}{Y(MOD:00259)@104}{Y(UNIMOD:21)@112} -0.33";
    vars.inputShorthandPtmProteins = "Q9Y463{[pY]@273} -0.2,Q13627{[pY]@321} 2.7,P51812{[pS]@369} -1.33";
    vars.inputShorthandPtmProteins = "";
    vars.uniprotJsonObjectAllForProtein2Pathways = {};
    vars.genesForProtein2Pathways =  vars.genes;
    vars.uniprotJsonObjectAllForProtein2Pathways = "";
    vars.massPtmProteinsForProtein2Pathways = "";
    vars.shorthandPtmProteinsForProtein2Pathways = "";
    vars.waitingForPeptideToProtein = false;
    vars.showOutputForPeptideToProtein = false;
    vars.proteinForm = "";
    vars.organismForm = "9606";
    vars.prositeFoundNum = 0;
    vars.motifLength = 0;
    vars.uniprotFoundNum = 0;
    vars.formatInput = false;
    vars.uniprotLength = 0;
    vars.geneIdListLength = 0;
    vars.peptideToModificationList = [];
    vars.peptideToModificationListOrig = [];
    vars.showOverAllParallelSVG = false;
    vars.showPLN = false;
    vars.showOutputSignor = false;
    vars.showOutputPtm = false;
    vars.showOutputPathway = false;
    vars.showPhosphoGeneNetwork = false;
    vars.showPhosphoDeepGeneNetwork = false;
    vars.showPtmGeneNetwork = false;
    vars.showSignorGeneNetwork = false;
    vars.blosum50Table = [];
    vars.deepPhosTable = [];
    vars.PTM_table = [];
    vars.signor_table = [];
    vars.ptmWaiting = false;
    vars.signorWaiting = false;
    vars.phosphoWaiting = false;
    vars.showPhosphoGeneNetworkProcessed = false;
    vars.showPhosphoDeepGeneNetworkProcessed = false;
    vars.showPtmGeneNetworkProcessed = false;
    vars.showSignorGeneNetworkProcessed = false;
    vars.plnFormatOne = [];
    vars.plnFormatTwo = [];
    vars.plnFormatThree = [];
    vars.prResponseList = [];
    vars.sequence_acListComplete = [];
    vars.phosphoNetwork = {};
    vars.ptmNetwork = {};
    vars.network = {};
    vars.kinaseNetwork = {};
    vars.kinaseTable = [];
    vars.signor_Network = {};
    vars.deepPhosNetwork = {};
    vars.enrichmentNetwork = {};
    vars.showGeneNetworkProcessed = false;
    vars.showGeneIlincsProcessed = false;
    vars.showGeneEnrichmentProcessed = false;
    vars.showGeneNetwork = false;
    vars.showKinaseNetworkProcessed = false;
    vars.ptmToModifierPtmOrGene = 'ptmProteinList';
    vars.proteinToPathwayPathwayOrGene = 'geneList';
    vars.computeWeightForUpdateEnrichment = true;
    vars.computeWeightForUpdate = true;
    vars.computeWeightForUpdateKinase = true;
    vars.computeWeightForUpdatePtm = true;
    vars.computeWeightForUpdateDeepPhos = true;
    vars.computeWeightForUpdateSignor = true;
    vars.computeWeightForUpdatePhospho = true;
    vars.list_of_positive_peps = [];
    vars.list_of_negative_peps = [];
    vars.list_of_positive_negative_peps = [];
    vars.peptideToAbundance = {};
    vars.peptideToNumberOfProteins = {};
    vars.ilincsSignatureUrl = "http://www.ilincs.org/ilincs/";
    //vars.showModal = true;


    vars.phosphoOptions = [
        {value: "Known_Kinase_TargetGene"},
        {value: "Predicted_Blosum50_Kinase_TargetGene"},
        {value: "Predicted_Probability_Kinase_TargetGene"}
    ];
    vars.tableGO = new NgTableParams({
        count: 5
    }, {
        total: 0,  dataset: [],counts: [5, 10, 25]});

    vars.tableSubCellular = new NgTableParams({
        count: 5
    }, {
        total: 0,  dataset: [],counts: [5, 10, 25]});

    vars.tableReactome = new NgTableParams({
        count: 5
    }, {
        total: 0,  dataset: [],counts: [5, 10, 25]});

    vars.ilincsCmapTable = new NgTableParams({
        count: 5
    }, {
        total: 0,  dataset: [],counts: [5, 10, 25]});

    vars.ilincsKnockdownTable = new NgTableParams({
        count: 5
    }, {
        total: 0,  dataset: [],counts: [5, 10, 25]});

    vars.ilincsPerturbationsTable = new NgTableParams({
        count: 5
    }, {
        total: 0,  dataset: [],counts: [5, 10, 25]});

    vars.inputArrayTable = new NgTableParams({
        count: 5
    }, {
        total: 0,  dataset: [],counts: [5, 10, 25]});

    vars.selectedArrayTable = new NgTableParams({
        count: 5
    }, {
        total: 0,  dataset: [],counts: [5, 10, 25]});



    vars.sliderFoldChangeValue = 2.0;
    vars.sliderSignificanceValue = 0.05;

    vars.list_of_positive_peps = [];
    vars.list_of_negative_peps = [];

    vars.uploadErrorTag = 200;
    vars.uploadErrorText = "";
    vars.inputArray = [];
    vars.selectedArray = [];
    vars.dataForAllPeptides = [];
    vars.volcanoJson = [];

    vars.subCellularTableData = [];
    vars.subCellularValues = [];
    vars.subCellularLabels = [];

    vars.reactomeTableData = [];
    vars.reactomeValues = [];
    vars.reactomeLabels = [];

    vars.goTableData = [];
    vars.goLabels = [];
    vars.goValues = [];

    vars.ex1orex2 = "ex1Id";
    vars.ex1orex2Protein = "ex1Id";
    vars.ex1orex2Pathway = "ex1Id";

    vars.showOutputex1orex2 = "ex1Id";

    vars.resultTab = "tab-1";
    vars.signatureTab = "tab-1";
    vars.proteinToPathwayResultTab = "tab5-1";
    vars.ptmResultTab = "tab-1";
    vars.helpTab = "tab5-1";

    vars.selectedphosphoPathways = vars.phosphoOptions[1];

    if($location.url().contains('ptmToModifier') || $location.url().contains('peptideToProtein') || $location.url().contains('proteinToPathway') || $location.url().contains('help') || $location.url().contains('upload') || $location.url().contains('modification')) {
        vars.showSplash = false;
        //console.log($location.url());
        //console.log("vars.showSplash");
        //console.log(vars.showSplash);
        //console.log($location.url());
        vars.firstVisit = false;
        //console.log(vars.firstVisit);
        //$scope.$apply();
    }
    //vars.tabForProtein2Pathways = 'ptmProteinList';
    //vars.organismFormProteinToPathway = "9606";
    vars.tabs = [
        {
            link: '/pinet/ptm',
            label: 'Post Translational Modification',
            info: 'Network analysis of Post translational modification of proteins'
        },
        {
            link: '/pinet/enrichment',
            label: 'Enrichment Analysis',
            info: 'Network Analysis of associated genes with the peptides or user defined genes'
        },
        {link: '/pinet/help', label: 'About PiNET', info: 'What is PiNET about?'},
        {link: '/pinet/contact', label: 'Contact US', info: 'Give us your feed-back about PiNET / Ask questions'}
    ];

    var deferred = $q.defer();


    return {

        getSiteVisit : function() {
            return $http.get("api/increment/" + 0)
                .then(function(response) {
                    // promise is fulfilled
                    //console.log(response);
                    deferred.resolve(response.data);
                    return response.data;
                    //return response.data;
                }, function(response) {
                    // the following line rejects the promise
                    deferred.reject(response);
                    return deferred.promise;
                });
        },

        getVar: function (variable) {
            return vars[variable.toString()];
        },

        setVar: function (key,value) {
            vars[key.toString()] = value;
        }
    }

});


appModule.controller('iFrameModalInstanceCtrl', ['$scope','$sce','$window','$uibModalInstance', 'linkID','type',
        function($scope,$sce,$window,$uibModalInstance,linkID,type) {

            $scope.ok = function () {
                // $uibModalInstance.close($scope.selected.item);
                $uibModalInstance.dismiss('cancel');
            };

            $scope.cancel = function () {
                $uibModalInstance.dismiss('cancel');
            };

            init = function() {
                //  console.log(linkID);
                //  console.log(type);
                // $scope.currentProject = $scope.projects[id];
                // $scope.currentSiteUrl = $sce.trustAsResourceUrl("http://stitch.embl.de/newstring_cgi/show_network_section.pl?identifier=CID000001833&required_score=200&limit=10&network_flavor=evidence");
                // $scope.currentSiteUrl = $sce.trustAsResourceUrl("http://stitch.embl.de/newstring_cgi/show_network_section.pl?identifier="+linkID+"&required_score=200&limit=10&network_flavor=evidence");
                switch (type) {
                    case "stitch":
                        // $scope.currentSiteUrl = $sce.trustAsResourceUrl("http://stitch.embl.de/newstring_cgi/show_network_section.pl?identifier="+linkID);  //stitch 4.0
                        // $scope.currentSiteUrl = $sce.trustAsResourceUrl("http://stitch.embl.de/interactions/"+linkID+"?species=9606&chemicalmode=11");  //without chemical-chemical links
                        // $scope.currentSiteUrl = $sce.trustAsResourceUrl("http://stitch.embl.de/interactions/"+linkID+"?species=9606&chemicalmode=12");  //with chemical-chemical links
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("http://stitch.embl.de/interactions/"+linkID+"?species=9606&chemicalmode=01");  //Show stereo-isomers as separate compounds
                        break;
                    case "pubChem":
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("https://pubchem.ncbi.nlm.nih.gov/compound/"+linkID);
                        break;

                    case "modOntology":
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("http://www.ebi.ac.uk/ols/ontologies/mod/terms?obo_id="+linkID);
                        break;

                    case "pinetUniprot":
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("http://www.rcsb.org/pdb/protein/"+linkID);
                        break;
                    case "pinetReactome":
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("https://reactome.org/content/detail/"+linkID);
                        break;
                    case "pinetGO":
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("https://www.ebi.ac.uk/QuickGO/term/"+linkID);
                        break;
                    case "pinetIlincs":
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("http://www.ilincs.org/ilincs/signature/"+linkID);
                        break;


                    case "pinetGeneCards":
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("http://www.genecards.org/cgi-bin/carddisp.pl?gene="+linkID);
                        break;

                    case "GPP":
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("http://portals.broadinstitute.org/gpp/public/clone/details?cloneId="+linkID);
                        break;
                    case "Genes":
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("http://www.ncbi.nlm.nih.gov/gene?cmd=Retrieve&dopt=full_report&list_uids="+linkID);
                        break;
                    case "GeneNCBI":
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("https://www.ncbi.nlm.nih.gov/gene/"+linkID);
                        break;
                    case "Ensembl":
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("https://www.ensembl.org/Homo_sapiens/Gene/Summary?g="+linkID);
                        break;
                    case "LIFE":
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("http://life.ccs.miami.edu/life/summary?mode=SmallMolecule&input="+linkID+"&source=LINCS");
                        break;
                    case "LDP":
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("http://lincsportal.ccs.miami.edu/SmallMolecules/#/view/"+linkID);
                        break;
                    case "LDPcell":
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("http://lincsportal.ccs.miami.edu/cells/#/view/"+linkID);
                        break;
                    case "CancerBrowser":
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("http://www.cancerbrowser.org/cell_line/"+linkID.toLowerCase());
                        break;
                    case "Pharos":
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("https://pharos.nih.gov/idg/ligands/"+linkID.toLowerCase());      //blocked by CORS
                        break;
                    case "GenomeBrowser":
                        // $scope.currentSiteUrl = $sce.trustAsResourceUrl("http://genome.cse.ucsc.edu/cgi-bin/hgTracks?org=Human&db=hg38&position="+linkID.toLowerCase());      //no reacting on org or db
                        // $scope.currentSiteUrl = $sce.trustAsResourceUrl("http://genome.cse.ucsc.edu/cgi-bin/hgTracks?position="+linkID);      //no reacting on org or db
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("http://genome.cse.ucsc.edu/cgi-bin/hgGene?db=hg38&hgg_gene="+linkID);      //no reacting on org or db
                        break;
                    case "Harmonizome":
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("http://amp.pharm.mssm.edu/Harmonizome/gene/"+linkID);
                        break;
                    case "geneCards":
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("http://www.genecards.org/cgi-bin/carddisp.pl?gene="+linkID);
                        break;
                    case "NCBOdisease":
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("https://bioportal.bioontology.org/ontologies/DOID/?p=classes&conceptid=http%3A%2F%2Fpurl.obolibrary.org%2Fobo%2F"+linkID);
                        break;
                    case "YouTube":
                        //  $scope.currentSiteUrl = $sce.trustAsResourceUrl("https://www.youtube.com/watch?v=K1tUuuNi3nA&list=PL0Bwuj8819U8d0lSxu4hxaPX64yJUOlzQ&index=9");
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("https://www.youtube.com/watch?v="+linkID+"&list=PL0Bwuj8819U8d0lSxu4hxaPX64yJUOlzQ");
                        // $scope.currentSiteUrl = $sce.trustAsResourceUrl("https://www.youtube.com/watch?v="+linkID);
                        // $scope.currentSiteUrl = $sce.trustAsResourceUrl("https://www.youtube.com/v/"+linkID+"&list=PL0Bwuj8819U8d0lSxu4hxaPX64yJUOlzQ");
                        // $scope.currentSiteUrl = $sce.trustAsResourceUrl("https://www.youtube.com/watch?list=PL0Bwuj8819U8d0lSxu4hxaPX64yJUOlzQ&v="+linkID);
                        //$scope.currentSiteUrl = $sce.trustAsResourceUrl("https://www.youtube.com/watch?v="+linkID);
                        $scope.currentSiteEmb = $sce.trustAsResourceUrl("https://www.youtube.com/embed/"+linkID);
                        // $scope.currentSiteEmb = $sce.trustAsResourceUrl("https://www.youtube.com/v/"+linkID);
                        break;
                    case "ScrubChem":
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("https://www.scrubchem.org/Home/Results?CIDs="+linkID+"&getJustifications=true");
                        break;
                    case "kNet":
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("http://knet.ccs.miami.edu/results/"+linkID);
                        break;
                    case "GTEx":
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("https://gtexportal.org/home/gene/"+linkID);
                        break;
                    case "atlasHeatmap":
                        // $scope.currentSiteUrl = $sce.trustAsResourceUrl("/ilincs/atlasHeatmap.html?gene="+linkID);
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("https://www.ebi.ac.uk/gxa/genes/"+linkID);
                        break;
                    case "EBIexp":
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("https://www.ebi.ac.uk/arrayexpress/experiments/"+linkID);
                        break;
                    case "FWDsig":
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("http://amp.pharm.mssm.edu/dmoa/sig/"+linkID);
                        break;
                    case "clueIoCompound":  //X-Frame Options deny
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl("https://clue.io/command?q="+linkID);
                        break;
                    case "corrPlot":
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl(linkID);
                        break;
                    default:
                        $scope.currentSiteUrl = $sce.trustAsResourceUrl(linkID);

                }

            }



            init();

        }]);



appModule.controller('ModalInstanceCtrl', ['$scope', '$uibModalInstance',function ($scope, $uibModalInstance) {
    //var $ctrl = this;


    $scope.ok = function () {
        console.log("in ok");
        //$uibModalInstance.close($ctrl.selected.item);
    };

    $scope.cancel = function () {
        console.log("in cancel");
        $uibModalInstance.dismiss('cancel');
    };
}]);


appModule.controller("AboutCtrl", ['$scope', '$http', '$location', '$window', '$timeout', '$routeParams', '$filter', '$q', 'filterFilter', 'SharedService', function ($scope, $http, $location, $window, $timeout, $routeParams, $filter, $q, filterFilter, SharedService) {
    //console.log("--------------- Restarting About! ---------------");
    SharedService.getSiteVisit().then(function(successResponse){
        $scope.siteVisit = successResponse;
        //console.log($scope.siteVisit);
    });
    self.uploadGraphWaiting = true;
    self.showGEGraph = false;
    $scope.showGEGraph = false;
    $scope.interest = "ATP";
    $scope.showColors = false;
    self.helpTab = SharedService.getVar("helpTab");
    //SharedService.setVar('showModal', false);
    $('input[name=tabs][id=' + self.helpTab + ']').prop('checked',true);
    $("input[name='tabs']").click(function () {
        self.helpTab = this.id;
        SharedService.setVar("helpTab", self.helpTab);

    });
    //
    // $(document).ready(function () {
    //     $("body").tooltip({selector: '[data-toggle=tooltip]'});
    // });
    // $(document).ready(function () {
    //     $('[data-toggle="tooltip"]').tooltip({
    //         trigger: 'hover'
    //     });
    // });
    // $(function () {
    //     $('[data-toggle="tooltip"]').tooltip()
    // })
    // $(document).ready(function () {
    //     $('[data-toggle="tooltip"]').tooltip({
    //         trigger: 'hover'
    //     });
    // });
    // $scope.tabClass = function (tab) {
    //     if ($scope.selectedTab == tab) {
    //         self.activeSite = $scope.selectedTab.link;
    //         return "active";
    //
    //     } else {
    //         return "";
    //     }
    // }
    // $(document).ready(function () {
    //     $("body").tooltip({selector: '[data-toggle=tooltip]'});
    // });

    //This is to activate tooltip otherwise it is not working on some occasions
    $(document).ready(function () {
        $("body").tooltip({selector: '[data-toggle=tooltip]'});
    });


    $scope.graphType = 0;
    $scope.circleSliderValue = 1100;
    $scope.nodeSliderValue = 15;
    $scope.fontSliderValue = 20;
    $scope.widthSliderValue = 1500;
    $(document).on('input', '#circle_slider', function() {
        $('#circle_slider_value').html( $(this).val() );
        ////console.log($(this).val());
        $scope.circleSliderValue = $(this).val();

        $scope.$apply();

        $scope.uploadFileGraph();
    });

    $(document).on('input', '#node_slider', function() {
        $('#node_slider_value').html( $(this).val() );
        ////console.log($(this).val());
        $scope.nodeSliderValue = $(this).val();

        $scope.$apply();

        $scope.uploadFileGraph();
    });

    $(document).on('input', '#font_slider', function() {
        $('#font_slider_value').html( $(this).val() );
        ////console.log($(this).val());
        $scope.fontSliderValue = $(this).val();

        $scope.$apply();

        $scope.uploadFileGraph();
    });

    $(document).on('input', '#width_slider', function() {
        $('#width_slider_value').html( $(this).val() );
        ////console.log($(this).val());
        $scope.widthSliderValue = $(this).val();

        $scope.$apply();

        $scope.uploadFileGraph();
    });


    $scope.uploadFileGraph = function(){

        self.uploadGraphWaiting = true;
        //self.showGEGraph = false;
        var file = $scope.myFileCSV;
        var fd = new FormData();
        self.uploadWaiting = true;
        self.showOutput = false;
        fd.append('file', file);
        var fileName = String(file.name).slice(0, -4).concat(String($scope.interest));
        console.log(fileName);

        //We can send anything in name parameter,
//it is hard coded to abc as it is irrelavant in this case.
        var uploadUrl = "api/uploadCSV";

        $http.post(uploadUrl, fd, {
            transformRequest: angular.identity,
            headers: {'Content-Type': undefined}
        })
        .success(function(response){
            console.log(response);
            var pNetwork = response;
            var ptmToAbundance = {};
            for (var iterNetNode = 0; iterNetNode < pNetwork.nodes.length; iterNetNode++)
            {
                //pNetwork.nodes[iterNetNode]["weight"] = 0;
                var iterNetNodeKey = pNetwork.nodes[iterNetNode]["name"];
                ptmToAbundance[iterNetNodeKey] = "NA";
                // if (iterNetNodeKey in ptmToAbundance)
                // {
                //     //console.log(iterNetNodeKey);
                //     if (ptmToAbundance[iterNetNodeKey] == "NA")
                //     {
                //         pNetwork.nodes[iterNetNode]["value"] = 0.0;
                //     }
                //     else {
                //         pNetwork.nodes[iterNetNode]["value"] = ptmToAbundance[iterNetNodeKey];
                //     }
                // }
            }



            $scope.makeGEGraph(response, ptmToAbundance, fileName, $scope.fontSliderValue, $scope.widthSliderValue, $scope.circleSliderValue, $scope.nodeSliderValue, $scope.graphType);
            self.uploadGraphWaiting = false;
            self.showGEGraph = true;
        })
        .error(function(response){
            self.uploadGraphWaiting = false;
            self.showGEGraph = true;
        });
    }



    $scope.makeGEGraph = function (network, ptmToAbundance, fileName, fontSize, widthSize, circleSize, nodeSize, graphType) {
        //console.log(self.computeWeightForUpdatePtm);

        self.showGEGraph = true;
        d3.select("#chartGE").select("svg").remove();
        if (typeof svgGE === 'undefined') {
            var svgGE = d3.selectAll("#chartGE").append("svg");
        }
        //var svg4 = d3.selectAll("#chart4").append("svg");


        var force;
        var colNodeScaleSeparate = d3.scale.ordinal()
            .range(["#987024", "#ed0909", "#0af702", "#d506d8"])
            //.range(["#987024", "#982482", "#0af702"])
            .domain([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);
//#f9a3f5
        // var colNodeScaleSeparate = d3.scale.ordinal()
        //     .range(["#767776", "#f91104", "#0af702"])
        //     .domain([0,1,2]);

        // var colNodeScale = d3.scale.linear().range(["#987024", "#ed0909"]);
        // var colScale = d3.scale.linear().range(["#987024", "#ed0909"]);

        var colScale = d3.scale.ordinal()
            .range(["#987024", "#ed0909", "#0af702", "#d506d8"])
            //.range(["#987024", "#982482", "#0af702"])
            .domain([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);

        var colNodeScale = d3.scale.ordinal()
            .range(["#987024", "#ed0909", "#0af702", "#d506d8"])
            //.range(["#987024", "#982482", "#0af702"])
            .domain([1, 2, 3, 4]);
        var edgeWeightScale = d3.scale.linear().range([1, 3]);
        var xScale = d3.scale.linear().range([nodeSize/3.0, nodeSize]);
        var scoreScale = d3.scale.linear().range([1.0, 3.0]).domain([0.0, 1.0]);
        var textPlacePlusMinus = d3.scale.ordinal()
            .range([18, -18, -18, -18, -18, -18, -18, -18, -18, -18, -18, -18, -18, -18, -18, -18, -18, -18, -18, -18, -18, -18, -18, -18])
            .domain([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]);
        var textPlaceStartEnd = d3.scale.ordinal().range(["end", "end", "end", "end", "end", "end", "end", "end", "end", "end", "end", "end", "end", "end", "end", "end", "end", "end", "end", "end", "end", "end", "end", "end"])
            .domain([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]);

        var colorsForAbundance = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
        var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];
        var colorScale = d3.scale.threshold()
            .domain(domain_data)
            .range(colorsForAbundance);


        function updateGE(nodes, links, fontSize, widthSize, circleSize, nodeSize) {

            circleSize = Math.min(circleSize, widthSize - 300);
            //
            //var svg;


            // $('force1').click();
            //document.getElementById('force1').click();

            // //console.log(circularLayout);



            // self.computeWeightForupdatePtm = false;
            // SharedService.setVar('computeWeightForupdatePtm', self.computeWeightForupdatePtm);




            // Set-up the export button
            // d3.select('#download-png').on('click', function() {
            //
            // })
            function circularViewGE() {
                svgGE.remove();

                xScale.domain(d3.extent(nodes, function (d) {
                    return d.weight;
                }));
                scoreScale.domain(d3.extent(links, function (d) {
                    return d.weight;
                }));
                colNodeScale.domain(d3.extent(nodes, function (d) {
                    return d.group;
                }));
                colScale.domain(d3.extent(links, function (d) {
                    return d.weight;
                }));
                var margin = 75,
                    w = widthSize - 2 * margin,
                    h = w,
                    radius = w / 2,
                    strokeWidth = 4,
                    hyp2 = Math.pow(radius, 2),
                    nodeBaseRad = 5;


                globalH = h;
                globalHPlus50 = h + 50;
                globalW = w;


                svgGE = d3.select("#chartGE")
                    .append("svg")
                    .attr("style", "outline: thin solid yellow;")
                    .attr("width", w)
                    .attr("height", globalHPlus50);
                svgGE.append("rect")
                    .attr("width", "100%")
                    .attr("height", "100%")
                    .attr("fill", "white");


                // This is for grouping nodes


                var force = d3.layout.force()
                    .nodes(nodes)
                    .links(links)
                    .size([w, h]);

// evenly spaces nodes along arc
                var circleCoord = function (node, index, input_num_nodes, has_focus) {
                    //console.log("in circleCoord");

                    // console.log(node["name"]);
                    // console.log(index);
                    // String(node["name"]).valueOf() ==
                    var circumference = circle.node().getTotalLength();
                    var pointAtLength = function (l) {
                        return circle.node().getPointAtLength(l)
                    };


                    if (has_focus){
                        var added_num = parseInt(input_num_nodes/4);
                        if (added_num%2 == 1){
                            added_num += 1;
                        }
                        var num_nodes = input_num_nodes + added_num;
                        var sectionLength = (circumference) / num_nodes;
                        if (String(node["name"]).valueOf() === $scope.interest){
                            var position = 0;
                            // console.log("in ATP");
                            // console.log(pointAtLength(circumference - position));
                            // console.log(position);
                        }
                        else {


                            var position = sectionLength * (index + added_num/2) + sectionLength / 2;
                        }
                    }
                    else{
                        var num_nodes = input_num_nodes;
                        var sectionLength = (circumference) / num_nodes;
                        var position = sectionLength * (index) + sectionLength / 2;

                    }

                    //console.log(pointAtLength(circumference - position));
                    return pointAtLength(circumference - position)
                }

                var is_connected = function (d, opacity) {
                    lines.transition().style("stroke-opacity", function (o) {
                        return o.source === d || o.target === d ? 1 : opacity;
                    });
                }

                var is_connected_on_click = function (d, opacity) {
                    //console.log(d);
                    lines.transition().style("stroke-opacity", function (o) {
                        return o.source.group === d.group || o.target.group === d.group ? 1 : opacity;
                    });
                }
                // var dim = w - 900
                // var circle = svgGE.append("path")
                //     .attr("d", "M 450, " + (dim / 2 + 450) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                //     .style("fill", "white");

                var dim = w - (widthSize - circleSize)
                var circle = svgGE.append("path")
                    .attr("d", "M " + String((widthSize - circleSize)/2) + ", " + (dim / 2 + (widthSize - circleSize)/2) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                    .style("fill", "white");

                force.start();
                var has_focus = false;
                nodes.forEach(function (n, i) {
                    if (String(n["name"]).valueOf() == $scope.interest){
                        //if (String(n["name"]).valueOf() === $scope.interest) {
                        has_focus = true;
                    }

                })
                nodes.forEach(function (n, i) {
                    var coord = circleCoord(n, i, nodes.length, has_focus)
                    n.x = coord.x
                    n.y = coord.y
                });


                // use this one for straight line links...
                // var lines = svg.selectAll("line.node-link")
                //     .data(links).enter().append("line")
                //     .attr("class", "node-link")
                //     .attr("x1", function(d) { return d.source.x; })
                //     .attr("y1", function(d) { return d.source.y; })
                //     .attr("x2", function(d) { return d.target.x; })
                //     .attr("y2", function(d) { return d.target.y; });

                var lines = svgGE.selectAll("path.node-link")
                    .data(links).enter().append("path")
                    .style("fill", "none")
                    .style("stroke", function (d) {

                        if (d.tag == 0) {
                            return("#696969");
                        }
                        else if (d.tag == 1) {
                            return("#006400");
                        }
                        else if (d.tag == 2) {
                            return("#00FF00");
                        }
                        else if (d.tag == 3) {
                            return("#0000FF");
                        }
                        else if (d.tag == 4) {
                            return("#808080");
                        }
                        else if (d.tag == 5) {
                            return("#8B4513");
                        }
                        else if (d.tag == 6) {
                            return("#FFFFE0");
                        }
                        else if (d.tag == 7) {
                            return("#8464c5");
                        }
                        else if (d.tag == 8) {
                            return("#00FFFF");
                        }
                        else if (d.tag == 9) {
                            return("#FF7F50");
                        }
                        else if (d.tag == 10) {
                            return("#FF0000");
                        }
                        else if (d.tag == 11) {
                            return("#FF00FF");
                        }
                        else if (d.tag == 12) {
                            return("#8FBC8F");
                        }
                        else if (d.tag == 13) {
                            return("#A52A2A");
                        }
                        else if (d.tag == 14) {
                            return("#FFD700");
                        }
                        else if (d.tag == 15) {
                            return("#A0522D");
                        }
                        else if (d.tag == 16) {
                            return("#FFFF00");
                        }
                        else if (d.tag == 17) {
                            return("#6A5ACD");
                        }
                        else if (d.tag == 18) {
                            return("#708090");
                        }
                        else if (d.tag == 19) {
                            return("#FF6347");
                        }
                        else if (d.tag == 20) {
                            return("#CD5C5C");
                        }
                        else if (d.tag == 21) {
                            return("#DB7093");
                        }
                        else if (d.tag == 22) {
                            return("#2E8B57");
                        }
                        else if (d.tag == 23) {
                            return("#000080");
                        }
                        else if (d.tag == 24) {
                            return("#9370DB");
                        }
                        else if (d.tag == 25) {
                            return("#A52A2A");
                        }
                        else if (d.tag == 26) {
                            return("#FDF5E6");
                        }
                        else if (d.tag == 27) {
                            return("#7B68EE");
                        }
                        else if (d.tag == 28) {
                            return("#696969");
                        }
                        else if (d.tag == 29) {
                            return("#FF4500");
                        }
                        else if (d.tag == 30) {
                            return("#DC143C");
                        }
                        else if (d.tag == 31) {
                            return("#FF69B4");
                        }
                        else if (d.tag == 32) {
                            return("#006400");
                        }
                        else if (d.tag == 33) {
                            return("#87CEEB");
                        }
                        else if (d.tag == 34) {
                            return("#EE82EE");
                        }
                        else if (d.tag == 35) {
                            return("#800000");
                        }
                        else if (d.tag == 36) {
                            return("#FAEBD7");
                        }
                        else if (d.tag == 37) {
                            return("#4B0082");
                        }
                        else if (d.tag == 38) {
                            return("#808080");
                        }
                        else if (d.tag == 39) {
                            return("#FF8C00");
                        }
                        else if (d.tag == 40) {
                            return("#FA8072");
                        }
                        else if (d.tag == 41) {
                            return("#FFC0CB");
                        }
                        else if (d.tag == 42) {
                            return("#9ACD32");
                        }
                        else if (d.tag == 43) {
                            return("#4682B4");
                        }
                        else if (d.tag == 44) {
                            return("#DDA0DD");
                        }
                        else if (d.tag == 45) {
                            return("#CD853F");
                        }
                        else if (d.tag == 46) {
                            return("#FFE4E1");
                        }
                        else if (d.tag == 47) {
                            return("#696969");
                        }
                        else if (d.tag == 48) {
                            return("#A9A9A9");
                        }
                        else if (d.tag == 49) {
                            return("#FFA500");
                        }
                        else{
                            return("#000000");
                        }













                        // if (d.group == 0) {
                        //     return colorScale(d.value);
                        // }
                        // else {
                        //
                        //     if (d.group == 1) {
                        //         return("#ed0909");
                        //     }
                        //     if (d.group == 2) {
                        //         return("#0af702");
                        //     }
                        //     if (d.group == 3) {
                        //         return("#FF00FF");
                        //     }
                        //     if (d.group == 4) {
                        //         return("#808000");
                        //     }
                        //     if (d.group == 5) {
                        //         return("#000080");
                        //     }
                        //     if (d.group == 6) {
                        //         return("#800080");
                        //     }
                        //     if (d.group == 7) {
                        //         return("#00ffff");
                        //     }
                        //     if (d.group == 8) {
                        //         return("#F5F5DC");
                        //     }
                        //     if (d.group == 9) {
                        //         return("#A52A2A");
                        //     }
                        //     if (d.group == 10) {
                        //         return("#8B0000");
                        //     }
                        //     if (d.group == 11) {
                        //         return("#FF8C00");
                        //     }
                        //
                        // }

                    })
                    //.style("stroke", "#726363")
                    .attr("class", "node-link")
                    .style("stroke-width", function (d) {return scoreScale(d.weight); })
                    .attr("d", function (d) {

                        //
                        // var dx = d.target.x - d.source.x,
                        //     dy = d.target.y - d.source.y,
                        //     dr = Math.sqrt(dx * dx + dy * dy),
                        //     a1 = dx,
                        //     a2 = dy,
                        //     b1 = w/2 - d.source.x,
                        //     b2 = h/2 - d.source.y,
                        //
                        //     drx = dr/1.5,
                        //     dry = dr/1.5,
                        //     xRotation = 0, // degrees
                        //     largeArc = 0, // 1 or 0
                        //
                        //     sweep = 1, // 1 or 0
                        //     x2 = d.target.x,
                        //     y2 = d.target.y;
                        // if( (a1*b2 - a2*b1) > 0)
                        // {
                        //     sweep = 0
                        // }
                        // else
                        // {sweep = 1}
                        //
                        //
                        // return "M" + d.source.x + "," + d.source.y + "A" + drx + "," + dry + " " + xRotation + "," + largeArc + "," + sweep + " " + x2 + "," + y2;
                        //
                        //










                        var dx = d.target.x - d.source.x,
                            dy = d.target.y - d.source.y,
                            dr = Math.sqrt(dx * dx + dy * dy);
                        return "M" +
                            d.source.x + "," +
                            d.source.y + "," +
                            d.target.x + "," +
                            d.target.y;

                    });


                var gnodes = svgGE.selectAll('g.gnode')
                    .data(nodes).enter().append('g')
                    .attr("transform", function (d) {
                        return "translate(" + d.x + "," + d.y + ")"
                    })
                    .classed('gnode', true);


                // node.append("circle")
                //     .attr("r", function (d) { return xScale(d.weight); })
                //     .style("fill", function(d) { return colNodeScale(d.group); });

                var node = gnodes.append("circle")
                    .attr("r", function (d) {
                        return xScale(d.weight);
                    })
                    .style("fill", function (d) {

                        if (d.group == 0) {
                            return("#696969");
                        }
                        else if (d.group == 1) {
                            return("#006400");
                        }
                        else if (d.group == 2) {
                            return("#00FF00");
                        }
                        else if (d.group == 3) {
                            return("#0000FF");
                        }
                        else if (d.group == 4) {
                            return("#808080");
                        }
                        else if (d.group == 5) {
                            return("#8B4513");
                        }
                        else if (d.group == 6) {
                            return("#FFFFE0");
                        }
                        else if (d.group == 7) {
                            return("#8464c5");
                        }
                        else if (d.group == 8) {
                            return("#00FFFF");
                        }
                        else if (d.group == 9) {
                            return("#FF7F50");
                        }
                        else if (d.group == 10) {
                            return("#FF0000");
                        }
                        else if (d.group == 11) {
                            return("#FF00FF");
                        }
                        else if (d.group == 12) {
                            return("#8FBC8F");
                        }
                        else if (d.group == 13) {
                            return("#A52A2A");
                        }
                        else if (d.group == 14) {
                            return("#FFD700");
                        }
                        else if (d.group == 15) {
                            return("#A0522D");
                        }
                        else if (d.group == 16) {
                            return("#FFFF00");
                        }
                        else if (d.group == 17) {
                            return("#6A5ACD");
                        }
                        else if (d.group == 18) {
                            return("#708090");
                        }
                        else if (d.group == 19) {
                            return("#FF6347");
                        }
                        else if (d.group == 20) {
                            return("#CD5C5C");
                        }
                        else if (d.group == 21) {
                            return("#DB7093");
                        }
                        else if (d.group == 22) {
                            return("#2E8B57");
                        }
                        else if (d.group == 23) {
                            return("#000080");
                        }
                        else if (d.group == 24) {
                            return("#9370DB");
                        }
                        else if (d.group == 25) {
                            return("#A52A2A");
                        }
                        else if (d.group == 26) {
                            return("#FDF5E6");
                        }
                        else if (d.group == 27) {
                            return("#7B68EE");
                        }
                        else if (d.group == 28) {
                            return("#696969");
                        }
                        else if (d.group == 29) {
                            return("#FF4500");
                        }
                        else if (d.group == 30) {
                            return("#DC143C");
                        }
                        else if (d.group == 31) {
                            return("#FF69B4");
                        }
                        else if (d.group == 32) {
                            return("#006400");
                        }
                        else if (d.group == 33) {
                            return("#87CEEB");
                        }
                        else if (d.group == 34) {
                            return("#EE82EE");
                        }
                        else if (d.group == 35) {
                            return("#800000");
                        }
                        else if (d.group == 36) {
                            return("#FAEBD7");
                        }
                        else if (d.group == 37) {
                            return("#4B0082");
                        }
                        else if (d.group == 38) {
                            return("#808080");
                        }
                        else if (d.group == 39) {
                            return("#FF8C00");
                        }
                        else if (d.group == 40) {
                            return("#FA8072");
                        }
                        else if (d.group == 41) {
                            return("#FFC0CB");
                        }
                        else if (d.group == 42) {
                            return("#9ACD32");
                        }
                        else if (d.group == 43) {
                            return("#4682B4");
                        }
                        else if (d.group == 44) {
                            return("#DDA0DD");
                        }
                        else if (d.group == 45) {
                            return("#CD853F");
                        }
                        else if (d.group == 46) {
                            return("#FFE4E1");
                        }
                        else if (d.group == 47) {
                            return("#696969");
                        }
                        else if (d.group == 48) {
                            return("#A9A9A9");
                        }
                        else if (d.group == 49) {
                            return("#FFA500");
                        }

                        else if (d.group == 117) {
                            return ("#FFD600FF");
                        }
                        else if (d.group == 64) {
                            return ("#FF7600FF");
                        }
                        else if (d.group == 85) {
                            return ("#FFFF9CFF");
                        }
                        else if (d.group == 95) {
                            return ("#FF3000FF");
                        }
                        else if (d.group == 123) {
                            return ("#FFFF0BFF");
                        }
                        else if (d.group == 88) {
                            return ("#FFFFF1FF");
                        }
                        else if (d.group == 73) {
                            return ("#FFC800FF");
                        }
                        else if (d.group == 118) {
                            return ("#FFDD00FF");
                        }
                        else if (d.group == 129) {
                            return ("#FFFF8AFF");
                        }
                        else if (d.group == 54) {
                            return ("#FF1B00FF");
                        }
                        else if (d.group == 122) {
                            return ("#FFF800FF");
                        }
                        else if (d.group == 130) {
                            return ("#FFFF9FFF");
                        }
                        else if (d.group == 99) {
                            return ("#FF5300FF");
                        }
                        else if (d.group == 98) {
                            return ("#FF4C00FF");
                        }
                        else if (d.group == 56) {
                            return ("#FF2E00FF");
                        }
                        else if (d.group == 89) {
                            return ("#FF0700FF");
                        }
                        else if (d.group == 110) {
                            return ("#FF9F00FF");
                        }
                        else if (d.group == 101) {
                            return ("#FF6000FF");
                        }
                        else if (d.group == 93) {
                            return ("#FF2200FF");
                        }
                        else if (d.group == 53) {
                            return ("#FF1200FF");
                        }
                        else if (d.group == 108) {
                            return ("#FF9100FF");
                        }
                        else if (d.group == 69) {
                            return ("#FFA400FF");
                        }
                        else if (d.group == 75) {
                            return ("#FFDB00FF");
                        }
                        else if (d.group == 76) {
                            return ("#FFE400FF");
                        }
                        else if (d.group == 119) {
                            return ("#FFE300FF");
                        }
                        else if (d.group == 134) {
                            return ("#FFFFF4FF");
                        }
                        else if (d.group == 62) {
                            return ("#FF6400FF");
                        }
                        else if (d.group == 127) {
                            return ("#FFFF60FF");
                        }
                        else if (d.group == 121) {
                            return ("#FFF100FF");
                        }
                        else if (d.group == 109) {
                            return ("#FF9800FF");
                        }
                        else if (d.group == 116) {
                            return ("#FFCF00FF");
                        }
                        else if (d.group == 124) {
                            return ("#FFFF20FF");
                        }
                        else if (d.group == 131) {
                            return ("#FFFFB5FF");
                        }
                        else if (d.group == 90) {
                            return ("#FF0E00FF");
                        }
                        else if (d.group == 114) {
                            return ("#FFBA00FF");
                        }
                        else if (d.group == 72) {
                            return ("#FFBF00FF");
                        }
                        else if (d.group == 52) {
                            return ("#FF0900FF");
                        }
                        else if (d.group == 63) {
                            return ("#FF6D00FF");
                        }
                        else if (d.group == 79) {
                            return ("#FFFF00FF");
                        }
                        else if (d.group == 80) {
                            return ("#FFFF0EFF");
                        }
                        else if (d.group == 78) {
                            return ("#FFF600FF");
                        }
                        else if (d.group == 107) {
                            return ("#FF8A00FF");
                        }
                        else if (d.group == 87) {
                            return ("#FFFFD4FF");
                        }
                        else if (d.group == 59) {
                            return ("#FF4900FF");
                        }
                        else if (d.group == 55) {
                            return ("#FF2400FF");
                        }
                        else if (d.group == 106) {
                            return ("#FF8300FF");
                        }
                        else if (d.group == 113) {
                            return ("#FFB300FF");
                        }
                        else if (d.group == 51) {
                            return ("#FF0000FF");
                        }
                        else if (d.group == 74) {
                            return ("#FFD100FF");
                        }
                        else if (d.group == 82) {
                            return ("#FFFF47FF");
                        }
                        else if (d.group == 104) {
                            return ("#FF7500FF");
                        }
                        else if (d.group == 66) {
                            return ("#FF8900FF");
                        }
                        else if (d.group == 133) {
                            return ("#FFFFDFFF");
                        }
                        else if (d.group == 86) {
                            return ("#FFFFB8FF");
                        }
                        else if (d.group == 65) {
                            return ("#FF8000FF");
                        }
                        else if (d.group == 132) {
                            return ("#FFFFCAFF");
                        }
                        else if (d.group == 58) {
                            return ("#FF4000FF");
                        }
                        else if (d.group == 105) {
                            return ("#FF7C00FF");
                        }
                        else if (d.group == 102) {
                            return ("#FF6700FF");
                        }
                        else if (d.group == 96) {
                            return ("#FF3E00FF");
                        }
                        else if (d.group == 125) {
                            return ("#FFFF35FF");
                        }
                        else if (d.group == 81) {
                            return ("#FFFF2BFF");
                        }
                        else if (d.group == 83) {
                            return ("#FFFF63FF");
                        }
                        else if (d.group == 120) {
                            return ("#FFEA00FF");
                        }
                        else if (d.group == 71) {
                            return ("#FFB600FF");
                        }
                        else if (d.group == 67) {
                            return ("#FF9200FF");
                        }
                        else if (d.group == 97) {
                            return ("#FF4500FF");
                        }
                        else if (d.group == 112) {
                            return ("#FFAC00FF");
                        }
                        else if (d.group == 61) {
                            return ("#FF5B00FF");
                        }
                        else if (d.group == 91) {
                            return ("#FF1500FF");
                        }
                        else if (d.group == 115) {
                            return ("#FFC100FF");
                        }
                        else if (d.group == 103) {
                            return ("#FF6E00FF");
                        }
                        else if (d.group == 70) {
                            return ("#FFAD00FF");
                        }
                        else if (d.group == 84) {
                            return ("#FFFF80FF");
                        }
                        else if (d.group == 126) {
                            return ("#FFFF4AFF");
                        }
                        else if (d.group == 100) {
                            return ("#FF5A00FF");
                        }
                        else if (d.group == 77) {
                            return ("#FFED00FF");
                        }
                        else if (d.group == 68) {
                            return ("#FF9B00FF");
                        }
                        else if (d.group == 57) {
                            return ("#FF3700FF");
                        }
                        else if (d.group == 92) {
                            return ("#FF1C00FF");
                        }
                        else if (d.group == 60) {
                            return ("#FF5200FF");
                        }
                        else if (d.group == 111) {
                            return ("#FFA500FF");
                        }
                        else if (d.group == 94) {
                            return ("#FF2900FF");
                        }
                        else if (d.group == 128) {
                                return ("#FFFF75FF");
                            }

                            else{
                            return("#000000");
                        }













                        // if (d.group == 0) {
                        //     return colorScale(d.value);
                        // }
                        // else {
                        //
                        //     if (d.group == 1) {
                        //         return("#ed0909");
                        //     }
                        //     if (d.group == 2) {
                        //         return("#0af702");
                        //     }
                        //     if (d.group == 3) {
                        //         return("#FF00FF");
                        //     }
                        //     if (d.group == 4) {
                        //         return("#808000");
                        //     }
                        //     if (d.group == 5) {
                        //         return("#000080");
                        //     }
                        //     if (d.group == 6) {
                        //         return("#800080");
                        //     }
                        //     if (d.group == 7) {
                        //         return("#00ffff");
                        //     }
                        //     if (d.group == 8) {
                        //         return("#F5F5DC");
                        //     }
                        //     if (d.group == 9) {
                        //         return("#A52A2A");
                        //     }
                        //     if (d.group == 10) {
                        //         return("#8B0000");
                        //     }
                        //     if (d.group == 11) {
                        //         return("#FF8C00");
                        //     }
                        //
                        // }

                    })

                    // .style("fill", function (d) {
                    //     return colNodeScale(d.group);
                    // })
                    .style("stroke", "#333")
                    .style("stroke-width", "2px")
                    .style("stroke-dasharray",
                        function (d) {
                            if (d.connected == "No") {
                                ////console.log("not connected");
                                return (5, 5);

                            }
                            else if(d.connected == "Yes") {
                                ////console.log("connected");
                                return (3, 0);
                            }
                        })

                    //.attr("class", "node")
                    .on("mouseenter", function (d) {
                        is_connected(d, 0.1)
                        node.transition().duration(100).attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        d3.select(this).transition().duration(100).attr("r", function (d) {
                            return xScale(d.weight + 3);
                        })
                    })
                    .on("mouseleave", function (d) {
                        node.transition().duration(100).attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        //is_connected(d, 1);
                    })
                    .on("click", function(d){

                        //if(!first_click) {
                        is_connected_on_click(d, 0.1);
                        node.transition().duration(100).attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        d3.select(this).transition().duration(100).attr("r", function (d) {
                            return xScale(d.weight + 3);
                        })

                    })
                    .call(force.drag);

                var labels = gnodes.append("text")
                    .attr("dx", 4)
                    .attr("dy", 4)
                    .style("font", String(fontSize) + "px Arial")
                    .attr("text-anchor", function (d) {
                        return d.x < w / 2 ? "end" : "start";
                    })
                    .attr("transform", function (d) {
                        return d.x < w / 2 ? "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(-20)" : "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(20)";
                    })
                    //.attr("transform", function(d) { return  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")"})
                    //.attr("transform", function(d) { return (d.x-w/2)/(d.y-w/2) < 0 ?  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")" : "rotate(180)"; })
                    .text(function (d) {
                        return d.full_name
                    })

                var drag = force.drag()
                    .on("dragstart", dragstart);
                //.on("dragstart", dragstartAll);


                //For not moving after drag
                function dragstart(d) {
                    d3.select(this).classed("fixed", d.fixed = true);

                    for (i = 0; i < nodes.length; i++) {
                        nodes[i].fixed = true;
                    }
                }


                var svgText = svgGE.append("text");
                svgText.attr("x",10).attr("y",globalHPlus50-50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                //Added from here for coloring the legend
                max_data = 1000;
                min_data = -1000;
                if (1 == 0) {

                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);


                    var legend2 = svgGE.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());
                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(globalW / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svgGE.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svgGE.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svgGE.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", "11px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();
                }


            };
            d3.select('#circularViewGE').on('click', function () {
                circularViewGE();
                $scope.graphType = 1;
            });

            function circosViewGE(){
                svgGE.remove();

                xScale.domain(d3.extent(nodes, function (d) {
                    return d.weight;
                }));
                scoreScale.domain(d3.extent(links, function (d) {
                    return d.weight;
                }));
                colNodeScale.domain(d3.extent(nodes, function (d) {
                    return d.group;
                }));
                colScale.domain(d3.extent(links, function (d) {
                    return d.weight;
                }));
                var margin = 75,
                    w = widthSize - 2 * margin,
                    h = w,
                    radius = w / 2,
                    strokeWidth = 4,
                    hyp2 = Math.pow(radius, 2),
                    nodeBaseRad = 5;


                globalH = h;
                globalHPlus50 = h + 50;
                globalW = w;

                var first_click = false;


                svgGE = d3.select("#chartGE")
                    .append("svg")
                    .attr("style", "outline: thin solid yellow;")
                    .attr("width", w)
                    .attr("height", globalHPlus50);
                svgGE.append("rect")
                    .attr("width", "100%")
                    .attr("height", "100%")
                    .attr("fill", "white");


                // This is for grouping nodes


                var force = d3.layout.force()
                    .nodes(nodes)
                    .links(links)
                    .size([w, h]);

// evenly spaces nodes along arc
                var circleCoord = function (node, index, input_num_nodes, has_focus) {
                    //console.log("in circleCoord");

                    // console.log(node["name"]);
                    // console.log(index);
                    // String(node["name"]).valueOf() ==
                    var circumference = circle.node().getTotalLength();
                    var pointAtLength = function (l) {
                        return circle.node().getPointAtLength(l)
                    };


                    if (has_focus){
                        var added_num = parseInt(input_num_nodes/4);
                        if (added_num%2 == 1){
                            added_num += 1;
                        }
                        var num_nodes = input_num_nodes + added_num;
                        var sectionLength = (circumference) / num_nodes;
                        if (String(node["name"]).valueOf() === $scope.interest){
                            var position = 0;
                            // console.log("in ATP");
                            // console.log(pointAtLength(circumference - position));
                            // console.log(position);
                        }
                        else {


                            var position = sectionLength * (index + added_num/2) + sectionLength / 2;
                        }
                    }
                    else{
                        var num_nodes = input_num_nodes;
                        var sectionLength = (circumference) / num_nodes;
                        var position = sectionLength * (index) + sectionLength / 2;

                    }

                    //console.log(pointAtLength(circumference - position));
                    return pointAtLength(circumference - position)
                }

                var is_connected = function (d, opacity) {
                    lines.transition().style("stroke-opacity", function (o) {
                        return o.source === d || o.target === d ? 1 : opacity;
                    });
                }



                // lines.transition().style("stroke-opacity", function (o) {
                //     if (o.source === d || o.target === d){
                //         return 1;
                //     }
                //
                // });

                var is_connected_on_click = function (d, opacity) {
                    //console.log(d);
                    lines.transition().style("stroke-opacity", function (o) {
                        return o.source.group === d.group || o.target.group === d.group ? 1 : opacity;
                    });
                }

                // var dim = w - 400
                // var circle = svgGE.append("path")
                //     .attr("d", "M 200, " + (dim / 2 + 200) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                //     .style("fill", "white");

                var dim = w - (widthSize - circleSize)
                var circle = svgGE.append("path")
                    .attr("d", "M " + String((widthSize - circleSize)/2) + ", " + (dim / 2 + (widthSize - circleSize)/2) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                    .style("fill", "white");

                force.start();
                var has_focus = false;
                nodes.forEach(function (n, i) {
                    if (String(n["name"]).valueOf() == $scope.interest){
                        //if (String(n["name"]).valueOf() === $scope.interest) {
                        has_focus = true;
                    }

                })

                console.log(has_focus);
                nodes.forEach(function (n, i) {
                    var coord = circleCoord(n, i, nodes.length, has_focus)
                    // console.log("calculating coor");
                    // console.log(coord);
                    // console.log(coord.x);
                    // console.log(coord.y);
                    n.x = coord.x
                    n.y = coord.y
                });


                // use this one for straight line links...
                // var lines = svg.selectAll("line.node-link")
                //     .data(links).enter().append("line")
                //     .attr("class", "node-link")
                //     .attr("x1", function(d) { return d.source.x; })
                //     .attr("y1", function(d) { return d.source.y; })
                //     .attr("x2", function(d) { return d.target.x; })
                //     .attr("y2", function(d) { return d.target.y; });

                var lines = svgGE.selectAll("path.node-link")
                    .data(links).enter().append("path")
                    .style("fill", "none")
                    .style("stroke", function (d) {


                        if (d.tag == 0) {
                            return("#696969");
                        }

                        else if (d.tag == 1) {
                            return("#006400");
                        }
                        else if (d.tag == 2) {
                            return("#00FF00");
                        }
                        else if (d.tag == 3) {
                            return("#0000FF");
                        }
                        else if (d.tag == 4) {
                            return("#808080");
                        }
                        else if (d.tag == 5) {
                            return("#8B4513");
                        }
                        else if (d.tag == 6) {
                            return("#FFFFE0");
                        }
                        else if (d.tag == 7) {
                            return("#8464c5");
                        }
                        else if (d.tag == 8) {
                            return("#00FFFF");
                        }
                        else if (d.tag == 9) {
                            return("#FF7F50");
                        }
                        else if (d.tag == 10) {
                            return("#FF0000");
                        }
                        else if (d.tag == 11) {
                            return("#FF00FF");
                        }
                        else if (d.tag == 12) {
                            return("#8FBC8F");
                        }
                        else if (d.tag == 13) {
                            return("#A52A2A");
                        }
                        else if (d.tag == 14) {
                            return("#FFD700");
                        }
                        else if (d.tag == 15) {
                            return("#A0522D");
                        }
                        else if (d.tag == 16) {
                            return("#FFFF00");
                        }
                        else if (d.tag == 17) {
                            return("#6A5ACD");
                        }
                        else if (d.tag == 18) {
                            return("#708090");
                        }
                        else if (d.tag == 19) {
                            return("#FF6347");
                        }
                        else if (d.tag == 20) {
                            return("#CD5C5C");
                        }
                        else if (d.tag == 21) {
                            return("#DB7093");
                        }
                        else if (d.tag == 22) {
                            return("#2E8B57");
                        }
                        else if (d.tag == 23) {
                            return("#000080");
                        }
                        else if (d.tag == 24) {
                            return("#9370DB");
                        }
                        else if (d.tag == 25) {
                            return("#A52A2A");
                        }
                        else if (d.tag == 26) {
                            return("#FDF5E6");
                        }
                        else if (d.tag == 27) {
                            return("#7B68EE");
                        }
                        else if (d.tag == 28) {
                            return("#696969");
                        }
                        else if (d.tag == 29) {
                            return("#FF4500");
                        }
                        else if (d.tag == 30) {
                            return("#DC143C");
                        }
                        else if (d.tag == 31) {
                            return("#FF69B4");
                        }
                        else if (d.tag == 32) {
                            return("#006400");
                        }
                        else if (d.tag == 33) {
                            return("#87CEEB");
                        }
                        else if (d.tag == 34) {
                            return("#EE82EE");
                        }
                        else if (d.tag == 35) {
                            return("#800000");
                        }
                        else if (d.tag == 36) {
                            return("#FAEBD7");
                        }
                        else if (d.tag == 37) {
                            return("#4B0082");
                        }
                        else if (d.tag == 38) {
                            return("#808080");
                        }
                        else if (d.tag == 39) {
                            return("#FF8C00");
                        }
                        else if (d.tag == 40) {
                            return("#FA8072");
                        }
                        else if (d.tag == 41) {
                            return("#FFC0CB");
                        }
                        else if (d.tag == 42) {
                            return("#9ACD32");
                        }
                        else if (d.tag == 43) {
                            return("#4682B4");
                        }
                        else if (d.tag == 44) {
                            return("#DDA0DD");
                        }
                        else if (d.tag == 45) {
                            return("#CD853F");
                        }
                        else if (d.tag == 46) {
                            return("#FFE4E1");
                        }
                        else if (d.tag == 47) {
                            return("#696969");
                        }
                        else if (d.tag == 48) {
                            return("#A9A9A9");
                        }
                        else if (d.tag == 49) {
                            return("#FFA500");
                        }
                        else{
                            return("#000000");
                        }













                        // if (d.group == 0) {
                        //     return colorScale(d.value);
                        // }
                        // else {
                        //
                        //     if (d.group == 1) {
                        //         return("#ed0909");
                        //     }
                        //     if (d.group == 2) {
                        //         return("#0af702");
                        //     }
                        //     if (d.group == 3) {
                        //         return("#FF00FF");
                        //     }
                        //     if (d.group == 4) {
                        //         return("#808000");
                        //     }
                        //     if (d.group == 5) {
                        //         return("#000080");
                        //     }
                        //     if (d.group == 6) {
                        //         return("#800080");
                        //     }
                        //     if (d.group == 7) {
                        //         return("#00ffff");
                        //     }
                        //     if (d.group == 8) {
                        //         return("#F5F5DC");
                        //     }
                        //     if (d.group == 9) {
                        //         return("#A52A2A");
                        //     }
                        //     if (d.group == 10) {
                        //         return("#8B0000");
                        //     }
                        //     if (d.group == 11) {
                        //         return("#FF8C00");
                        //     }
                        //
                        // }

                    })



                    //.style("stroke", "#726363")
                    .attr("class", "node-link")
                    .style("stroke-width", function (d) {return scoreScale(d.weight); })
                    //.style("stroke-width", 0.1)
                    .attr("d", function (d) {

                        var dx = d.target.x - d.source.x,
                            dy = d.target.y - d.source.y,
                            dr = Math.sqrt(dx * dx + dy * dy),
                            a1 = dx,
                            a2 = dy,
                            c1 = w/2 - d.source.x,
                            c2 = h/2 - d.source.y,
                            d1 = w/2 - d.target.x,
                            d2 = h/2 - d.target.y,

                            drx = dr/1.5,
                            dry = dr/1.5,
                            xRotation = 0, // degrees
                            largeArc = 0, // 1 or 0

                            sweep = 1, // 1 or 0
                            x2 = d.target.x,
                            y2 = d.target.y;


                            // if( (a1*c2 - a2*c1) > 0)
                            // {
                            //     sweep = 0
                            // }
                            // else
                            // {sweep = 1}
                            if( (c1*d2 - c2*d1) > 0)
                            {
                                sweep = 0
                            }
                            else
                            {sweep = 1}


                        return "M" + d.source.x + "," + d.source.y + "A" + drx + "," + dry + " " + xRotation + "," + largeArc + "," + sweep + " " + x2 + "," + y2;


                        //return "M" + d.source.x + "," + d.source.y + ","+ d.target.x + "," + d.target.y;
                        //return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
                    });






                //     var dx = d.target.x - d.source.x,
                //         dy = d.target.y - d.source.y,
                //         dr = Math.sqrt(dx * dx + dy * dy);
                //     return "M" +
                //         d.source.x + "," +
                //         d.source.y + "," +
                //         d.target.x + "," +
                //         d.target.y;
                //
                // });


                var gnodes = svgGE.selectAll('g.gnode')
                    .data(nodes).enter().append('g')
                    .attr("transform", function (d) {
                        return "translate(" + d.x + "," + d.y + ")"
                    })
                    .classed('gnode', true);


                // node.append("circle")
                //     .attr("r", function (d) { return xScale(d.weight); })
                //     .style("fill", function(d) { return colNodeScale(d.group); });

//                 function click() {
//                     d3.select(this).select("text").transition()
//                         .duration(750)
//                         .attr("x", 22)
//                         .style("stroke", "lightsteelblue")
//                         .style("stroke-width", ".5px")
//                         .style("font", "20px sans-serif");
//                     d3.select(this).select("circle").transition()
//                         .duration(750)
//                         .attr("r", 16);
//                 }
//
// // action to take on mouse double click
//                 function dblclick() {
//                     d3.select(this).select("circle").transition()
//                         .duration(750)
//                         .attr("r", 6);
//                     d3.select(this).select("text").transition()
//                         .duration(750)
//                         .attr("x", 12)
//                         .style("stroke", "none")
//                         .style("fill", "black")
//                         .style("stroke", "none")
//                         .style("font", "10px sans-serif");
//                 }



                var node = gnodes.append("circle")
                    .attr("r", function (d) {
                        return xScale(d.weight);
                    })
                    .style("fill", function (d) {


                        if (d.group == 0) {
                            return("#696969");
                        }
                        else if (d.group == 1) {
                            return("#006400");
                        }
                        else if (d.group == 2) {
                            return("#00FF00");
                        }
                        else if (d.group == 3) {
                            return("#0000FF");
                        }
                        else if (d.group == 4) {
                            return("#808080");
                        }
                        else if (d.group == 5) {
                            return("#8B4513");
                        }
                        else if (d.group == 6) {
                            return("#FFFFE0");
                        }
                        else if (d.group == 7) {
                            return("#8464c5");
                        }
                        else if (d.group == 8) {
                            return("#00FFFF");
                        }
                        else if (d.group == 9) {
                            return("#FF7F50");
                        }
                        else if (d.group == 10) {
                            return("#FF0000");
                        }
                        else if (d.group == 11) {
                            return("#FF00FF");
                        }
                        else if (d.group == 12) {
                            return("#8FBC8F");
                        }
                        else if (d.group == 13) {
                            return("#A52A2A");
                        }
                        else if (d.group == 14) {
                            return("#FFD700");
                        }
                        else if (d.group == 15) {
                            return("#A0522D");
                        }
                        else if (d.group == 16) {
                            return("#FFFF00");
                        }
                        else if (d.group == 17) {
                            return("#6A5ACD");
                        }
                        else if (d.group == 18) {
                            return("#708090");
                        }
                        else if (d.group == 19) {
                            return("#FF6347");
                        }
                        else if (d.group == 20) {
                            return("#CD5C5C");
                        }
                        else if (d.group == 21) {
                            return("#DB7093");
                        }
                        else if (d.group == 22) {
                            return("#2E8B57");
                        }
                        else if (d.group == 23) {
                            return("#000080");
                        }
                        else if (d.group == 24) {
                            return("#9370DB");
                        }
                        else if (d.group == 25) {
                            return("#A52A2A");
                        }
                        else if (d.group == 26) {
                            return("#FDF5E6");
                        }
                        else if (d.group == 27) {
                            return("#7B68EE");
                        }
                        else if (d.group == 28) {
                            return("#696969");
                        }
                        else if (d.group == 29) {
                            return("#FF4500");
                        }
                        else if (d.group == 30) {
                            return("#DC143C");
                        }
                        else if (d.group == 31) {
                            return("#FF69B4");
                        }
                        else if (d.group == 32) {
                            return("#006400");
                        }
                        else if (d.group == 33) {
                            return("#87CEEB");
                        }
                        else if (d.group == 34) {
                            return("#EE82EE");
                        }
                        else if (d.group == 35) {
                            return("#800000");
                        }
                        else if (d.group == 36) {
                            return("#FAEBD7");
                        }
                        else if (d.group == 37) {
                            return("#4B0082");
                        }
                        else if (d.group == 38) {
                            return("#808080");
                        }
                        else if (d.group == 39) {
                            return("#FF8C00");
                        }
                        else if (d.group == 40) {
                            return("#FA8072");
                        }
                        else if (d.group == 41) {
                            return("#FFC0CB");
                        }
                        else if (d.group == 42) {
                            return("#9ACD32");
                        }
                        else if (d.group == 43) {
                            return("#4682B4");
                        }
                        else if (d.group == 44) {
                            return("#DDA0DD");
                        }
                        else if (d.group == 45) {
                            return("#CD853F");
                        }
                        else if (d.group == 46) {
                            return("#FFE4E1");
                        }
                        else if (d.group == 47) {
                            return("#696969");
                        }
                        else if (d.group == 48) {
                            return("#A9A9A9");
                        }
                        else if (d.group == 49) {
                            return("#FFA500");
                        }
                        else if (d.group == 117) {
                            return ("#FFD600FF");
                        }
                        else if (d.group == 64) {
                            return ("#FF7600FF");
                        }
                        else if (d.group == 85) {
                            return ("#FFFF9CFF");
                        }
                        else if (d.group == 95) {
                            return ("#FF3000FF");
                        }
                        else if (d.group == 123) {
                            return ("#FFFF0BFF");
                        }
                        else if (d.group == 88) {
                            return ("#FFFFF1FF");
                        }
                        else if (d.group == 73) {
                            return ("#FFC800FF");
                        }
                        else if (d.group == 118) {
                            return ("#FFDD00FF");
                        }
                        else if (d.group == 129) {
                            return ("#FFFF8AFF");
                        }
                        else if (d.group == 54) {
                            return ("#FF1B00FF");
                        }
                        else if (d.group == 122) {
                            return ("#FFF800FF");
                        }
                        else if (d.group == 130) {
                            return ("#FFFF9FFF");
                        }
                        else if (d.group == 99) {
                            return ("#FF5300FF");
                        }
                        else if (d.group == 98) {
                            return ("#FF4C00FF");
                        }
                        else if (d.group == 56) {
                            return ("#FF2E00FF");
                        }
                        else if (d.group == 89) {
                            return ("#FF0700FF");
                        }
                        else if (d.group == 110) {
                            return ("#FF9F00FF");
                        }
                        else if (d.group == 101) {
                            return ("#FF6000FF");
                        }
                        else if (d.group == 93) {
                            return ("#FF2200FF");
                        }
                        else if (d.group == 53) {
                            return ("#FF1200FF");
                        }
                        else if (d.group == 108) {
                            return ("#FF9100FF");
                        }
                        else if (d.group == 69) {
                            return ("#FFA400FF");
                        }
                        else if (d.group == 75) {
                            return ("#FFDB00FF");
                        }
                        else if (d.group == 76) {
                            return ("#FFE400FF");
                        }
                        else if (d.group == 119) {
                            return ("#FFE300FF");
                        }
                        else if (d.group == 134) {
                            return ("#FFFFF4FF");
                        }
                        else if (d.group == 62) {
                            return ("#FF6400FF");
                        }
                        else if (d.group == 127) {
                            return ("#FFFF60FF");
                        }
                        else if (d.group == 121) {
                            return ("#FFF100FF");
                        }
                        else if (d.group == 109) {
                            return ("#FF9800FF");
                        }
                        else if (d.group == 116) {
                            return ("#FFCF00FF");
                        }
                        else if (d.group == 124) {
                            return ("#FFFF20FF");
                        }
                        else if (d.group == 131) {
                            return ("#FFFFB5FF");
                        }
                        else if (d.group == 90) {
                            return ("#FF0E00FF");
                        }
                        else if (d.group == 114) {
                            return ("#FFBA00FF");
                        }
                        else if (d.group == 72) {
                            return ("#FFBF00FF");
                        }
                        else if (d.group == 52) {
                            return ("#FF0900FF");
                        }
                        else if (d.group == 63) {
                            return ("#FF6D00FF");
                        }
                        else if (d.group == 79) {
                            return ("#FFFF00FF");
                        }
                        else if (d.group == 80) {
                            return ("#FFFF0EFF");
                        }
                        else if (d.group == 78) {
                            return ("#FFF600FF");
                        }
                        else if (d.group == 107) {
                            return ("#FF8A00FF");
                        }
                        else if (d.group == 87) {
                            return ("#FFFFD4FF");
                        }
                        else if (d.group == 59) {
                            return ("#FF4900FF");
                        }
                        else if (d.group == 55) {
                            return ("#FF2400FF");
                        }
                        else if (d.group == 106) {
                            return ("#FF8300FF");
                        }
                        else if (d.group == 113) {
                            return ("#FFB300FF");
                        }
                        else if (d.group == 51) {
                            return ("#FF0000FF");
                        }
                        else if (d.group == 74) {
                            return ("#FFD100FF");
                        }
                        else if (d.group == 82) {
                            return ("#FFFF47FF");
                        }
                        else if (d.group == 104) {
                            return ("#FF7500FF");
                        }
                        else if (d.group == 66) {
                            return ("#FF8900FF");
                        }
                        else if (d.group == 133) {
                            return ("#FFFFDFFF");
                        }
                        else if (d.group == 86) {
                            return ("#FFFFB8FF");
                        }
                        else if (d.group == 65) {
                            return ("#FF8000FF");
                        }
                        else if (d.group == 132) {
                            return ("#FFFFCAFF");
                        }
                        else if (d.group == 58) {
                            return ("#FF4000FF");
                        }
                        else if (d.group == 105) {
                            return ("#FF7C00FF");
                        }
                        else if (d.group == 102) {
                            return ("#FF6700FF");
                        }
                        else if (d.group == 96) {
                            return ("#FF3E00FF");
                        }
                        else if (d.group == 125) {
                            return ("#FFFF35FF");
                        }
                        else if (d.group == 81) {
                            return ("#FFFF2BFF");
                        }
                        else if (d.group == 83) {
                            return ("#FFFF63FF");
                        }
                        else if (d.group == 120) {
                            return ("#FFEA00FF");
                        }
                        else if (d.group == 71) {
                            return ("#FFB600FF");
                        }
                        else if (d.group == 67) {
                            return ("#FF9200FF");
                        }
                        else if (d.group == 97) {
                            return ("#FF4500FF");
                        }
                        else if (d.group == 112) {
                            return ("#FFAC00FF");
                        }
                        else if (d.group == 61) {
                            return ("#FF5B00FF");
                        }
                        else if (d.group == 91) {
                            return ("#FF1500FF");
                        }
                        else if (d.group == 115) {
                            return ("#FFC100FF");
                        }
                        else if (d.group == 103) {
                            return ("#FF6E00FF");
                        }
                        else if (d.group == 70) {
                            return ("#FFAD00FF");
                        }
                        else if (d.group == 84) {
                            return ("#FFFF80FF");
                        }
                        else if (d.group == 126) {
                            return ("#FFFF4AFF");
                        }
                        else if (d.group == 100) {
                            return ("#FF5A00FF");
                        }
                        else if (d.group == 77) {
                            return ("#FFED00FF");
                        }
                        else if (d.group == 68) {
                            return ("#FF9B00FF");
                        }
                        else if (d.group == 57) {
                            return ("#FF3700FF");
                        }
                        else if (d.group == 92) {
                            return ("#FF1C00FF");
                        }
                        else if (d.group == 60) {
                            return ("#FF5200FF");
                        }
                        else if (d.group == 111) {
                            return ("#FFA500FF");
                        }
                        else if (d.group == 94) {
                            return ("#FF2900FF");
                        }
                        else if (d.group == 128) {
                                return ("#FFFF75FF");
                            }

                            else{
                            return("#000000");
                        }













                        // if (d.group == 0) {
                        //     return colorScale(d.value);
                        // }
                        // else {
                        //
                        //     if (d.group == 1) {
                        //         return("#ed0909");
                        //     }
                        //     if (d.group == 2) {
                        //         return("#0af702");
                        //     }
                        //     if (d.group == 3) {
                        //         return("#FF00FF");
                        //     }
                        //     if (d.group == 4) {
                        //         return("#808000");
                        //     }
                        //     if (d.group == 5) {
                        //         return("#000080");
                        //     }
                        //     if (d.group == 6) {
                        //         return("#800080");
                        //     }
                        //     if (d.group == 7) {
                        //         return("#00ffff");
                        //     }
                        //     if (d.group == 8) {
                        //         return("#F5F5DC");
                        //     }
                        //     if (d.group == 9) {
                        //         return("#A52A2A");
                        //     }
                        //     if (d.group == 10) {
                        //         return("#8B0000");
                        //     }
                        //     if (d.group == 11) {
                        //         return("#FF8C00");
                        //     }
                        //
                        // }

                    })
                    // .style("fill", function (d) {
                    //     return colNodeScale(d.group);
                    // })
                    .style("stroke", "#333")
                    .style("stroke-width", "2px")
                    .style("stroke-dasharray",
                        function (d) {
                            if (d.connected == "No") {
                                ////console.log("not connected");
                                return (5, 5);

                            }
                            else if(d.connected == "Yes") {
                                ////console.log("connected");
                                return (3, 0);
                            }
                        })

                    //.attr("class", "node")
                    .on("mouseenter", function (d) {
                        is_connected(d, 0.1)
                        node.transition().duration(100).attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        d3.select(this).transition().duration(100).attr("r", function (d) {
                            return xScale(d.weight + 3);
                        })
                    })
                    // .on("mouseleave", function (d) {
                    //     node.transition().duration(100).attr("r", function (d) {
                    //         return xScale(d.weight);
                    //     })
                    //     //is_connected(d, 1);
                    // })
                    .on("click", function(d){

                        //if(!first_click) {
                        is_connected_on_click(d, 0.1);
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            d3.select(this).transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight + 3);
                            })

                    })

                    .call(force.drag);

                var labels = gnodes.append("text")
                    .attr("dx", 4)
                    .attr("dy", 4)
                    .style("font", String(fontSize) + "px Arial")
                    .attr("text-anchor", function (d) {
                        return d.x < w / 2 ? "end" : "start";
                    })
                    .attr("transform", function (d) {
                        return d.x < w / 2 ? "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(-20)" : "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(20)";
                    })
                    //.attr("transform", function(d) { return  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")"})
                    //.attr("transform", function(d) { return (d.x-w/2)/(d.y-w/2) < 0 ?  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")" : "rotate(180)"; })
                    .text(function (d) {
                        return d.full_name
                    })

                var drag = force.drag()
                    .on("dragstart", dragstart);
                //.on("dragstart", dragstartAll);


                //For not moving after drag
                function dragstart(d) {
                    d3.select(this).classed("fixed", d.fixed = true);

                    for (i = 0; i < nodes.length; i++) {
                        nodes[i].fixed = true;
                    }
                }


                var svgText = svgGE.append("text");
                svgText.attr("x",10).attr("y",globalHPlus50-50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                //Added from here for coloring the legend
                max_data = 1000;
                min_data = -1000;

                if (1 == 0) {
                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);


                    var legend2 = svgGE.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());
                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(globalW / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svgGE.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svgGE.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svgGE.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", "11px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();
                }


            };

            d3.select('#circosViewGE').on('click', function (){
                circosViewGE();
                $scope.graphType = 0;
            });



            function parallelViewGE() {
                svgGE.remove();

                //xPosition.domain(d3.extent(nodes, function (d) { return d.text; }));
                xScale.domain(d3.extent(nodes, function (d) {
                    return d.weight;
                }));
                colNodeScale.domain(d3.extent(nodes, function (d) {
                    return d.group;
                }));
                colScale.domain(d3.extent(links, function (d) {
                    return d.weight;
                }));
                textPlacePlusMinus.domain(d3.extent(nodes, function (d) {
                    return d.group;
                }));
                textPlaceStartEnd.domain(d3.extent(nodes, function (d) {
                    return d.group;
                }));
                scoreScale.domain(d3.extent(links, function (d) {
                    return d.score;
                }));

                var groupId = {};
                var groupIds = [];
                var maxId = 0;
                var maxGroupNum = 0;
                for (var i = 0; i < nodes.length; i++) {
                    var item = nodes[i];

                    if (!groupId[item.group]) {
                        groupId[item.group] = [];
                        groupIds.push(item.group);
                    }

                    groupId[item.group].push({name: item.name});
                    // //console.log(item.group);
                    // //console.log(groupId[item.group]);
                    // if (maxId < item.group) {
                    //     maxId = item.group;
                    // }
                }
                //console.log(maxId);
                var nodeListIter = {};
                for (var key in groupId) {
                    if (groupId.hasOwnProperty(key)) {
                        nodeListIter[key] = 0;
                        maxId += 1;
                        console.log(groupId[key]);
                        console.log(groupId[key].length);
                        if (maxGroupNum < groupId[key].length) {
                            maxGroupNum = groupId[key].length;
                        }
                    }
                }
                console.log(groupIds);
                groupIds.sort();
                console.log(groupIds);

                console.log(maxId);
                console.log(maxGroupNum);

                var parallelH = Math.max(maxGroupNum * 25, 500);
                //var parallelH = Math.max(n1 * 12, n2 * 12);

                var margin = 75,
                    w = widthSize - 2 * margin,
                    h = parallelH,
                    radius = w / 2,
                    strokeWidth = 4,
                    hyp2 = Math.pow(radius, 2),
                    nodeBaseRad = 5;

                globalH = h;
                globalHPlus50 = h + 50;
                globalW = w;


                svgGE = d3.select("#chartGE")
                    .append("svg")
                    .attr("style", "outline: thin solid yellow;")
                    .attr("width", w)
                    .attr("height", globalHPlus50);

                svgGE.append("rect")
                    .attr("width", "100%")
                    .attr("height", "100%")
                    .attr("fill", "white");


                var force = d3.layout.force()
                    .nodes(nodes)
                    .links(links)
                    .size([w, h]);


                var parallelCoordx = function (group, maxId) {


                        return group * w/(maxId + 1)+ w/(maxId + 1);

                }

                var parallelCoordy = function (index, num_nodes) {
                    var dist = h / (num_nodes + 1);

                    return (index + 1) * dist;
                }

                var is_connected = function (d, opacity) {
                    lines.transition().style("stroke-opacity", function (o) {
                        return o.source === d || o.target === d ? 1 : opacity;
                    });
                }

                var is_connected_on_click = function (d, opacity) {
                    //console.log(d);
                    lines.transition().style("stroke-opacity", function (o) {
                        return o.source.group === d.group || o.target.group === d.group ? 1 : opacity;
                    });
                }
                //var dim = w-80
                // var circle = svg.append("path")
                //     .attr("d", "M 40, "+(dim/2+40)+" a "+dim/2+","+dim/2+" 0 1,0 "+dim+",0 a "+dim/2+","+dim/2+" 0 1,0 "+dim*-1+",0")
                //     .style("fill", "#f5f5f5");

                force.start();


                // //console.log(nodes.length);







                nodes.forEach(function (n, i) {
                    var groupOrder = groupIds.indexOf(n.group);
                    n.x = parallelCoordx(groupOrder, maxId);
                    n.y = parallelCoordy(nodeListIter[n.group], groupId[n.group].length);
                    nodeListIter[n.group] += 1;

                });


                // use this one for straight line links...
                // var lines = svg.selectAll("line.node-link")
                //   .data(links).enter().append("line")
                //     .attr("class", "node-link")
                //   .attr("x1", function(d) { return d.source.x; })
                //   .attr("y1", function(d) { return d.source.y; })
                //   .attr("x2", function(d) { return d.target.x; })
                //   .attr("y2", function(d) { return d.target.y; });

                var lines = svgGE.selectAll("path.node-link")
                    .data(links).enter().append("path")
                    .style("fill", "none")
                    .style("stroke", function (d) {

                        if (d.tag == 0) {
                            return("#696969");
                        }
                        else if (d.tag == 1) {
                            return("#006400");
                        }
                        else if (d.tag == 2) {
                            return("#00FF00");
                        }
                        else if (d.tag == 3) {
                            return("#0000FF");
                        }
                        else if (d.tag == 4) {
                            return("#808080");
                        }
                        else if (d.tag == 5) {
                            return("#8B4513");
                        }
                        else if (d.tag == 6) {
                            return("#FFFFE0");
                        }
                        else if (d.tag == 7) {
                            return("#8464c5");
                        }
                        else if (d.tag == 8) {
                            return("#00FFFF");
                        }
                        else if (d.tag == 9) {
                            return("#FF7F50");
                        }
                        else if (d.tag == 10) {
                            return("#FF0000");
                        }
                        else if (d.tag == 11) {
                            return("#FF00FF");
                        }
                        else if (d.tag == 12) {
                            return("#8FBC8F");
                        }
                        else if (d.tag == 13) {
                            return("#A52A2A");
                        }
                        else if (d.tag == 14) {
                            return("#FFD700");
                        }
                        else if (d.tag == 15) {
                            return("#A0522D");
                        }
                        else if (d.tag == 16) {
                            return("#FFFF00");
                        }
                        else if (d.tag == 17) {
                            return("#6A5ACD");
                        }
                        else if (d.tag == 18) {
                            return("#708090");
                        }
                        else if (d.tag == 19) {
                            return("#FF6347");
                        }
                        else if (d.tag == 20) {
                            return("#CD5C5C");
                        }
                        else if (d.tag == 21) {
                            return("#DB7093");
                        }
                        else if (d.tag == 22) {
                            return("#2E8B57");
                        }
                        else if (d.tag == 23) {
                            return("#000080");
                        }
                        else if (d.tag == 24) {
                            return("#9370DB");
                        }
                        else if (d.tag == 25) {
                            return("#A52A2A");
                        }
                        else if (d.tag == 26) {
                            return("#FDF5E6");
                        }
                        else if (d.tag == 27) {
                            return("#7B68EE");
                        }
                        else if (d.tag == 28) {
                            return("#696969");
                        }
                        else if (d.tag == 29) {
                            return("#FF4500");
                        }
                        else if (d.tag == 30) {
                            return("#DC143C");
                        }
                        else if (d.tag == 31) {
                            return("#FF69B4");
                        }
                        else if (d.tag == 32) {
                            return("#006400");
                        }
                        else if (d.tag == 33) {
                            return("#87CEEB");
                        }
                        else if (d.tag == 34) {
                            return("#EE82EE");
                        }
                        else if (d.tag == 35) {
                            return("#800000");
                        }
                        else if (d.tag == 36) {
                            return("#FAEBD7");
                        }
                        else if (d.tag == 37) {
                            return("#4B0082");
                        }
                        else if (d.tag == 38) {
                            return("#808080");
                        }
                        else if (d.tag == 39) {
                            return("#FF8C00");
                        }
                        else if (d.tag == 40) {
                            return("#FA8072");
                        }
                        else if (d.tag == 41) {
                            return("#FFC0CB");
                        }
                        else if (d.tag == 42) {
                            return("#9ACD32");
                        }
                        else if (d.tag == 43) {
                            return("#4682B4");
                        }
                        else if (d.tag == 44) {
                            return("#DDA0DD");
                        }
                        else if (d.tag == 45) {
                            return("#CD853F");
                        }
                        else if (d.tag == 46) {
                            return("#FFE4E1");
                        }
                        else if (d.tag == 47) {
                            return("#696969");
                        }
                        else if (d.tag == 48) {
                            return("#A9A9A9");
                        }
                        else if (d.tag == 49) {
                            return("#FFA500");
                        }
                        else{
                            return("#000000");
                        }













                        // if (d.group == 0) {
                        //     return colorScale(d.value);
                        // }
                        // else {
                        //
                        //     if (d.group == 1) {
                        //         return("#ed0909");
                        //     }
                        //     if (d.group == 2) {
                        //         return("#0af702");
                        //     }
                        //     if (d.group == 3) {
                        //         return("#FF00FF");
                        //     }
                        //     if (d.group == 4) {
                        //         return("#808000");
                        //     }
                        //     if (d.group == 5) {
                        //         return("#000080");
                        //     }
                        //     if (d.group == 6) {
                        //         return("#800080");
                        //     }
                        //     if (d.group == 7) {
                        //         return("#00ffff");
                        //     }
                        //     if (d.group == 8) {
                        //         return("#F5F5DC");
                        //     }
                        //     if (d.group == 9) {
                        //         return("#A52A2A");
                        //     }
                        //     if (d.group == 10) {
                        //         return("#8B0000");
                        //     }
                        //     if (d.group == 11) {
                        //         return("#FF8C00");
                        //     }
                        //
                        // }

                    })
                    //.style("stroke", "#726363")
                    .attr("class", "node-link")
                    .style("stroke-width", function (d) {return d.score/2; })
                    .attr("d", function (d) {

                        var dx = d.target.x - d.source.x,
                            dy = d.target.y - d.source.y,
                            dr = Math.sqrt(dx * dx + dy * dy),
                            a1 = dx,
                            a2 = dy,
                            c1 = w/2 - d.source.x,
                            c2 = h/2 - d.source.y,
                            d1 = w/2 - d.target.x,
                            d2 = h/2 - d.target.y,

                            drx = dr/1.5,
                            dry = dr/1.5,
                            xRotation = 0, // degrees
                            largeArc = 0, // 1 or 0

                            sweep = 1, // 1 or 0
                            x2 = d.target.x,
                            y2 = d.target.y;


                        // if( (a1*c2 - a2*c1) > 0)
                        // {
                        //     sweep = 0
                        // }
                        // else
                        // {sweep = 1}
                        if( (c1*d2 - c2*d1) > 0)
                        {
                            sweep = 0
                        }
                        else
                        {sweep = 1}


                        return "M" + d.source.x + "," + d.source.y + "A" + drx + "," + dry + " " + xRotation + "," + largeArc + "," + sweep + " " + x2 + "," + y2;


                        //return "M" + d.source.x + "," + d.source.y + ","+ d.target.x + "," + d.target.y;
                        //return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
                    });
                    // .attr("d", function (d) {
                    //     var dx = d.target.x - d.source.x,
                    //         dy = d.target.y - d.source.y,
                    //         dr = Math.sqrt(dx * dx + dy * dy);
                    //     return "M" +
                    //         d.source.x + "," +
                    //         d.source.y + "," +
                    //         d.target.x + "," +
                    //         d.target.y;
                    // });


                // nodes.weight = lines.filter(function(l) {
                //     return l.source.index == d.index || l.target.index == d.index
                // }).size();

                // var lines = svg.selectAll("path.node-link")
                //     .data(links).enter().append("path")
                //     .style("fill", "none")
                //     .style("stroke", "black")
                //     .attr("class", "node-link")
                //     .attr("d", function(d) {
                //         var dx = d.target.x - d.source.x,
                //             dy = d.target.y - d.source.y,
                //             dr = Math.sqrt(dx * dx + dy * dy);
                //         return "M" +
                //             d.source.x + "," +
                //             d.source.y + "A" +
                //             dr + "," + dr + " 0 0,1 " +
                //             d.target.x + "," +
                //             d.target.y;
                //     });

                var gnodes = svgGE.selectAll('g.gnode')
                    .data(nodes).enter().append('g')
                    .attr("transform", function (d) {
                        return "translate(" + d.x + "," + d.y + ")"
                    })
                    .classed('gnode', true);

                // gnodes.forEach(function (n, i) {
                //     n.weight = lines.filter(function (l) {
                //         return l.source.idx == n.idx || l.target.idx == n.idx
                //     }).size();
                //
                // });
                var node = gnodes.append("circle")
                //.attr("r", function(d) {
                // d.sizes = lines.filter(function(l) {
                //     return l.source.index == d.index || l.target.index == d.index
                // }).size();
                // var minRadius = 5;
                // return minRadius + (d.sizes * 2);
                //     return colorScale(d.weight);
                // })
                    .attr("r", function (d) {
                        return xScale(d.weight);
                    })
                    .style("fill", function (d) {

                        if (d.group == 0) {
                            return("#696969");
                        }
                        else if (d.group == 1) {
                            return("#006400");
                        }
                        else if (d.group == 2) {
                            return("#00FF00");
                        }
                        else if (d.group == 3) {
                            return("#0000FF");
                        }
                        else if (d.group == 4) {
                            return("#808080");
                        }
                        else if (d.group == 5) {
                            return("#8B4513");
                        }
                        else if (d.group == 6) {
                            return("#FFFFE0");
                        }
                        else if (d.group == 7) {
                            return("#8464c5");
                        }
                        else if (d.group == 8) {
                            return("#00FFFF");
                        }
                        else if (d.group == 9) {
                            return("#FF7F50");
                        }
                        else if (d.group == 10) {
                            return("#FF0000");
                        }
                        else if (d.group == 11) {
                            return("#FF00FF");
                        }
                        else if (d.group == 12) {
                            return("#8FBC8F");
                        }
                        else if (d.group == 13) {
                            return("#A52A2A");
                        }
                        else if (d.group == 14) {
                            return("#FFD700");
                        }
                        else if (d.group == 15) {
                            return("#A0522D");
                        }
                        else if (d.group == 16) {
                            return("#FFFF00");
                        }
                        else if (d.group == 17) {
                            return("#6A5ACD");
                        }
                        else if (d.group == 18) {
                            return("#708090");
                        }
                        else if (d.group == 19) {
                            return("#FF6347");
                        }
                        else if (d.group == 20) {
                            return("#CD5C5C");
                        }
                        else if (d.group == 21) {
                            return("#DB7093");
                        }
                        else if (d.group == 22) {
                            return("#2E8B57");
                        }
                        else if (d.group == 23) {
                            return("#000080");
                        }
                        else if (d.group == 24) {
                            return("#9370DB");
                        }
                        else if (d.group == 25) {
                            return("#A52A2A");
                        }
                        else if (d.group == 26) {
                            return("#FDF5E6");
                        }
                        else if (d.group == 27) {
                            return("#7B68EE");
                        }
                        else if (d.group == 28) {
                            return("#696969");
                        }
                        else if (d.group == 29) {
                            return("#FF4500");
                        }
                        else if (d.group == 30) {
                            return("#DC143C");
                        }
                        else if (d.group == 31) {
                            return("#FF69B4");
                        }
                        else if (d.group == 32) {
                            return("#006400");
                        }
                        else if (d.group == 33) {
                            return("#87CEEB");
                        }
                        else if (d.group == 34) {
                            return("#EE82EE");
                        }
                        else if (d.group == 35) {
                            return("#800000");
                        }
                        else if (d.group == 36) {
                            return("#FAEBD7");
                        }
                        else if (d.group == 37) {
                            return("#4B0082");
                        }
                        else if (d.group == 38) {
                            return("#808080");
                        }
                        else if (d.group == 39) {
                            return("#FF8C00");
                        }
                        else if (d.group == 40) {
                            return("#FA8072");
                        }
                        else if (d.group == 41) {
                            return("#FFC0CB");
                        }
                        else if (d.group == 42) {
                            return("#9ACD32");
                        }
                        else if (d.group == 43) {
                            return("#4682B4");
                        }
                        else if (d.group == 44) {
                            return("#DDA0DD");
                        }
                        else if (d.group == 45) {
                            return("#CD853F");
                        }
                        else if (d.group == 46) {
                            return("#FFE4E1");
                        }
                        else if (d.group == 47) {
                            return("#696969");
                        }
                        else if (d.group == 48) {
                            return("#A9A9A9");
                        }
                        else if (d.group == 49) {
                            return("#FFA500");
                        }
                        else{
                            return("#000000");
                        }













                        // if (d.group == 0) {
                        //     return colorScale(d.value);
                        // }
                        // else {
                        //
                        //     if (d.group == 1) {
                        //         return("#ed0909");
                        //     }
                        //     if (d.group == 2) {
                        //         return("#0af702");
                        //     }
                        //     if (d.group == 3) {
                        //         return("#FF00FF");
                        //     }
                        //     if (d.group == 4) {
                        //         return("#808000");
                        //     }
                        //     if (d.group == 5) {
                        //         return("#000080");
                        //     }
                        //     if (d.group == 6) {
                        //         return("#800080");
                        //     }
                        //     if (d.group == 7) {
                        //         return("#00ffff");
                        //     }
                        //     if (d.group == 8) {
                        //         return("#F5F5DC");
                        //     }
                        //     if (d.group == 9) {
                        //         return("#A52A2A");
                        //     }
                        //     if (d.group == 10) {
                        //         return("#8B0000");
                        //     }
                        //     if (d.group == 11) {
                        //         return("#FF8C00");
                        //     }
                        //
                        // }

                    })

                    // .style("fill", function (d) {
                    //     return colNodeScale(d.group);
                    // })
                    .style("stroke", "#333")
                    .style("stroke-width", "2px")
                    .style("stroke-dasharray",
                        function (d) {
                            if (d.connected == "No") {
                                ////console.log("not connected");
                                return (5, 5);

                            }
                            else if(d.connected == "Yes") {
                                ////console.log("connected");
                                return (3, 0);
                            }
                        })
                    //.attr("class", "node")
                    .on("mouseenter", function (d) {
                        is_connected(d, 0.1)
                        node.transition().duration(100).attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        d3.select(this).transition().duration(100).attr("r", function (d) {
                            return xScale(d.weight + 3);
                        })
                    })
                    // .on("mouseleave", function (d) {
                    //     node.transition().duration(100).attr("r", function (d) {
                    //         return xScale(d.weight);
                    //     })
                    //     is_connected(d, 1);
                    // })
                    .on("click", function(d){

                        //if(!first_click) {
                        is_connected_on_click(d, 0.1);
                        node.transition().duration(100).attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        d3.select(this).transition().duration(100).attr("r", function (d) {
                            return xScale(d.weight + 3);
                        })

                    })
                    .call(force.drag);
                // var bbox = textElement.getBBox();
                // var width = bbox.width;
                // var height = bbox.height;
                var labels = gnodes.append("text")
                    .style("font", String(fontSize) + "px Arial")
                    .attr("dx", function (d) {
                        return -18;
                    })
                    .attr("dy", 4)
                    .attr("text-anchor", function (d) {
                        return "end";
                    })
                    .text(function (d) {
                        return d.full_name
                    })

                var svgText = svgGE.append("text");
                svgText.attr("x",10).attr("y",globalHPlus50-50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");
                if(1 == 0) {
                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);


                    var legend2 = svgGE.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());
                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(globalW / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svgGE.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svgGE.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svgGE.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", "11px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);
                    legend2.exit().remove();
                }
                //legend2.exit().remove();

                //till here for coloring the legend

            };



            d3.select('#parallelViewGE').on('click', function () {
                parallelViewGE();
                $scope.graphType = 2;
            });


            function defaultSVGGE() {


                svgGE.remove();

                xScale.domain(d3.extent(nodes, function (d) {
                    return d.weight;
                }));
                colNodeScale.domain(d3.extent(nodes, function (d) {
                    return d.group;
                }));
                // colorScale.domain(d3.extent(nodes, function (d) {
                //     return d.value;
                // }));
                colScale.domain(d3.extent(links, function (d) {
                    return d.weight;
                }));
                scoreScale.domain(d3.extent(links, function (d) {
                    return d.score;
                }));
                var margin = 75,
                    w = widthSize - 2 * margin,
                    h = w,
                    radius = w / 2,
                    strokeWidth = 4,
                    hyp2 = Math.pow(radius, 2),
                    nodeBaseRad = 5;

//These variables are global variables
                globalH = h;
                globalHPlus50 = h + 50;
                globalW = w;

                svgGE = d3.select("#chartGE")
                    .append("svg")
                    .attr("style", "outline: thin solid yellow;")
                    .attr("width", w)
                    .attr("height", globalHPlus50);
                svgGE.append("rect")
                    .attr("width", "100%")
                    .attr("height", "100%")
                    .attr("fill", "white");


                var force = d3.layout.force()
                    .nodes(nodes)
                    .links(links)
                    .size([w, h])
                    .linkDistance(350)
                    .charge(-2000)
                    //.linkStrength(0.9)
                    //.friction(0.9)
                    //.chargeDistance(300)
                    .gravity(0.15)
                    //.theta(0.8)
                    //.alpha(0.1)
                    .on("tick", tick)
                    .start();

                // for (var i = n*n; i > 0; --i) force.tick();
                // force.stop();

                //.stop();


                var path = svgGE.append("svg:g").selectAll("path")
                //.data(links)
                    .data(force.links())
                    .enter().append("svg:path")
                    .style("stroke-width", function (d) {return d.score/2; })

                    .style("stroke", function (d) {


                        if (d.tag == 0) {
                            return("#696969");
                        }

                        else if (d.tag == 1) {
                            return("#006400");
                        }
                        else if (d.tag == 2) {
                            return("#00FF00");
                        }
                        else if (d.tag == 3) {
                            return("#0000FF");
                        }
                        else if (d.tag == 4) {
                            return("#808080");
                        }
                        else if (d.tag == 5) {
                            return("#8B4513");
                        }
                        else if (d.tag == 6) {
                            return("#FFFFE0");
                        }
                        else if (d.tag == 7) {
                            return("#8464c5");
                        }
                        else if (d.tag == 8) {
                            return("#00FFFF");
                        }
                        else if (d.tag == 9) {
                            return("#FF7F50");
                        }
                        else if (d.tag == 10) {
                            return("#FF0000");
                        }
                        else if (d.tag == 11) {
                            return("#FF00FF");
                        }
                        else if (d.tag == 12) {
                            return("#8FBC8F");
                        }
                        else if (d.tag == 13) {
                            return("#A52A2A");
                        }
                        else if (d.tag == 14) {
                            return("#FFD700");
                        }
                        else if (d.tag == 15) {
                            return("#A0522D");
                        }
                        else if (d.tag == 16) {
                            return("#FFFF00");
                        }
                        else if (d.tag == 17) {
                            return("#6A5ACD");
                        }
                        else if (d.tag == 18) {
                            return("#708090");
                        }
                        else if (d.tag == 19) {
                            return("#FF6347");
                        }
                        else if (d.tag == 20) {
                            return("#CD5C5C");
                        }
                        else if (d.tag == 21) {
                            return("#DB7093");
                        }
                        else if (d.tag == 22) {
                            return("#2E8B57");
                        }
                        else if (d.tag == 23) {
                            return("#000080");
                        }
                        else if (d.tag == 24) {
                            return("#9370DB");
                        }
                        else if (d.tag == 25) {
                            return("#A52A2A");
                        }
                        else if (d.tag == 26) {
                            return("#FDF5E6");
                        }
                        else if (d.tag == 27) {
                            return("#7B68EE");
                        }
                        else if (d.tag == 28) {
                            return("#696969");
                        }
                        else if (d.tag == 29) {
                            return("#FF4500");
                        }
                        else if (d.tag == 30) {
                            return("#DC143C");
                        }
                        else if (d.tag == 31) {
                            return("#FF69B4");
                        }
                        else if (d.tag == 32) {
                            return("#006400");
                        }
                        else if (d.tag == 33) {
                            return("#87CEEB");
                        }
                        else if (d.tag == 34) {
                            return("#EE82EE");
                        }
                        else if (d.tag == 35) {
                            return("#800000");
                        }
                        else if (d.tag == 36) {
                            return("#FAEBD7");
                        }
                        else if (d.tag == 37) {
                            return("#4B0082");
                        }
                        else if (d.tag == 38) {
                            return("#808080");
                        }
                        else if (d.tag == 39) {
                            return("#FF8C00");
                        }
                        else if (d.tag == 40) {
                            return("#FA8072");
                        }
                        else if (d.tag == 41) {
                            return("#FFC0CB");
                        }
                        else if (d.tag == 42) {
                            return("#9ACD32");
                        }
                        else if (d.tag == 43) {
                            return("#4682B4");
                        }
                        else if (d.tag == 44) {
                            return("#DDA0DD");
                        }
                        else if (d.tag == 45) {
                            return("#CD853F");
                        }
                        else if (d.tag == 46) {
                            return("#FFE4E1");
                        }
                        else if (d.tag == 47) {
                            return("#696969");
                        }
                        else if (d.tag == 48) {
                            return("#A9A9A9");
                        }
                        else if (d.tag == 49) {
                            return("#FFA500");
                        }
                        else{
                            return("#000000");
                        }













                        // if (d.group == 0) {
                        //     return colorScale(d.value);
                        // }
                        // else {
                        //
                        //     if (d.group == 1) {
                        //         return("#ed0909");
                        //     }
                        //     if (d.group == 2) {
                        //         return("#0af702");
                        //     }
                        //     if (d.group == 3) {
                        //         return("#FF00FF");
                        //     }
                        //     if (d.group == 4) {
                        //         return("#808000");
                        //     }
                        //     if (d.group == 5) {
                        //         return("#000080");
                        //     }
                        //     if (d.group == 6) {
                        //         return("#800080");
                        //     }
                        //     if (d.group == 7) {
                        //         return("#00ffff");
                        //     }
                        //     if (d.group == 8) {
                        //         return("#F5F5DC");
                        //     }
                        //     if (d.group == 9) {
                        //         return("#A52A2A");
                        //     }
                        //     if (d.group == 10) {
                        //         return("#8B0000");
                        //     }
                        //     if (d.group == 11) {
                        //         return("#FF8C00");
                        //     }
                        //
                        // }

                    })

                    //.style('stroke', "black")
                    //.style("stroke", function (d) {return colScale(d.value); })
                    .attr("class", function (d) {
                        return "link ";
                    });


                var node = svgGE.append("svg:g").selectAll("g.node")
                    .data(force.nodes())
                    .enter().append("svg:g")
                    // .style("stroke-width", 3)
                    // .style('stroke', "black")
                    //.attr("class", "node")
                    .call(force.drag);

                // nodes.forEach(function(v) {
                //     var nd;
                //     var cx = v.coord[0];
                //     var cy = v.coord[1];
                //
                //     switch (v.group) {
                //         case 1:
                //             nd = svg.append("circle");
                //             break;
                //         case 2:
                //             nd = svg.append("rect");
                //             break;
                //     }
                // });


                var colorsForAbundance = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];
                var colorScale = d3.scale.threshold()
                    .domain(domain_data)
                    .range(colorsForAbundance);


                node.append("circle")
                    .attr("r", function (d) {
                        return xScale(d.weight);
                    })
                    .style("fill", function (d) {

                        if (d.group == 0) {
                            return("#696969");
                        }
                        else if (d.group == 1) {
                            return("#006400");
                        }
                        else if (d.group == 2) {
                            return("#00FF00");
                        }
                        else if (d.group == 3) {
                            return("#0000FF");
                        }
                        else if (d.group == 4) {
                            return("#808080");
                        }
                        else if (d.group == 5) {
                            return("#8B4513");
                        }
                        else if (d.group == 6) {
                            return("#FFFFE0");
                        }
                        else if (d.group == 7) {
                            return("#8464c5");
                        }
                        else if (d.group == 8) {
                            return("#00FFFF");
                        }
                        else if (d.group == 9) {
                            return("#FF7F50");
                        }
                        else if (d.group == 10) {
                            return("#FF0000");
                        }
                        else if (d.group == 11) {
                            return("#FF00FF");
                        }
                        else if (d.group == 12) {
                            return("#8FBC8F");
                        }
                        else if (d.group == 13) {
                            return("#A52A2A");
                        }
                        else if (d.group == 14) {
                            return("#FFD700");
                        }
                        else if (d.group == 15) {
                            return("#A0522D");
                        }
                        else if (d.group == 16) {
                            return("#FFFF00");
                        }
                        else if (d.group == 17) {
                            return("#6A5ACD");
                        }
                        else if (d.group == 18) {
                            return("#708090");
                        }
                        else if (d.group == 19) {
                            return("#FF6347");
                        }
                        else if (d.group == 20) {
                            return("#CD5C5C");
                        }
                        else if (d.group == 21) {
                            return("#DB7093");
                        }
                        else if (d.group == 22) {
                            return("#2E8B57");
                        }
                        else if (d.group == 23) {
                            return("#000080");
                        }
                        else if (d.group == 24) {
                            return("#9370DB");
                        }
                        else if (d.group == 25) {
                            return("#A52A2A");
                        }
                        else if (d.group == 26) {
                            return("#FDF5E6");
                        }
                        else if (d.group == 27) {
                            return("#7B68EE");
                        }
                        else if (d.group == 28) {
                            return("#696969");
                        }
                        else if (d.group == 29) {
                            return("#FF4500");
                        }
                        else if (d.group == 30) {
                            return("#DC143C");
                        }
                        else if (d.group == 31) {
                            return("#FF69B4");
                        }
                        else if (d.group == 32) {
                            return("#006400");
                        }
                        else if (d.group == 33) {
                            return("#87CEEB");
                        }
                        else if (d.group == 34) {
                            return("#EE82EE");
                        }
                        else if (d.group == 35) {
                            return("#800000");
                        }
                        else if (d.group == 36) {
                            return("#FAEBD7");
                        }
                        else if (d.group == 37) {
                            return("#4B0082");
                        }
                        else if (d.group == 38) {
                            return("#808080");
                        }
                        else if (d.group == 39) {
                            return("#FF8C00");
                        }
                        else if (d.group == 40) {
                            return("#FA8072");
                        }
                        else if (d.group == 41) {
                            return("#FFC0CB");
                        }
                        else if (d.group == 42) {
                            return("#9ACD32");
                        }
                        else if (d.group == 43) {
                            return("#4682B4");
                        }
                        else if (d.group == 44) {
                            return("#DDA0DD");
                        }
                        else if (d.group == 45) {
                            return("#CD853F");
                        }
                        else if (d.group == 46) {
                            return("#FFE4E1");
                        }
                        else if (d.group == 47) {
                            return("#696969");
                        }
                        else if (d.group == 48) {
                            return("#A9A9A9");
                        }
                        else if (d.group == 49) {
                            return("#FFA500");
                        }

                        else if (d.group == 117) {
                            return ("#FFD600FF");
                        }
                        else if (d.group == 64) {
                            return ("#FF7600FF");
                        }
                        else if (d.group == 85) {
                            return ("#FFFF9CFF");
                        }
                        else if (d.group == 95) {
                            return ("#FF3000FF");
                        }
                        else if (d.group == 123) {
                            return ("#FFFF0BFF");
                        }
                        else if (d.group == 88) {
                            return ("#FFFFF1FF");
                        }
                        else if (d.group == 73) {
                            return ("#FFC800FF");
                        }
                        else if (d.group == 118) {
                            return ("#FFDD00FF");
                        }
                        else if (d.group == 129) {
                            return ("#FFFF8AFF");
                        }
                        else if (d.group == 54) {
                            return ("#FF1B00FF");
                        }
                        else if (d.group == 122) {
                            return ("#FFF800FF");
                        }
                        else if (d.group == 130) {
                            return ("#FFFF9FFF");
                        }
                        else if (d.group == 99) {
                            return ("#FF5300FF");
                        }
                        else if (d.group == 98) {
                            return ("#FF4C00FF");
                        }
                        else if (d.group == 56) {
                            return ("#FF2E00FF");
                        }
                        else if (d.group == 89) {
                            return ("#FF0700FF");
                        }
                        else if (d.group == 110) {
                            return ("#FF9F00FF");
                        }
                        else if (d.group == 101) {
                            return ("#FF6000FF");
                        }
                        else if (d.group == 93) {
                            return ("#FF2200FF");
                        }
                        else if (d.group == 53) {
                            return ("#FF1200FF");
                        }
                        else if (d.group == 108) {
                            return ("#FF9100FF");
                        }
                        else if (d.group == 69) {
                            return ("#FFA400FF");
                        }
                        else if (d.group == 75) {
                            return ("#FFDB00FF");
                        }
                        else if (d.group == 76) {
                            return ("#FFE400FF");
                        }
                        else if (d.group == 119) {
                            return ("#FFE300FF");
                        }
                        else if (d.group == 134) {
                            return ("#FFFFF4FF");
                        }
                        else if (d.group == 62) {
                            return ("#FF6400FF");
                        }
                        else if (d.group == 127) {
                            return ("#FFFF60FF");
                        }
                        else if (d.group == 121) {
                            return ("#FFF100FF");
                        }
                        else if (d.group == 109) {
                            return ("#FF9800FF");
                        }
                        else if (d.group == 116) {
                            return ("#FFCF00FF");
                        }
                        else if (d.group == 124) {
                            return ("#FFFF20FF");
                        }
                        else if (d.group == 131) {
                            return ("#FFFFB5FF");
                        }
                        else if (d.group == 90) {
                            return ("#FF0E00FF");
                        }
                        else if (d.group == 114) {
                            return ("#FFBA00FF");
                        }
                        else if (d.group == 72) {
                            return ("#FFBF00FF");
                        }
                        else if (d.group == 52) {
                            return ("#FF0900FF");
                        }
                        else if (d.group == 63) {
                            return ("#FF6D00FF");
                        }
                        else if (d.group == 79) {
                            return ("#FFFF00FF");
                        }
                        else if (d.group == 80) {
                            return ("#FFFF0EFF");
                        }
                        else if (d.group == 78) {
                            return ("#FFF600FF");
                        }
                        else if (d.group == 107) {
                            return ("#FF8A00FF");
                        }
                        else if (d.group == 87) {
                            return ("#FFFFD4FF");
                        }
                        else if (d.group == 59) {
                            return ("#FF4900FF");
                        }
                        else if (d.group == 55) {
                            return ("#FF2400FF");
                        }
                        else if (d.group == 106) {
                            return ("#FF8300FF");
                        }
                        else if (d.group == 113) {
                            return ("#FFB300FF");
                        }
                        else if (d.group == 51) {
                            return ("#FF0000FF");
                        }
                        else if (d.group == 74) {
                            return ("#FFD100FF");
                        }
                        else if (d.group == 82) {
                            return ("#FFFF47FF");
                        }
                        else if (d.group == 104) {
                            return ("#FF7500FF");
                        }
                        else if (d.group == 66) {
                            return ("#FF8900FF");
                        }
                        else if (d.group == 133) {
                            return ("#FFFFDFFF");
                        }
                        else if (d.group == 86) {
                            return ("#FFFFB8FF");
                        }
                        else if (d.group == 65) {
                            return ("#FF8000FF");
                        }
                        else if (d.group == 132) {
                            return ("#FFFFCAFF");
                        }
                        else if (d.group == 58) {
                            return ("#FF4000FF");
                        }
                        else if (d.group == 105) {
                            return ("#FF7C00FF");
                        }
                        else if (d.group == 102) {
                            return ("#FF6700FF");
                        }
                        else if (d.group == 96) {
                            return ("#FF3E00FF");
                        }
                        else if (d.group == 125) {
                            return ("#FFFF35FF");
                        }
                        else if (d.group == 81) {
                            return ("#FFFF2BFF");
                        }
                        else if (d.group == 83) {
                            return ("#FFFF63FF");
                        }
                        else if (d.group == 120) {
                            return ("#FFEA00FF");
                        }
                        else if (d.group == 71) {
                            return ("#FFB600FF");
                        }
                        else if (d.group == 67) {
                            return ("#FF9200FF");
                        }
                        else if (d.group == 97) {
                            return ("#FF4500FF");
                        }
                        else if (d.group == 112) {
                            return ("#FFAC00FF");
                        }
                        else if (d.group == 61) {
                            return ("#FF5B00FF");
                        }
                        else if (d.group == 91) {
                            return ("#FF1500FF");
                        }
                        else if (d.group == 115) {
                            return ("#FFC100FF");
                        }
                        else if (d.group == 103) {
                            return ("#FF6E00FF");
                        }
                        else if (d.group == 70) {
                            return ("#FFAD00FF");
                        }
                        else if (d.group == 84) {
                            return ("#FFFF80FF");
                        }
                        else if (d.group == 126) {
                            return ("#FFFF4AFF");
                        }
                        else if (d.group == 100) {
                            return ("#FF5A00FF");
                        }
                        else if (d.group == 77) {
                            return ("#FFED00FF");
                        }
                        else if (d.group == 68) {
                            return ("#FF9B00FF");
                        }
                        else if (d.group == 57) {
                            return ("#FF3700FF");
                        }
                        else if (d.group == 92) {
                            return ("#FF1C00FF");
                        }
                        else if (d.group == 60) {
                            return ("#FF5200FF");
                        }
                        else if (d.group == 111) {
                            return ("#FFA500FF");
                        }
                        else if (d.group == 94) {
                            return ("#FF2900FF");
                        }
                        else if (d.group == 128) {
                                return ("#FFFF75FF");
                            }
                        else{
                            return("#000000");
                        }













                        // if (d.group == 0) {
                        //     return colorScale(d.value);
                        // }
                        // else {
                        //
                        //     if (d.group == 1) {
                        //         return("#ed0909");
                        //     }
                        //     if (d.group == 2) {
                        //         return("#0af702");
                        //     }
                        //     if (d.group == 3) {
                        //         return("#FF00FF");
                        //     }
                        //     if (d.group == 4) {
                        //         return("#808000");
                        //     }
                        //     if (d.group == 5) {
                        //         return("#000080");
                        //     }
                        //     if (d.group == 6) {
                        //         return("#800080");
                        //     }
                        //     if (d.group == 7) {
                        //         return("#00ffff");
                        //     }
                        //     if (d.group == 8) {
                        //         return("#F5F5DC");
                        //     }
                        //     if (d.group == 9) {
                        //         return("#A52A2A");
                        //     }
                        //     if (d.group == 10) {
                        //         return("#8B0000");
                        //     }
                        //     if (d.group == 11) {
                        //         return("#FF8C00");
                        //     }
                        //
                        // }

                    })

                    // .style("fill", function (d) {
                    //     return colNodeScale(d.group);
                    // })
                    .style("stroke", "#333")
                    .style("stroke-dasharray",
                        function (d) {
                            if (d.connected == "No") {
                                ////console.log("not connected");
                                return (5, 5);

                            }
                            else if(d.connected == "Yes") {
                                ////console.log("connected");
                                return (3, 0);
                            }
                        })
                    .style("stroke-width", "2px");
                //.on("dblclick", dblclick);



                // node.append("circle")
                //     .attr("r", function (d) {
                //         return xScale(d.weight);
                //     })
                //     .style("fill", function (d) {
                //         if (d.group == 1) {
                //             return colorScale(d.value);
                //         }
                //         else {
                //             return colNodeScale(d.group);
                //         }
                //         //return colNodeScale(d.group);
                //     })
                //     .style("stroke", "#333")
                //     .style("stroke-width", "2px");



                function openLink() {
                    return function (d) {
                        var url = "";
                        if (d.slug != "") {
                            url = d.slug
                        } //else if(d.type == 2) {
                        //url = "clients/" + d.slug
                        //} else if(d.type == 3) {
                        //url = "agencies/" + d.slug
                        //}
                        window.open("//" + url)
                    }
                };
                node.append("svg:image")
                //****************************************
                //.attr("class", function(d){ return d.name })
                //****************************************
                //.attr("xlink:href", function(d){ return d.img_hrefD})
                    .attr("x", "-36px")
                    .attr("y", "-36px")
                    .attr("width", "70px")
                    .attr("height", "70px")
                //.on("dblclick", openLink());

                // .on("mouseover", function (d) { if(d.entity == "company")
                // {
                //     d3.select(this).attr("width", "90px")
                //         .attr("x", "-46px")
                //         .attr("y", "-36.5px")
                //         .attr("xlink:href", function(d){ return d.img_hrefL});
                // }
                // })
                // .on("mouseout", function (d) { if(d.entity == "company")
                // {
                //     d3.select(this).attr("width", "70px")
                //         .attr("x", "-36px")
                //         .attr("y", "-36px")
                //         .attr("xlink:href", function(d){ return d.img_hrefD});
                // }
                // });


                //.text(function(d) { return d.name })
                node.append("svg:text")
                //****************************************
                    .attr("class", function (d) {
                        return d.full_name
                    })
                    //****************************************
                    .attr("x", 16)
                    .attr("y", ".31em")
                    //.attr("class", "shadow")
                    //.style("font-size","10px")
                    // .attr("dx", 0)
                    // .attr("dy", ".35em")
                    //.style("font-size","12px")
                    //****************************************
                    //text.shadow {
                    .style("stroke", "#fff")
                    .style("stroke-width", "4px")
                    //}
                    //.attr("class", "shadow")
                    .style("font", String(fontSize) + "px Arial")
                    //****************************************
                    //.attr("text-anchor", "middle")
                    //****************************************
                    .text(function (d) {
                        return d.full_name
                    });
                //****************************************


                //This one is for the actual text
                node.append("svg:text")
                //****************************************
                    .attr("class", function (d) {
                        return d.full_name
                    })
                    //****************************************
                    .attr("x", 16)
                    .attr("y", ".31em")
                    //.attr("class", "shadow")
                    //.style("font-size","10px")
                    // .attr("dx", 0)
                    // .attr("dy", ".35em")
                    //.style("font-size","12px")
                    //****************************************
                    .style("font", String(fontSize) + "px Arial")
                    //****************************************
                    //.attr("text-anchor", "middle")
                    //****************************************
                    .text(function (d) {
                        return d.full_name
                    });
                //****************************************


                node.on("mouseover", function (d) {
                    // d3.select(this).select("text")
                    //     .transition()
                    //     .duration(300)
                    //     .text(function (d) {
                    //         return d.full_name;
                    //     })
                    // //.style("font-size", "15px")
                    // .style("font", "14px Times New Roman");
                    //
                    // d3.select(this).select("text")
                    //     .transition()
                    //     .duration(300)
                    //     .text(function (d) {
                    //         return d.full_name;
                    //     })
                    //     //.style("font-size", "15px")
                    //     //.attr("class", "shadow")
                    //     .style("font", "14px Times New Roman");
                    // d3.select(this).select("text")
                    //     .transition()
                    //     .duration(300)
                    //     .text(function (d) {
                    //         return d.full_name;
                    //     })
                    //
                    //     .style("fill",'black')
                    //     .style("font", "14px Times New Roman");

                    //d3.selectAll("text").remove();
                    //d3.select(this).style("stroke-width", 6);

                    //d3.select(this).select("text").style("stroke", "blue");

                    var nodeNeighbors = links.filter(function (link) {
                        // Filter the list of links to only those links that have our target
                        // node as a source or target
                        return link.source.index === d.index || link.target.index === d.index;
                    })
                        .map(function (link) {
                            // Map the list of links to a simple array of the neighboring indices - this is
                            // technically not required but makes the code below simpler because we can use
                            // indexOf instead of iterating and searching ourselves.
                            return link.source.index === d.index ? link.target.index : link.source.index;
                        });

                    d3.selectAll('circle').filter(function (node) {
                        // I filter the selection of all circles to only those that hold a node with an
                        // index in my listg of neighbors
                        return nodeNeighbors.indexOf(node.index) > -1;
                    })
                        .style('stroke', 'blue');

                    //d3.selectAll('text').filter(d).style('fill', 'blue');
                    //****************************
                    // d3.selectAll('text').filter(function(node) {
                    //     // I filter the selection of all circles to only those that hold a node with an
                    //     // index in my listg of neighbors
                    //     return nodeNeighbors.indexOf(node.index) > -1;
                    // }).style('fill', 'blue')
                    //     //.style("font-size", "16px")
                    //     //.style("font-weight", "bold");
                    // //****************************
                    path.style('stroke', function (l) {
                        if (d === l.source || d === l.target)
                            return "blue";
                        else
                            return "grey";
                    })

                    path.style('stroke-width', function (l) {
                        if (d === l.source || d === l.target)
                            return 2;
                        else
                            return 1;
                    })

                })
                    .on("mouseout", function (d) {
                        d3.select(this).select("text")
                            .transition()
                            .duration(300)
                            .text(function (d) {

                                return d.full_name;
                            });
                        // d3.select(this).select("text")
                        //     //*******************************
                        //     .style("font", "14px Times New Roman")
                        //     //*******************************
                        //     .style("font-size", "14px")
                        //     .style("fill",'black')
                        //     .style("font-weight", "normal");

                        // d3.select(this).select("text")
                        // //*******************************
                        //     .style("font", "14px Times New Roman")
                        //     //*******************************
                        //     .style("font-size", "14px")
                        //     .style("fill",'black')
                        //     .style("font-weight", "normal");
                        //d3.select(this).style("stroke", "black");
                        //d3.select(this).style("stroke-width", 1);
                        //d3.select(this).style("stroke", "#333");
                        path.style('stroke', "grey");
                        path.style('stroke-width', 1);
                        //circle.style('stroke', "grey");
                        //node.style("stroke-width", 3);
                        //node.style("stroke", "#333");
                        //d3.selectAll('text').style('fill', 'black')
                        // d3.selectAll('text').style('fill', 'black')
                        //     .style("font-weight", "normal");
                        //d3.selectAll("text").style("font-weight", "normal");
                        node.selectAll("circle").style("stroke-width", 3)
                            .style('stroke', "black");
                        //.style("font-size", "12px");
                        //}
                    });


                function pythag(r, b, coord) {
                    r += nodeBaseRad;

                    // force use of b coord that exists in circle to avoid sqrt(x<0)
                    b = Math.min(w - r - strokeWidth, Math.max(r + strokeWidth, b));

                    var b2 = Math.pow((b - radius), 2),
                        a = Math.sqrt(hyp2 - b2);

                    function openLink() {
                        return function (d) {
                            var url = "";
                            if (d.slug != "") {
                                url = d.slug
                            } //else if(d.type == 2) {
                            //url = "clients/" + d.slug
                            //} else if(d.type == 3) {
                            //url = "agencies/" + d.slug
                            //}
                            window.open("//" + url)
                        }
                    }

                    // radius - sqrt(hyp^2 - b^2) < coord < sqrt(hyp^2 - b^2) + radius
                    coord = Math.max(radius - a + r + strokeWidth,
                        Math.min(a + radius - r - strokeWidth, coord));

                    return coord;
                }

                function tick(e) {
                    path.attr("d", function (d) {
                        var dx = d.target.x - d.source.x,
                            dy = d.target.y - d.source.y,

                            dr = Math.sqrt(dx * dx + dy * dy);
                        ////console.log(d.source.x);
                        // //console.log(d.target.x);
                        return "M" + d.source.x + "," + d.source.y + "," + d.target.x + "," + d.target.y;
                        //return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
                    });

                    node.attr('x', function (d) {
                        return d.x = pythag(Math.random() * 12, d.y, d.x);
                    })
                        .attr('y', function (d) {
                            return d.y = pythag(Math.random() * 12, d.x, d.y);
                        })
                        .attr("transform", function (d) {
                            return "translate(" + d.x + "," + d.y + ")"
                        });

                    //d3.select(this).classed("fixed", d.fixed = true);
                    // circle.attr("transform", function(d) {
                    //     return "translate(" + d.x + "," + d.y + ")";
                    // });
                    //************************************
                    // text.attr("transform", function(d) {
                    //     return "translate(" + d.x + "," + d.y + ")";
                    // });
                    //************************************
                }

                //For not moving after drag
                var drag = force.drag()
                    .on("dragstart", dragstart);
                //.on("dragstart", dragstartAll);

                //For not moving after drag
                function dblclick(d) {
                    d3.select(this).classed("fixed", d.fixed = false);

                }

                //For not moving after drag
                function dragstart(d) {
                    d3.select(this).classed("fixed", d.fixed = true);

                    for (i = 0; i < nodes.length; i++) {
                        nodes[i].fixed = true;
                    }
                }


                var svgText = svgGE.append("text");
                svgText.attr("x",10).attr("y",globalHPlus50-50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                //Added from here for coloring the legend
                if(1 == 0) {
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);


                    var legend2 = svgGE.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());
                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(globalW / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svgGE.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svgGE.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svgGE.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", "11px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();
                }

                //legend2.exit().remove();

                //till here for coloring the legend


                // For legend
                // var colNodeScaleSeparateInfo = d3.scale.ordinal()
                //     .range(["#767776", "#f91104"])
                //     .domain(["Query Gene Set", "Pathways / Kinases Perturbation"]);
                //
                //
                // var legend = svg.selectAll(".legend")
                //     .data(colNodeScaleSeparateInfo.domain())
                //     .enter().append("g")
                //     .attr("class", "legend")
                //     .attr("transform", function (d, i) {
                //         return "translate(0," + (i) * 25 + ")";
                //     });
                //
                // legend.append("rect")
                //     .attr("x", w - 25)
                //     .attr("width", 25)
                //     .attr("height", 25)
                //     .style("fill", colNodeScaleSeparateInfo);
                //
                // legend.append("text")
                //     .attr("x", w - 35)
                //     .attr("y", 12.5)
                //     .attr("dy", ".35em")
                //     .style("text-anchor", "end")
                //     .text(function (d) {
                //         return d;
                //     });
                //
                //
                // d3.select("#download").on("click", function () {
                //     d3.select(this)
                //         .attr("href", 'data:application/octet-stream;base64,' + btoa(d3.select("#chart").html()))
                //         .attr("download", "pathway_network.svg")
                // })

            };

            //defaultSVGPtm();
            //SharedService.setVar('svg', svg);

            d3.select('#forceGE').on('click', function () {
                defaultSVGGE();
                $scope.graphType = 3;

            });

            if (graphType == 0){
                circosViewGE();
            } else if (graphType == 1){
                circularViewGE();
            } else if (graphType == 2){
                parallelViewGE();
            } else if (graphType == 3){
                defaultSVGGE();
            }



            // d3.select("#GE").on("click", function() {
            //     d3.select(this)
            //         .attr("href", 'data:application/octet-stream;base64,' + btoa(d3.select("#line").html()))
            //         .attr("download", "viz.svg")
            // })
            d3.select("#download-svgGE").on("click", function ()  {
                var name = fileName.concat('.svg');
                var svgEl = svgGE.node();
                svgEl.setAttribute("xmlns", "http://www.w3.org/2000/svg");
                var svgData = svgEl.outerHTML;
                var preface = '<?xml version="1.0" standalone="no"?>\r\n';
                var svgBlob = new Blob([preface, svgData], {type:"image/svg+xml;charset=utf-8"});
                var svgUrl = URL.createObjectURL(svgBlob);
                var downloadLink = document.createElement("a");
                downloadLink.href = svgUrl;
                downloadLink.download = name;
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
            })

            // d3.select("#download-svgGE").on("click", function () {
            //     console.log("#download-svgGE")
            //     d3.select(this)
            //         .attr("href", 'data:application/octet-stream;base64,' + btoa(d3.select("#chartGE")))
            //         .attr("download", "pathway_network.svg")
            // })

            d3.select('#download-pngGE').on('click', function () {
                var svgString = getSVGString(svgGE.node());


                svgString2Image(svgString, 4 * globalW, 4 * globalHPlus50, 'png', save); // passes Blob and filesize String to the callback

                function save(dataBlob, filesize) {
                    saveAs(dataBlob, fileName.concat('.png')); // FileSaver.js function
                }
            });
            d3.select('#saveButton').on('click', function () {
                var svgString = getSVGString(svg4.node());

                svgString2Image(svgString, 4 * globalW, 4 * globalHPlus50, 'png', save); // passes Blob and filesize String to the callback

                function save(dataBlob, filesize) {
                    saveAs(dataBlob, fileName.concat('.png')); // FileSaver.js function
                }
            });

// Below are the functions that handle actual exporting:
// getSVGString ( svgNode ) and svgString2Image( svgString, width, height, format, callback )
            function getSVGString(svgNode) {
                svgNode.setAttribute('xlink', 'http://www.w3.org/1999/xlink');
                var cssStyleText = getCSSStyles(svgNode);
                appendCSS(cssStyleText, svgNode);

                var serializer = new XMLSerializer();
                var svgString = serializer.serializeToString(svgNode);
                svgString = svgString.replace(/(\w+)?:?xlink=/g, 'xmlns:xlink='); // Fix root xlink without namespace
                svgString = svgString.replace(/NS\d+:href/g, 'xlink:href'); // Safari NS namespace fix

                return svgString;

                function getCSSStyles(parentElement) {
                    var selectorTextArr = [];

                    // Add Parent element Id and Classes to the list
                    selectorTextArr.push('#' + parentElement.id);
                    for (var c = 0; c < parentElement.classList.length; c++)
                        if (!contains('.' + parentElement.classList[c], selectorTextArr))
                            selectorTextArr.push('.' + parentElement.classList[c]);

                    // Add Children element Ids and Classes to the list
                    var nodes = parentElement.getElementsByTagName("*");
                    for (var i = 0; i < nodes.length; i++) {
                        var id = nodes[i].id;
                        if (!contains('#' + id, selectorTextArr))
                            selectorTextArr.push('#' + id);

                        var classes = nodes[i].classList;
                        for (var c = 0; c < classes.length; c++)
                            if (!contains('.' + classes[c], selectorTextArr))
                                selectorTextArr.push('.' + classes[c]);
                    }

                    // Extract CSS Rules
                    var extractedCSSText = "";
                    for (var i = 0; i < document.styleSheets.length; i++) {
                        var s = document.styleSheets[i];

                        try {
                            if (!s.cssRules) continue;
                        } catch (e) {
                            if (e.name !== 'SecurityError') throw e; // for Firefox
                            continue;
                        }

                        var cssRules = s.cssRules;
                        for (var r = 0; r < cssRules.length; r++) {
                            if (contains(cssRules[r].selectorText, selectorTextArr))
                                extractedCSSText += cssRules[r].cssText;
                        }
                    }


                    return extractedCSSText;

                    function contains(str, arr) {
                        return arr.indexOf(str) === -1 ? false : true;
                    }

                }

                function appendCSS(cssText, element) {
                    var styleElement = document.createElement("style");
                    styleElement.setAttribute("type", "text/css");
                    styleElement.innerHTML = cssText;
                    var refNode = element.hasChildNodes() ? element.children[0] : null;
                    element.insertBefore(styleElement, refNode);
                }
            }


            function svgString2Image(svgString, width, height, format, callback) {
                var format = format ? format : 'png';

                var imgsrc = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgString))); // Convert SVG string to data URL

                var canvas = document.createElement("canvas");
                var context = canvas.getContext("2d");

                canvas.width = width;
                canvas.height = height;

                var image = new Image();
                image.onload = function () {
                    context.clearRect(0, 0, width, height);
                    context.drawImage(image, 0, 0, width, height);

                    canvas.toBlob(function (blob) {
                        var filesize = Math.round(blob.length / 1024) + ' KB';
                        if (callback) callback(blob, filesize);
                    });


                };

                image.src = imgsrc;
            }



            self.showGEGraph = true;
            $scope.showGEGraph = true;


        }


        // //console.log(network.parallel);
        // //console.log(network.circular);
        // update(network.nodes, network.edges, network.parallel, network.circular);
        //console.log(network.nodes);
        //console.log(ptmToAbundance);
        for (var iterNetNode = 0; iterNetNode < network.nodes.length; iterNetNode++)
        {
            var iterNetNodeKey = network.nodes[iterNetNode]["name"];
            if (iterNetNodeKey in ptmToAbundance)
            {
                //console.log(iterNetNodeKey);
                if (ptmToAbundance[iterNetNodeKey] == "NA")
                {
                    network.nodes[iterNetNode]["value"] = 0.0;
                }
                else {
                    network.nodes[iterNetNode]["value"] = ptmToAbundance[iterNetNodeKey];
                }
            }
        }
        //console.log(self.computeWeightForupdatePtm);
        // if(self.computeWeightForUpdateGE) {
            //console.log("---  inside computeWeightForUpdatePtm");
            for (var iterNetNode = 0; iterNetNode < network.edges.length; iterNetNode++) {
                //var iterNetNodeKey = network.nodes[iterNetNode]["name"];
                var idx1 = network.edges[iterNetNode]["source"];
                var idx2 = network.edges[iterNetNode]["target"];
                network.nodes[idx1]["weight"] += 1;
                network.nodes[idx2]["weight"] += 1;

            }
            self.computeWeightForUpdateGE = false;
            SharedService.setVar('computeWeightForUpdateGE',self.computeWeightForUpdateGE);
        // }
        //console.log(network);
        updateGE(network.nodes, network.edges, fontSize, widthSize, circleSize, nodeSize);
        console.log("self.showGEGraph");
        console.log($scope.showGEGraph);


        self.showGEGraph = true;
    }

    function convertToCSV(objArray) {
        var array = typeof objArray != 'object' ? JSON.parse(objArray) : objArray;
        var str = '';

        for (var i = 0; i < array.length; i++) {
            var line = '';
            for (var index in array[i]) {
                if (line != '') line += ','

                line += array[i][index];
            }

            str += line + '\r\n';
        }

        return str;
    }

    function exportCSVFile(headers, items, fileTitle) {
        if (headers) {
            items.unshift(headers);
        }

        // Convert Object to JSON
        var jsonObject = JSON.stringify(items);

        var csv = this.convertToCSV(jsonObject);

        var exportedFilenmae = fileTitle + '.csv' || 'export.csv';

        var blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        if (navigator.msSaveBlob) { // IE 10+
            navigator.msSaveBlob(blob, exportedFilenmae);
        } else {
            var link = document.createElement("a");
            if (link.download !== undefined) { // feature detection
                // Browsers that support HTML5 download attribute
                var url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", exportedFilenmae);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }
    }


    function convertToCSV(objArray) {
        var array = typeof objArray != 'object' ? JSON.parse(objArray) : objArray;
        var str = '';

        for (var i = 0; i < array.length; i++) {
            var line = '';
            for (var index in array[i]) {
                if (line != '') line += ','

                line += array[i][index];
            }

            str += line + '\r\n';
        }

        return str;
    }

    function exportCSVFile(headers, items, fileTitle) {
        if (headers) {
            items.unshift(headers);
        }

        // Convert Object to JSON
        var jsonObject = JSON.stringify(items);

        var csv = convertToCSV(jsonObject);

        var exportedFilenmae = fileTitle + '.csv' || 'export.csv';

        var blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        if (navigator.msSaveBlob) { // IE 10+
            navigator.msSaveBlob(blob, exportedFilenmae);
        } else {
            var link = document.createElement("a");
            if (link.download !== undefined) { // feature detection
                // Browsers that support HTML5 download attribute
                var url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", exportedFilenmae);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }
    }

    $scope.downloadCSVExampleForGraph1 = function(){
        //var headers = {
        //     model: 'Phone Model'.replace(/,/g, ''), // remove commas to avoid errors
        //     chargers: "Chargers",
        //     cases: "Cases",
        //     earphones: "Earphones"
        // };

        //var itemsNotFormatted = [
        //     {
        //         model: 'Samsung S7',
        //         chargers: '55',
        //         cases: '56',
        //         earphones: '57',
        //         scratched: '2'
        //     },
        //     {
        //         model: 'Pixel XL',
        //         chargers: '77',
        //         cases: '78',
        //         earphones: '79',
        //         scratched: '4'
        //     },
        //     {
        //         model: 'iPhone 7',
        //         chargers: '88',
        //         cases: '89',
        //         earphones: '90',
        //         scratched: '6'
        //     }
        // ];



        d3.csv('./example/graph_illustration.csv', function (data) {

            console.log(data);
            var itemsFormatted = [];
            var headers = {
                Category1: 'Category1'.replace(/,/g, ''), // remove commas to avoid errors
                Category2: "Category2",
                Relation: "Relation",
                Category1Id: "Category1Id",
                Category2Id: "Category2Id",
                EdgeId: "EdgeId"
            };
            var itemsNotFormatted = data;
            itemsNotFormatted.forEach( function(item){
                itemsFormatted.push({
                    Category1: item.Category1.replace(/,/g, ''), // remove commas to avoid errors,
                    Category2: item.Category2.replace(/,/g, ''),
                    Relation: item.Relation.replace(/,/g, ''),
                    Category1Id: item.Category1Id.replace(/,/g, ''),
                    Category2Id: item.Category2Id.replace(/,/g, ''),
                    EdgeId: item.EdgeId.replace(/,/g, '')

                });
            });

            var fileTitle = 'pinet_graph_illustration'; // or 'my-unique-title'

            exportCSVFile(headers, itemsFormatted, fileTitle); // call the exportCSVFile() function to process the JSON and trigger the download

        })
        // format the data

    }


    $scope.downloadCSVExampleForGraph2 = function(){
        //var headers = {
        //     model: 'Phone Model'.replace(/,/g, ''), // remove commas to avoid errors
        //     chargers: "Chargers",
        //     cases: "Cases",
        //     earphones: "Earphones"
        // };

        //var itemsNotFormatted = [
        //     {
        //         model: 'Samsung S7',
        //         chargers: '55',
        //         cases: '56',
        //         earphones: '57',
        //         scratched: '2'
        //     },
        //     {
        //         model: 'Pixel XL',
        //         chargers: '77',
        //         cases: '78',
        //         earphones: '79',
        //         scratched: '4'
        //     },
        //     {
        //         model: 'iPhone 7',
        //         chargers: '88',
        //         cases: '89',
        //         earphones: '90',
        //         scratched: '6'
        //     }
        // ];



        d3.csv('./example/out-klts_abbrevs_09_10_2019-10.csv', function (data) {

            console.log(data);
            var itemsFormatted = [];
            var headers = {
                Category1: 'Category1'.replace(/,/g, ''), // remove commas to avoid errors
                Category2: "Category2",
                Relation: "Relation",
                Category1Id: "Category1Id",
                Category2Id: "Category2Id",
                EdgeId: "EdgeId"
            };
            var itemsNotFormatted = data;
            itemsNotFormatted.forEach( function(item){
                itemsFormatted.push({
                    Category1: item.Category1.replace(/,/g, ''), // remove commas to avoid errors,
                    Category2: item.Category2.replace(/,/g, ''),
                    Relation: item.Relation.replace(/,/g, ''),
                    Category1Id: item.Category1Id.replace(/,/g, ''),
                    Category2Id: item.Category2Id.replace(/,/g, ''),
                    EdgeId: item.EdgeId.replace(/,/g, '')

                });
            });

            var fileTitle = 'pinet_graph_illustration_node_ordered'; // or 'my-unique-title'

            exportCSVFile(headers, itemsFormatted, fileTitle); // call the exportCSVFile() function to process the JSON and trigger the download

        })
        // format the data

    }

    //console.log("$scope.siteVisit");
    //console.log($scope.siteVisit);



    //console.log("========= change URL =============");
    //console.log($location.url());
    //console.log("self.showSplash");
    //console.log(self.showSplash);
    //console.log($location.url());

    $scope.$on('$locationChangeStart', function(event) {
        // call your method here

        if($location.url().contains('ptmToModifier') || $location.url().contains('peptideToProtein') || $location.url().contains('proteinToPathway') || $location.url().contains('help') || $location.url().contains('upload') || $location.url().contains('modification')) {
            self.showSplash = false;
            SharedService.setVar('showSplash', false);
            //console.log($location.url());
            //console.log($location.url());
            //console.log("self.showSplash");
            //console.log(self.showSplash);
            //console.log($location.url());
            self.firstVisit = false;
            SharedService.setVar('firstVisit', false);

            //$scope.$apply();
        }
        else
        {
            //console.log($location.url());
            if (self.firstVisit == false) {
                self.showSplash = false;
                SharedService.setVar('showSplash', false);
                $location.url("/peptideToProtein");
                self.url = $location.url();
                //console.log($location.url());
            }
            //console.log("self.showSplash");
            //console.log(self.showSplash);
            //console.log("self.firstVisit");
            //console.log(self.firstVisit);
            //$scope.$apply();
        }
    });



    //self.proteinForm = "";//"" for canonical, "{+iso" for canonical+isoform
    //console.log(self.organismForm);
    //console.log(self.proteinForm);

//This is for navigation tabs
    $scope.tabs = SharedService.getVar('tabs');


    // $scope.selectedTab = $scope.tabs[0];
    $scope.setSelectedTab = function (tab) {
        $scope.selectedTab = tab;
        //console.log($scope.selectedTab.link);
        //console.log($scope.selectedTab.label);
        self.activeSite = $scope.selectedTab.link;

        //console.log("url");
        $location.url(self.activeSite);
        self.url = $location.url();
        //console.log(self.url);

    }



    $('.tabgroup > div').hide();
    $('.tabgroup > div:first-of-type').show();
    $('.tabs22 a').click(function(e){
        e.preventDefault();
        var $this = $(this),
            tabgroup = '#'+$this.parents('.tabs22').data('tabgroup'),
            others = $this.closest('li').siblings().children('a'),
            target = $this.attr('href');
        others.removeClass('active');
        $this.addClass('active');
        $(tabgroup).children('div').hide();
        $(target).show();

    })

    // //console.log($scope.selectedTab.link);
    // //console.log($scope.selectedTab.label);


    // $(document).ready(function () {
    //     $('[data-toggle="tooltip"]').tooltip({
    //         trigger: 'hover'
    //     });
    // });
    // $scope.tabClass = function (tab) {
    //     if ($scope.selectedTab == tab) {
    //         self.activeSite = $scope.selectedTab.link;
    //         return "active";
    //
    //     } else {
    //         return "";
    //     }
    // }
    //
    //
    //
    // $(document).ready(function () {
    //
    //
    //     var numItems = $('li.fancyTab').length;
    //
    //
    //     if (numItems == 12) {
    //         $("li.fancyTab").width('8.3%');
    //     }
    //     if (numItems == 11) {
    //         $("li.fancyTab").width('9%');
    //     }
    //     if (numItems == 10) {
    //         $("li.fancyTab").width('10%');
    //     }
    //     if (numItems == 9) {
    //         $("li.fancyTab").width('11.1%');
    //     }
    //     if (numItems == 8) {
    //         $("li.fancyTab").width('12.5%');
    //     }
    //     if (numItems == 7) {
    //         $("li.fancyTab").width('14.2%');
    //     }
    //     if (numItems == 6) {
    //         $("li.fancyTab").width('16.666666666666667%');
    //     }
    //     if (numItems == 5) {
    //         $("li.fancyTab").width('20%');
    //     }
    //     if (numItems == 4) {
    //         $("li.fancyTab").width('25%');
    //     }
    //     if (numItems == 3) {
    //         $("li.fancyTab").width('33.3%');
    //     }
    //     if (numItems == 2) {
    //         $("li.fancyTab").width('50%');
    //     }
    //
    //
    // });
    //
    // $(window).load(function () {
    //
    //     $('.fancyTabs').each(function () {
    //
    //         var highestBox = 0;
    //         $('.fancyTab a', this).each(function () {
    //
    //             if ($(this).height() > highestBox)
    //                 highestBox = $(this).height();
    //         });
    //
    //         $('.fancyTab a', this).height(highestBox);
    //
    //     });
    // });
    $(document).ready(function(){
        $('[data-toggle="tooltip"]').tooltip();
    });

}]);

appModule.controller("ModificationCtrl", ['$scope', '$http', '$location', '$window', '$timeout', '$routeParams', '$filter', '$q', 'filterFilter', 'SharedService', function ($scope, $http, $location, $window, $timeout, $routeParams, $filter, $q, filterFilter, SharedService) {
    //console.log("--------------- Restarting About! ---------------");
    SharedService.getSiteVisit().then(function(successResponse){
        self.siteVisit = successResponse;
        //console.log(self.siteVisit);
    });





    //console.log("self.siteVisit");
    //console.log(self.siteVisit);



    //console.log("========= change URL =============");
    //console.log($location.url());
    //console.log("self.showSplash");
    //console.log(self.showSplash);
    //console.log($location.url());

    $scope.$on('$locationChangeStart', function(event) {
        // call your method here

        if($location.url().contains('ptmToModifier') || $location.url().contains('peptideToProtein') || $location.url().contains('proteinToPathway') || $location.url().contains('help') || $location.url().contains('upload') || $location.url().contains('modification')) {
            self.showSplash = false;
            SharedService.setVar('showSplash', false);
            //console.log($location.url());
            //console.log($location.url());
            //console.log("self.showSplash");
            //console.log(self.showSplash);
            //console.log($location.url());
            self.firstVisit = false;
            SharedService.setVar('firstVisit', false);

            //$scope.$apply();
        }
        else
        {
            //console.log($location.url());
            if (self.firstVisit == false) {
                self.showSplash = false;
                SharedService.setVar('showSplash', false);
                $location.url("/peptideToProtein");
                self.url = $location.url();
                //console.log($location.url());
            }
            //console.log("self.showSplash");
            //console.log(self.showSplash);
            //console.log("self.firstVisit");
            //console.log(self.firstVisit);
            //$scope.$apply();
        }
    });



    //self.proteinForm = "";//"" for canonical, "{+iso" for canonical+isoform
    //console.log(self.organismForm);
    //console.log(self.proteinForm);

//This is for navigation tabs
    $scope.tabs = SharedService.getVar('tabs');


    // $scope.selectedTab = $scope.tabs[0];
    $scope.setSelectedTab = function (tab) {
        $scope.selectedTab = tab;
        //console.log($scope.selectedTab.link);
        //console.log($scope.selectedTab.label);
        self.activeSite = $scope.selectedTab.link;

        //console.log("url");
        $location.url(self.activeSite);
        self.url = $location.url();
        //console.log(self.url);

    }


}]);




appModule.controller("MainCtrl", ['$scope', '$http', '$location', '$window', '$timeout', '$routeParams', '$filter', '$q', 'filterFilter', 'SharedService', 'NgTableParams', '$uibModal', function ($scope, $http, $location, $window, $timeout, $routeParams, $filter, $q, filterFilter, SharedService, NgTableParams, $uibModal) {
    //console.log("--------------- Restarting peptide 2 uniprot! ---------------");
    var self = this;
    //self.showPLN = false;
    // self.showSection1 = true;
    // self.showSection2 = false;
    self.progressText = "";
    $scope.rating = 50
    self.showExampleForPeptide = true;
    self.showGeneInSplash = true;
    self.formatAsInchOrAllhits = 0;
    //self.formatInput = SharedService.getVar('formatInput');
    self.formatAsJsonOrInline = false;
    self.allVsFirstPrositeHits = false;
    self.prositeFound = '';
    self.showShorthandTable = false;
    self.uniprotFound = '';
    self.showExamples = false;
    self.ex1orex2 = SharedService.getVar("ex1orex2");
    self.showOutputex1orex2 = SharedService.getVar("showOutputex1orex2");

    $('input[name=tabset3][id=' + self.ex1orex2 + ']').prop('checked', true);
    $("input[name='tabset3']").click(function () {
        self.ex1orex2 = this.id;
        console.log(self.ex1orex2);

        SharedService.setVar("ex1orex2", self.ex1orex2);
        $scope.$apply();

    });
    self.resultTab = SharedService.getVar("resultTab");

    $('input[name=tabs][id=' + self.resultTab + ']').prop('checked', true);
    $("input[name='tabs']").click(function () {
        self.resultTab = this.id;

        SharedService.setVar("resultTab", self.resultTab);
        $scope.$apply();

    });


    $scope.newSite = function (url) {


        document.getElementById('iframe_modal').src = url;
    }
    //
    // $('<iframe name="iframe_modal"/>').appendTo('body').attr({'id': 'iframeUploader'});


    $scope.openIframeModal = function (linkID, type) {


        var modalInstance = $uibModal.open({
            animation: $scope.animationsEnabled,
            // templateUrl: 'myModalContent.html',
            templateUrl: 'myModalContent.html',
            controller: 'iFrameModalInstanceCtrl',
            size: 'xxl',
            windowClass: 'app-modal-window',
            resolve: {
                linkID: function () {
                    return linkID;
                },
                type: function () {
                    return type;
                }
            }
        });
    }
    //
    // $('#myModal22').on('hidden.bs.modal', function () {
    //     $(this).removeData('bs.modal');
    // });
    //
    //
    // $("#somediv").click(function() {
    //     opendialog("https://www.ebi.ac.uk/ols/ontologies/mod/terms?obo_id=MOD:00723");
    // });
    //
    // function opendialog(page) {
    //     var $dialog = $('#somediv')
    //         .html('<iframe style="border: 0px; " src="' + page + '" width="100%" height="100%"></iframe>')
    //         .dialog({
    //             title: "Page",
    //             autoOpen: false,
    //             dialogClass: 'dialog_fixed,ui-widget-header',
    //             modal: true,
    //             height: 500,
    //             minWidth: 400,
    //             minHeight: 400,
    //             draggable:true,
    //             /*close: function () { $(this).remove(); },*/
    //             buttons: { "Ok": function () {         $(this).dialog("close"); } }
    //         });
    //     console.log("in opendialog");
    //     console.log(page);
    //     $dialog.dialog('open');
    // }

    // $('#remoteModal').on('show.bs.modal', function (e) {
    //     var loadurl = $(e.relatedTarget).dataset.loadUrl;
    //     $(this).find('.modal-body').load(loadurl);
    // });
    //
    // //JS script
    // $('.ls-modal').on('click', function(e){
    //     e.preventDefault();
    //     $('#myModal').modal('show').find('.modal-body').load($(this).attr('href'));
    // });

    //self.motifLength = 0;

//This is to activate tooltip otherwise it is not working on some occasions
    function windowpop(url, width, height) {
        var leftPosition, topPosition;
        //Allow for borders.
        leftPosition = (window.screen.width / 2) - ((width / 2) + 10);
        //Allow for title and status bars.
        topPosition = (window.screen.height / 2) - ((height / 2) + 50);
        //Open the window.
        window.open(url, "Window2", "status=no,height=" + height + ",width=" + width + ",resizable=yes,left=" + leftPosition + ",top=" + topPosition + ",screenX=" + leftPosition + ",screenY=" + topPosition + ",toolbar=no,menubar=no,scrollbars=no,location=no,directories=no");
    }

    $(document).ready(function () {
        $("body").tooltip({selector: '[data-toggle=tooltip]'});
    });


    // $('a.example').click(function(){   //bind handlers
    //     var url = $(this).attr('href');
    //     showDialog(url);
    //
    //     return false;
    // });
    //
    // $("#targetDiv").dialog({  //create dialog, but keep it closed
    //     autoOpen: false,
    //     height: 300,
    //     width: 350,
    //     modal: true
    // });
    //
    // function showDialog(url){  //load content and open dialog
    //     $("#targetDiv").load(url);
    //     $("#targetDiv").dialog("open");
    // }


    // self.siteVisit = SharedService.getSiteVisit()
    //     .then(
    //         function(response) {
    //             // promise was fullfilled (regardless of outcome)
    //             // checks for information will be peformed here
    //             return response.value;
    //         },
    //         function(error) {
    //             // handle errors here
    //             //console.log(error.statusText);
    //         }
    //     );


    //self.showOutputPtm = true;
    //self.showOutputPathway = true;
    self.noResponse = false;
    //$scope.showGeneNetworkProcessed = false;
    //$scope.showKinaseNetworkProcessed = false;
    //self.showPhosphoGeneNetworkProcessed = false;
    //self.showGeneNetwork = true;
    //self.showPhosphoGeneNetwork = true;
    //console.log("$scope.showGeneNetworkProcessed");
    //console.log($scope.showGeneNetworkProcessed);

//This is for grid show of parallel view in networks
    self.showGrid1 = false;
    self.modificationPattern = /[^A-Z]/g;
    self.modificationPatternWithLetter = /[A-Z]\[\+[\d\.]+]/g;
    self.modificationPatternSecondFormat = /\[[a-z0-9]+[A-Z]+\]/g;
    // self.modificationPatternForAllPTMs = /[^[\]]+(?=])/g;
    // self.modificationPatternForAllProteins = /(?:^|])([^[\]]+)/g;
    self.modificationPatternForAllPTMs = /{(.+)}/g;
    self.modificationPatternForAllProteins = /(?:^|])([^[\]]+)/g;
    self.paranthesesPattern = /[A-Z]\(([^)]+)\)/g;
    self.rowSplitPattern = /[,;\n]/;
    self.rowSplitPatternGenes = /[,;\n]/;
    self.cleanFormattedModifications = /\[/;
    self.patt1 = /[A-Z]/g;
    self.patt2 = /[a-z0-9]+/g;
    self.patt3 = /\d+/g
    self.patt4 = /[+\d\.]+/g;
    self.patt5 = /^[0-9]+([,.][0-9]+)?$/g;
    self.patt6 = /^[\d.]/g;

    self.modificationForGenes = /\b\w*[^\[]\w*\b/g;
    self.modificationForptmProteins = /\b\w*[\[]\w*\b/g;

    self.modificationMap = {'a': 42.037, 'me': 14.027, 'me2': 28.05, 'me3': 42.046, 'p': 79.966, 'my': 210.198};
    self.modificationMapReverse = {42.037: 'a', 14.027: 'me', 28.05: 'me2', 42.046: 'me3', 79.966: 'p', 210.198: 'my'};

    self.modificationNameMap = {'a': 'acetyl', 'me': 'methyl', 'me2': 'dimethyl', 'me3': 'trimethyl', 'p': 'phospho', 'my': 'myristoy'};

    self.modificationAminoMap =
        {
            'A':'alanine',
            'R': 'arginine',
            'N': 'asparagine',
            'D': 'aspartic',
            'C': 'cysteine',
        'Q': 'glutamine',
        'E': 'glutamic',
        'G': 'glycine',
        'H': 'histidine',
        'I': 'isoleucine',
        'L': 'leucine',
        'K': 'lysine',
        'M': 'methionine',
        'F': 'phenylalanine',
        'P': 'proline',
        'S': 'serine',
        'T': 'threonine',
        'W': 'tryptophan',
        'Y': 'tyrosine',
        'V': 'valine'
        };



    self.proteinMap = {};
    self.hugoProteinMap = {};
    var protPlace = 0;
    var emptyList = [];

    self.prResponseJson = {};

    var distinct = [];
    var firstPrositeResponseFiltered = [];
    self.parsedMotifs = [];
    self.parsedPeptides = [];
    //self.genes = "TP53,BRAF,OCIAD1,NCOR2,ZC3HC1,RPS6KA3,PDPK1,PDPK2P,HN1,MAP4,ABI1";
    //self.sampleGenes = ["OCIAD1", "NCOR2", "ZC3HC1", "RPS6KA3", "PDPK1", "PDPK2P", "HN1", "BRAF", "TP53"];
    self.parsedPTMProteins = [];

    self.parsedGenes = [];
    self.parsedModifications = [];
    self.parsedModificationsFormatter = [];
    self.ontologyMappings = [];
    self.ontologyMappingsUnique = [];
    self.numResponsesFromProsite = 0;
    self.numResponsesFromUniprot;

    self.plnFirstHit = [];
    self.sequence_acList = [];
    self.geneIdList = [];

    self.url = $location.url();

    //self.motifLength = 1;
    self.peptideOrGenes = true;
    self.peptideOrProteinsOrGenes = 0;
    // self.showTableRow1 = false;
    // self.showTableRow2 = false;
    // self.showTableRow3 = false;
    // self.showTableRow4 = false;
    // self.showTableRow5 = false;
    // self.showTableRow6 = false;
    self.showUploadFlag = false;
    self.plnFormatted = "";


    //console.log(self.organismForm);
    self.progressPercent = 0;
    self.tableGO = SharedService.getVar('tableGO');
    self.tableSubCellular = SharedService.getVar('tableSubCellular');
    self.tableReactome = SharedService.getVar('tableReactome');

    self.subCellularTableData = SharedService.getVar("subCellularTableData");
    self.subCellularValues = SharedService.getVar("subCellularValues");
    self.subCellularLabels = SharedService.getVar("subCellularLabels");

    self.reactomeTableData = SharedService.getVar("reactomeTableData");
    self.reactomeValues = SharedService.getVar("reactomeValues");
    self.reactomeLabels = SharedService.getVar("reactomeLabels");

    self.goTableData = SharedService.getVar("goTableData");
    self.goLabels = SharedService.getVar("goLabels");
    self.goValues = SharedService.getVar("goValues");




    SharedService.getSiteVisit().then(function (successResponse) {
        self.siteVisit = successResponse;
        //console.log(self.siteVisit);
    });
    //console.log("self.siteVisit");
    //console.log(self.siteVisit);
    self.showSplash = SharedService.getVar('showSplash');
    self.firstVisit = SharedService.getVar('firstVisit');
    // self.uniprotFoundNum = SharedService.getVar('uniprotFoundNum');
    //self.textAreaFormatMD = SharedService.getVar('textAreaFormatMD');
    //self.textAreaFormatSN = SharedService.getVar('textAreaFormatSN');
    self.textArea = SharedService.getVar('textArea');
    self.waiting = SharedService.getVar('waiting');
    self.showOutput = SharedService.getVar('showOutput');
    self.genes = SharedService.getVar('genes');
    //self.organism = SharedService.getVar('organism');

    self.inputMassPtmProteins = SharedService.getVar('inputMassPtmProteins');
    self.inputShorthandPtmProteins = SharedService.getVar('inputShorthandPtmProteins');
    self.uniprotJsonObjectAllForProtein2Pathways = SharedService.getVar('uniprotJsonObjectAllForProtein2Pathways');
    self.genesForProtein2Pathways = SharedService.getVar('genesForProtein2Pathways');
    self.uniprotJsonObjectAllForProtein2Pathways = SharedService.getVar('uniprotJsonObjectAllForProtein2Pathways');
    //self.massPtmProteinsForProtein2Pathways = SharedService.getVar('massPtmProteinsForProtein2Pathways');
    self.shorthandPtmProteinsForProtein2Pathways = SharedService.getVar('shorthandPtmProteinsForProtein2Pathways');
    // self.waitingForPeptideToProtein = SharedService.getVar('waitingForPeptideToProtein');
    // self.showOutputForPeptideToProtein = SharedService.getVar('showOutputForPeptideToProtein');
    self.organismForm = SharedService.getVar('organismForm');
    self.proteinForm = SharedService.getVar('proteinForm');
    self.proteinDb = SharedService.getVar('proteinDb');
    self.peptideNormalizeFlag = SharedService.getVar('peptideNormalizeFlag');
    self.prositeFoundNum = SharedService.getVar('prositeFoundNum');
    self.motifLength = SharedService.getVar('motifLength');
    self.uniprotFoundNum = SharedService.getVar('uniprotFoundNum');
    self.uniprotLength = SharedService.getVar('uniprotLength');
    self.geneIdListLength = SharedService.getVar('geneIdListLength');

    self.peptideToModificationList = SharedService.getVar('peptideToModificationList');
    self.peptideToModificationListOrig = SharedService.getVar('peptideToModificationListOrig');
    self.showOverAllParallelSVG = SharedService.getVar('showOverAllParallelSVG');
    self.showPLN = SharedService.getVar('showPLN');
    self.plnFormatOne = SharedService.getVar('plnFormatOne');
    self.plnFormatTwo = SharedService.getVar('plnFormatTwo');
    self.plnFormatThree = SharedService.getVar('plnFormatThree');
    self.ptmToModifierPtmOrGene = SharedService.getVar('ptmToModifierPtmOrGene');
    self.proteinToPathwayPathwayOrGene = SharedService.getVar('proteinToPathwayPathwayOrGene');
    //console.log(self.plnFormatOne);
    //console.log(self.plnFormatTwo);
    self.prResponseList = SharedService.getVar('prResponseList');
    self.sequence_acListComplete = SharedService.getVar('sequence_acListComplete');
    self.uploadedFalg = false;
    self.uploadWaiting = false;
    self.sliderFoldChangeValue = SharedService.getVar("sliderFoldChangeValue");
    self.sliderSignificanceValue = SharedService.getVar("sliderSignificanceValue");
    self.sliderLogSignificanceValue = Math.log10(self.sliderSignificanceValue);
    self.sliderLogFoldChangeValue = Math.log2(self.sliderFoldChangeValue);
    self.list_of_positive_peps = SharedService.getVar("list_of_positive_peps");
    self.list_of_negative_peps = SharedService.getVar("list_of_negative_peps");
    self.inputArrayTable = SharedService.getVar("inputArrayTable");
    self.selectedArrayTable = SharedService.getVar("selectedArrayTable");
    self.uploadErrorTag = SharedService.getVar("uploadErrorTag");
    self.uploadErrorText = SharedService.getVar("uploadErrorText");
    self.inputArray = SharedService.getVar("inputArray");
    self.selectedArray = SharedService.getVar("selectedArray");
    self.dataForAllPeptides = SharedService.getVar("dataForAllPeptides");
    self.volcanoJson = SharedService.getVar("volcanoJson");
    self.list_of_positive_negative_peps = SharedService.getVar("list_of_positive_negative_peps");
    self.list_of_negative_peps = SharedService.getVar("list_of_negative_peps");
    self.list_of_positive_peps = SharedService.getVar("list_of_positive_peps");
    self.peptideToAbundance = SharedService.getVar("peptideToAbundance");
    self.peptideToNumberOfProteins = SharedService.getVar("peptideToNumberOfProteins");
    //self.showModal = SharedService.getVar("showModal");

    //console.log(self.organismForm);
    //console.log(self.proteinForm);

    //console.log(self.showOutput);
    //console.log(self.waiting);

    var ignoreScrollEvents = false;

    function syncScroll(element1, element2, element3) {
        element1.scroll(function (e) {
            var ignore = ignoreScrollEvents;
            ignoreScrollEvents = false;
            // //console.log("in scroll");
            if (ignore) return;
            // //console.log("in scroll2");
            ignoreScrollEvents = true;
            element2.scrollTop(element1.scrollTop());
            element3.scrollTop(element1.scrollTop());
        })
    }

    syncScroll($("#div11"), $("#div12"), $("#div13"));
    syncScroll($("#div12"), $("#div11"), $("#div13"));
    syncScroll($("#div13"), $("#div11"), $("#div12"));

    // if(self.showModal) {
    //
    //     $('#firstModal').modal('show');
    //
    //
    // }


    function BrowserDetection() {
    // Opera 8.0+
    var isOpera = (!!window.opr && !!opr.addons) || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;

// Firefox 1.0+
    var isFirefox = typeof InstallTrigger !== 'undefined';

// Safari 3.0+ "[object HTMLElementConstructor]"
    var isSafari = /constructor/i.test(window.HTMLElement) || (function (p) { return p.toString() === "[object SafariRemoteNotification]"; })(!window['safari'] || (typeof safari !== 'undefined' && safari.pushNotification));

// Internet Explorer 6-11
    var isIE = /*@cc_on!@*/false || !!document.documentMode;

// Edge 20+
    var isEdge = !isIE && !!window.StyleMedia;

// Chrome 1 - 71
    var isChrome = !!window.chrome && (!!window.chrome.webstore || !!window.chrome.runtime);

// Edge (based on chromium) detection
    var isEdgeChromium = isChrome && (navigator.userAgent.indexOf("Edg") != -1);

// Blink engine detection
    var isBlink = (isChrome || isOpera) && !!window.CSS;

        //Check if browser is IE

        //Check if browser is Chrome
        if(isSafari || isOpera || isIE || isEdge || isEdgeChromium){
            console.log("showing modal");
            console.log(isSafari);
            console.log(isOpera);
            console.log(isIE);
            console.log(isEdge);
            console.log(isEdgeChromium);
            //console.log(isBlink);
            console.log("End of showing modal");
            $('#firstModal').modal('show');
        }

    var output = 'Detecting browsers by ducktyping:<hr>';
    output += 'isFirefox: ' + isFirefox + '<br>';
    output += 'isChrome: ' + isChrome + '<br>';
    output += 'isSafari: ' + isSafari + '<br>';
    output += 'isOpera: ' + isOpera + '<br>';
    output += 'isIE: ' + isIE + '<br>';
    output += 'isEdge: ' + isEdge + '<br>';
    output += 'isEdgeChromium: ' + isEdgeChromium + '<br>';
    output += 'isBlink: ' + isBlink + '<br>';
    console.log(output);
    };
    BrowserDetection();

    // $(window).load(function(){
    //     console.log(self.showModal);
    //     console.log("showing modal 0");
    //     if(self.showModal) {
    //         $('#firstModal').modal('show');
    //     }
    // });
    //
    // $(document).ready(function(){
    //     console.log(self.showModal);
    //     console.log("showing modal 0");
    //     if(self.showModal) {
    //         console.log("showing modal 1");
    //         $("#firstModal").modal('show');
    //         console.log("showing modal 2");
    //
    //     }
    // });



    //console.log("========= change URL =============");
    //console.log($location.url());
    //console.log("self.showSplash");
    //console.log(self.showSplash);
    //console.log($location.url());

    $scope.$on('$locationChangeStart', function (event) {
        // call your method here

        if ($location.url().contains('ptmToModifier') || $location.url().contains('peptideToProtein') || $location.url().contains('proteinToPathway') || $location.url().contains('help') || $location.url().contains('upload') || $location.url().contains('modification')) {
            self.showSplash = false;
            SharedService.setVar('showSplash', false);
            //console.log($location.url());
            //console.log($location.url());
            //console.log("self.showSplash");
            //console.log(self.showSplash);
            //console.log($location.url());
            self.firstVisit = false;
            SharedService.setVar('firstVisit', false);

            //$scope.$apply();
        }
        else {
            //console.log($location.url());
            if (self.firstVisit == false) {
                self.showSplash = false;
                SharedService.setVar('showSplash', false);
                $location.url("/peptideToProtein");
                self.url = $location.url();
                //console.log($location.url());


            }
            //console.log("self.showSplash");
            //console.log(self.showSplash);
            //console.log("self.firstVisit");
            //console.log(self.firstVisit);
            //$scope.$apply();
        }
    });


    // $("#div11").scroll(function () {
    //     $("#div12").scrollTop($("#div11").scrollTop());
    //     $("#div13").scrollTop($("#div11").scrollTop());
    // });
    // $("#div12").scroll(function () {
    //     $("#div11").scrollTop($("#div12").scrollTop());
    //     $("#div13").scrollTop($("#div12").scrollTop());
    //
    // });
    // $("#div13").scroll(function () {
    //     $("#div11").scrollTop($("#div13").scrollTop());
    //     $("#div12").scrollTop($("#div13").scrollTop());
    //
    // });


    // function updateTextInput(val) {
    //     document.getElementById('textInput').value=val;
    //     //console.log(val);
    // }
    //
    // var slider = document.getElementById("myRange");
    // var output = document.getElementById("demo");
    // output.innerHTML = slider.value;
    //
    // slider.oninput = function() {
    //     output.innerHTML = this.value;
    // }
//Working example
    //Volcano plot =====================================================================

    // callVolcanoPlotFromTSVFile = function (fc, pv) {
    //
    //     //console.log(fc);
    //     //console.log(pv);
    //     self.list_of_positive_peps = [];
    //     self.list_of_negative_peps = [];
    //     self.sliderFoldChangeValue = fc;
    //     self.sliderLogFoldChangeValue = Math.log2(self.sliderFoldChangeValue);
    //     $scope.sliderFoldChangeValue = self.sliderFoldChangeValue;
    //     $scope.sliderLogFoldChangeValue = self.sliderLogFoldChangeValue;
    //
    //     var yLabel = 'log<tspan baseline-shift="sub">10</tspan>P Value',
    //         xLabel = 'log<tspan baseline-shift="sub">2</tspan>Fold-change',
    //         file = "data.diff";
    //
    //     var volcanoPlot = volcanoPlot()
    //         .xAxisLabel(xLabel)
    //         .yAxisLabel(yLabel)
    //         .foldChangeThreshold(fc)
    //         .significanceThreshold(pv)
    //         .sampleID("Peptide")
    //         .xColumn("log2(fold_change)")
    //         .yColumn("p_value");
    //
    //     // d3.csv('./example/mascot.csv', function (data) {
    //     //     //console.log(data);
    //     //     JSONToCSVConvertor(data, "Mascot", true);
    //     //     // alasql('SELECT * INTO XLSX("example.xlsx",{headers:true}) FROM ?', [data]);
    //     // })
    //
    //     d3.tsv('./example/data.diff', parser, function (error, data) {
    //         ////console.log(data);
    //
    //         // if (data[yColumn] <= significanceThreshold && data[xColumn] > foldChangeThreshold) {
    //         //     self.list_of_positive_peps.push(d[sampleID]);
    //         //
    //         // }
    //         //
    //         //
    //         // else if (d[yColumn] <= significanceThreshold && d[xColumn] < -foldChangeThreshold) {
    //         //     self.list_of_negative_peps.push(d[sampleID]);
    //         //     return 'dot sigfoldMinus';
    //         // }
    //         // self.list_of_positive_peps = [];
    //         // self.list_of_negative_peps = [];
    //         // self.list_of_positive_negative_peps = [];
    //         // data.forEach(function (obj) {
    //         //
    //         //     if (obj["p_value"] <= pv && obj["log2(fold_change)"] > fc) {
    //         //         self.list_of_positive_peps.push(obj);
    //         //     }
    //         //     if (obj["p_value"] <= pv && obj["log2(fold_change)"] < -fc) {
    //         //         self.list_of_negative_peps.push(obj);
    //         //     }
    //         //
    //         //
    //         // });
    //         // //console.log(self.list_of_positive_peps);
    //         // //console.log(self.list_of_negative_peps);
    //
    //         if (error) //console.log(error);
    //         d3.select("#volcano").select("svg").remove();
    //         d3.select('#volcano')
    //             .data([data])
    //             .call(volcanoPlot);
    //     });
    //
    //     // row parser to convert key values into numbers if possible
    //     function parser(d) {
    //         for (var key in d) {
    //             if (d.hasOwnProperty(key)) {
    //                 d[key] = numberParser(d[key]);
    //             }
    //         }
    //         return d;
    //     }
    //
    //     // function to turn string into number if possible
    //     function numberParser(value) {
    //         return (+value) ? +value : value;
    //     }
    //
    //     function volcanoPlot() {
    //         // var width = 960,
    //         //     height = 500,
    //         //     margin = {top: 20, right: 20, bottom: 40, left: 50},
    //         var width = 750,
    //             height = 400,
    //             margin = {top: 20, right: 20, bottom: 40, left: 60},
    //             xColumn, // name of the variable to be plotted on the axis
    //             yColumn,
    //             xAxisLabel, // label for the axis
    //             yAxisLabel,
    //             xAxisLabelOffset, // offset for the label of the axis
    //             yAxisLabelOffset,
    //             xTicks, // number of ticks on the axis
    //             yTicks,
    //             sampleID = "Peptide",
    //             significanceThreshold = 0.05, // significance threshold to colour by
    //             foldChangeThreshold = 1.0, // fold change level to colour by
    //             colorRange, // colour range to use in the plot
    //             xScale = d3.scale.linear(), // the values for the axes will be continuous
    //             yScale = d3.scale.log();
    //
    //
    //         function chart(selection) {
    //             var innerWidth = width - margin.left - margin.right, // set the size of the chart within its container
    //                 innerHeight = height - margin.top - margin.bottom;
    //
    //             selection.each(function (data) {
    //
    //                 // set up the scaling for the axes based on the inner width/height of the chart and also the range
    //                 // of value for the x and y axis variables. This range is defined by their min and max values as
    //                 // calculated by d3.extent()
    //                 xScale.range([0, innerWidth])
    //                     .domain(d3.extent(data, function (d) {
    //                         return d[xColumn];
    //                     }));
    //                 //.nice();
    //
    //                 // normally would set the y-range to [height, 0] but by swapping it I can flip the axis and thus
    //                 // have -log10 scale without having to do extra parsing
    //                 yScale.range([0, innerHeight])
    //                     .domain(d3.extent(data, function (d) {
    //                         return d[yColumn];
    //                     }));
    //                 //.nice(); // adds "padding" so the domain extent is exactly the min and max values
    //
    //
    //                 function zoomed() {
    //                     container.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
    //                 }
    //
    //                 var zoom2 = d3.behavior.zoom()
    //                     .scaleExtent([1, 20])
    //                     .scaleExtent([[0, 0], [width, height]])
    //                     .on('zoom', zoomFunction);
    //                 //.on('zoom', zoomed);
    //
    //
    //                 // append the svg object to the selection
    //                 var svg = d3.select(this).append('svg')
    //                     .attr('height', height)
    //                     .attr('width', width)
    //                     .append('g')
    //                     .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
    //                 //.call(zoom);
    //
    //                 var zoom = d3.behavior.zoom()
    //                 // only scale up, e.g. between 1x and 50x
    //                     .scaleExtent([1, 50])
    //                     .on("zoom", function () {
    //                         // the "zoom" event populates d3.event with an object that has
    //                         // a "translate" property (a 2-element Array in the form [x, y])
    //                         // and a numeric "scale" property
    //                         var e = d3.event,
    //                             // now, constrain the x and y components of the translation by the
    //                             // dimensions of the viewport
    //                             tx = Math.min(0, Math.max(e.translate[0], width - width * e.scale)),
    //                             ty = Math.min(0, Math.max(e.translate[1], height - height * e.scale));
    //                         // then, update the zoom behavior's internal translation, so that
    //                         // it knows how to properly manipulate it on the next movement
    //                         zoom.translate([tx, ty]);
    //                         // and finally, update the <g> element's transform attribute with the
    //                         // correct translation and scale (in reverse order)
    //
    //                         // var transform = d3.zoomTransform(this);
    //                         // //var transform = d3.event.transform;
    //                         // d3.selectAll('.dot')
    //                         //     .attr('transform', transform)
    //
    //
    //                         d3.selectAll('.dot').attr("transform", [
    //                             "translate(" + [tx, ty] + ")",
    //                             "scale(" + e.scale + ")"
    //                         ].join(" "));
    //                     });
    //
    //                 // then, call the zoom behavior on the svg element, which will add
    //                 // all of the necessary mouse and touch event handlers.
    //                 // remember that if you call this on the <g> element, the even handlers
    //                 // will only trigger when the mouse or touch cursor intersects with the
    //                 // <g> elements' children!
    //                 svg.call(zoom);
    //
    //                 // position the reset button and attach reset function
    //                 d3.select('#resetBtn')
    //                     .style('top', margin.top * 1.5 + 'px')
    //                     .style('left', margin.left * 1.25 + 'px')
    //                     .on('click', reset);
    //
    //                 svg.append('defs').append('clipPath')
    //                     .attr('id', 'clip')
    //                     .append('rect')
    //                     .attr('height', innerHeight)
    //                     .attr('width', innerWidth);
    //
    //                 // add the axes
    //                 var x = d3.scale.linear()
    //                     .domain(d3.extent(data, function (d) {
    //                         return d[xColumn];
    //                     }))
    //                     .range([0, innerWidth]);
    //
    //                 var y = d3.scale.log()
    //                     .base(Math.E)
    //                     .domain(d3.extent(data, function (d) {
    //                         return d[yColumn];
    //                     }))
    //                     .range([0, innerHeight]);
    //
    //                 //var xAxis = d3.svg.axis(xScale);
    //                 //var yAxis = d3.svg.axis(yScale)
    //                 //.orient('left')
    //                 //.ticks(5)
    //                 //.tickFormat(yTickFormat);
    //
    //
    //                 var xAxis = d3.svg.axis()
    //                     .scale(x)
    //
    //                     .orient("bottom");
    //
    //                 var yAxis = d3.svg.axis()
    //                     .scale(y)
    //                     .orient("left")
    //
    //                     .tickFormat(yTickFormat);
    //                 //function(d) { return "e" + formatPower(Math.round(Math.log(d))); });
    //                 //d3.select(yAxis).style("font-size",30);
    //
    //                 var gX = svg.append('g')
    //                     .attr('class', 'x axis')
    //                     .attr('transform', 'translate(0,' + innerHeight + ')')
    //                     .call(xAxis);
    //
    //                 gX.append('text')
    //                     .attr('class', 'label')
    //                     .attr('transform', 'translate(' + width / 2 + ',' + (margin.bottom - 6) + ')')
    //                     .attr('text-anchor', 'middle')
    //                     .html(xAxisLabel || xColumn);
    //
    //                 var gY = svg.append('g')
    //                     .attr('class', 'y axis')
    //                     .call(yAxis);
    //
    //                 gY.append('text')
    //                     .attr('class', 'label')
    //                     .attr('transform', 'translate(' + (0 - margin.left / 1.25) + ',' + (height / 2) + ') rotate(-90)')
    //                     .style('text-anchor', 'middle')
    //                     .html(yAxisLabel || yColumn);
    //
    //                 // this rect acts as a layer so that zooming works anywhere in the svg. otherwise, if zoom is called on
    //                 // just svg, zoom functionality will only work when the pointer is over a circle.
    //                 var zoomBox = svg.append('rect')
    //                     .attr('class', 'zoom')
    //                     .attr('height', innerHeight)
    //                     .attr('width', innerWidth);
    //
    //                 var circles = svg.append('g')
    //                     .attr('class', 'circlesContainer');
    //
    //                 circles.selectAll(".dot")
    //                     .data(data)
    //                     .enter().append('circle')
    //                     .attr('r', 3)
    //                     .attr('cx', function (d) {
    //                         return xScale(d[xColumn]);
    //                     })
    //                     .attr('cy', function (d) {
    //                         return yScale(d[yColumn]);
    //                     })
    //                     .attr('class', circleClass)
    //                     .on('mouseenter', tipEnter)
    //                     .on("mousemove", tipMove)
    //                     .on('mouseleave', function (d) {
    //                         return tooltip.style('visibility', 'hidden');
    //                     });
    //
    //                 var thresholdLines = svg.append('g')
    //                     .attr('class', 'thresholdLines');
    //
    //                 // add horizontal line at significance threshold
    //                 thresholdLines.append("svg:line")
    //                     .attr('class', 'threshold')
    //                     .attr("x1", 0)
    //                     .attr("x2", innerWidth)
    //                     .attr("y1", yScale(significanceThreshold))
    //                     .attr("y2", yScale(significanceThreshold));
    //
    //                 // add vertical line(s) at fold-change threshold (and negative fold-change)
    //                 [foldChangeThreshold, -1 * foldChangeThreshold].forEach(function (threshold) {
    //                     thresholdLines.append("svg:line")
    //                         .attr('class', 'threshold')
    //                         .attr("x1", xScale(threshold))
    //                         .attr("x2", xScale(threshold))
    //                         .attr("y1", 0)
    //                         .attr("y2", innerHeight);
    //                 });
    //
    //                 var tooltip = d3.select("body")
    //                     .append("div")
    //                     .attr('class', 'tooltip');
    //
    //                 function tipEnter(d) {
    //                     tooltip.style('visibility', 'visible')
    //                         .style('font-size', '11px')
    //                         .html(
    //                             '<strong>' + sampleID + '</strong>: ' + d[sampleID] + '<br/>' +
    //                             '<strong>' + xColumn + '</strong>: ' + d3.format('.2f')(d[xColumn]) + '<br/>' +
    //                             '<strong>' + yColumn + '</strong>: ' + d[yColumn]
    //                         );
    //                 }
    //
    //                 function tipMove() {
    //                     tooltip.style("top", (event.pageY - 5) + "px")
    //                         .style("left", (event.pageX + 20) + "px");
    //                 }
    //
    //                 function yTickFormat(n) {
    //                     return d3.format(".2r")(getBaseLog(10, n));
    //                     function getBaseLog(x, y) {
    //                         return Math.log(y) / Math.log(x);
    //                     }
    //                 }
    //
    //
    //                 //var zoom = d3.behavior.zoom()
    //                 // only scale up, e.g. between 1x and 50x
    //                 //.scaleExtent([1, 50])
    //                 // .on("zoom", function() {
    //                 // the "zoom" event populates d3.event with an object that has
    //                 // a "translate" property (a 2-element Array in the form [x, y])
    //                 // and a numeric "scale" property
    //                 // var e = d3.event,
    //                 // now, constrain the x and y components of the translation by the
    //                 // dimensions of the viewport
    //                 //     tx = Math.min(0, Math.max(e.translate[0], width - width * e.scale)),
    //                 //     ty = Math.min(0, Math.max(e.translate[1], height - height * e.scale));
    //                 // then, update the zoom behavior's internal translation, so that
    //                 // it knows how to properly manipulate it on the next movement
    //                 // zoom.translate([tx, ty]);
    //                 // and finally, update the <g> element's transform attribute with the
    //                 // correct translation and scale (in reverse order)
    //                 //  g.attr("transform", [
    //                 //    "translate(" + [tx, ty] + ")",
    //                 //    "scale(" + e.scale + ")"
    //                 //  ].join(" "));
    //                 //});
    //
    //                 // then, call the zoom behavior on the svg element, which will add
    //                 // all of the necessary mouse and touch event handlers.
    //                 // remember that if you call this on the <g> element, the even handlers
    //                 // will only trigger when the mouse or touch cursor intersects with the
    //                 // <g> elements' children!
    //                 //svg.call(zoom);
    //
    //                 function zoomFunction2() {
    //                     var e = d3.event,
    //                         // now, constrain the x and y components of the translation by the
    //                         // dimensions of the viewport
    //                         tx = Math.min(0, Math.max(e.translate[0], width - width * e.scale)),
    //                         ty = Math.min(0, Math.max(e.translate[1], height - height * e.scale));
    //                     // then, update the zoom behavior's internal translation, so that
    //                     // it knows how to properly manipulate it on the next movement
    //                     zoom.translate([tx, ty]);
    //                     // and finally, update the <g> element's transform attribute with the
    //                     // correct translation and scale (in reverse order)
    //                     this.attr("transform", [
    //                         "translate(" + [tx, ty] + ")",
    //                         "scale(" + e.scale + ")"
    //                     ].join(" "));
    //                 };
    //
    //                 // then, call the zoom behavior on the svg element, which will add
    //                 // all of the necessary mouse and touch event handlers.
    //                 // remember that if you call this on the <g> element, the even handlers
    //                 // will only trigger when the mouse or touch cursor intersects with the
    //                 // <g> elements' children!
    //                 //svg.call(zoom);
    //
    //                 function zoomFunction() {
    //
    //                     var transform = d3.zoomTransform(this);
    //                     //var transform = d3.event.transform;
    //                     d3.selectAll('.dot')
    //                         .attr('transform', transform)
    //                         .attr('r', 3 / Math.sqrt(d3.event.transform.k));
    //                     gX.call(xAxis.scale(d3.event.transform.rescaleX(xScale)));
    //                     gY.call(yAxis.scale(d3.event.transform.rescaleY(yScale)));
    //                     svg.selectAll('.threshold')
    //                         .attr('transform', transform)
    //                         .attr('stroke-width', 1 / transform.k);
    //                 }
    //
    //                 function circleClass(d) {
    //                     //if (d[yColumn] <= significanceThreshold && Math.abs(d[xColumn]) >= foldChangeThreshold) return 'dot sigfold';
    //                     if (d[yColumn] <= significanceThreshold && d[xColumn] > foldChangeThreshold) {
    //
    //                         return 'dot sigfoldPlus';
    //                     }
    //
    //
    //                     else if (d[yColumn] <= significanceThreshold && d[xColumn] < -foldChangeThreshold) {
    //
    //                         return 'dot sigfoldMinus';
    //                     }
    //                     else if (d[yColumn] <= significanceThreshold) return 'dot sig';
    //                     else if (Math.abs(d[xColumn]) >= foldChangeThreshold) return 'dot fold';
    //                     else return 'dot';
    //                 }
    //
    //                 function reset() {
    //                     var ease = d3.easePolyIn.exponent(4.0);
    //                     svg.transition().duration(750)
    //                         .ease(ease)
    //                         .call(zoom.transform, d3.zoomIdentity);
    //                 }
    //             });
    //         }
    //
    //         chart.width = function (value) {
    //             if (!arguments.length) return width;
    //             width = value;
    //             return chart;
    //         };
    //
    //         chart.height = function (value) {
    //             if (!arguments.length) return height;
    //             height = value;
    //             return chart;
    //         };
    //
    //         chart.margin = function (value) {
    //             if (!arguments.length) return margin;
    //             margin = value;
    //             return chart;
    //         };
    //
    //         chart.xColumn = function (value) {
    //             if (!arguments.length) return xColumn;
    //             xColumn = value;
    //             return chart;
    //         };
    //
    //         chart.yColumn = function (value) {
    //             if (!arguments.length) return yColumn;
    //             yColumn = value;
    //             return chart;
    //         };
    //
    //         chart.xAxisLabel = function (value) {
    //             if (!arguments.length) return xAxisLabel;
    //             xAxisLabel = value;
    //             return chart;
    //         };
    //
    //         chart.yAxisLabel = function (value) {
    //             if (!arguments.length) return yAxisLabel;
    //             yAxisLabel = value;
    //             return chart;
    //         };
    //
    //         chart.xAxisLabelOffset = function (value) {
    //             if (!arguments.length) return xAxisLabelOffset;
    //             xAxisLabelOffset = value;
    //             return chart;
    //         };
    //
    //         chart.yAxisLabelOffset = function (value) {
    //             if (!arguments.length) return yAxisLabelOffset;
    //             yAxisLabelOffset = value;
    //             return chart;
    //         };
    //
    //         chart.xTicks = function (value) {
    //             if (!arguments.length) return xTicks;
    //             xTicks = value;
    //             return chart;
    //         };
    //
    //         chart.yTicks = function (value) {
    //             if (!arguments.length) return yTicks;
    //             yTicks = value;
    //             return chart;
    //         };
    //
    //         chart.significanceThreshold = function (value) {
    //             if (!arguments.length) return significanceThreshold;
    //             significanceThreshold = value;
    //             return chart;
    //         };
    //
    //         chart.foldChangeThreshold = function (value) {
    //             if (!arguments.length) return foldChangeThreshold;
    //             foldChangeThreshold = value;
    //             return chart;
    //         };
    //
    //         chart.colorRange = function (value) {
    //             if (!arguments.length) return colorRange;
    //             colorRange = value;
    //             return chart;
    //         };
    //
    //         chart.sampleID = function (value) {
    //             if (!arguments.length) return sampleID;
    //             sampleID = value;
    //             return chart;
    //         };
    //
    //
    //         return chart;
    //     }
    //
    //     // setTimeout(function(){
    //     //     $scope.$broadcast('reCalcViewDimensions');
    //     // },500)
    // }

    refineSelectedList = function (fc, pv) {

        self.showOverAllParallelSVG = false;
        self.selectedArray = [];
        self.selectedPeptides = [];
        if (self.inputArray.length > 0) {
            self.inputArray.forEach(function (obj) {

                if (obj["pv"] <= pv && obj["fc"] > fc) {
                    self.selectedArray.push(obj);
                    self.selectedPeptides.push(obj["Peptide"]);
                }
                if (obj["pv"] <= pv && obj["fc"] < -fc) {
                    self.selectedArray.push(obj);
                    self.selectedPeptides.push(obj["Peptide"]);
                }
            });
        }
        self.selectedArrayTable = new NgTableParams({
            count: 5
        }, {
            total: self.selectedArray.length,  dataset: self.selectedArray,counts: [5, 10, 25]});
        SharedService.setVar("selectedArrayTable", self.selectedArrayTable);
        self.peptideToModificationList = [];
        //self.proteinToAbundance = {};
        self.geneToAbundance = {};
        self.ptmProteinToAbundance = {};
        self.peptideToModificationListOrig.map(function (e) {
            // //console.log(e);
            var parallelPep = e.motif;

            if (self.selectedPeptides.indexOf(parallelPep) > -1) {
                self.peptideToModificationList.push(e);

                e.response.map(function (e2) {
                    ////console.log(e2);

                    var parallelProt = e2.sequence_ac;
                    var parallelPtm = e2.ptmProteinsMixAll[0];
                    var parallelGene = e2.geneArray[0];
                    ////console.log(e2);
                    if (!(parallelPtm in self.ptmProteinToAbundance)){
                        self.ptmProteinToAbundance[parallelPtm] = self.peptideToAbundance[parallelPep] / self.peptideToNumberOfProteins[parallelPep];
                    }
                    else{
                    self.ptmProteinToAbundance[parallelPtm] += self.peptideToAbundance[parallelPep] / self.peptideToNumberOfProteins[parallelPep];

                    }

                    if (!(parallelGene in self.geneToAbundance)){
                        self.geneToAbundance[parallelGene] = self.peptideToAbundance[parallelPep] / self.peptideToNumberOfProteins[parallelPep];
                    }
                    else{
                        self.geneToAbundance[parallelGene] += self.peptideToAbundance[parallelPep] / self.peptideToNumberOfProteins[parallelPep];

                    }

                })
                // e.response.map(function (e2) {
                //     var parallelProt = e2.sequence_ac;
                //     var parallelPtm = e2.ptmProteinsMixAll[0];
                //     var parallelGene = e2.geneArray[0];
                //
                //
                //
                // })
            }


        })
        //console.log(self.list_of_positive_peps);
        //console.log(self.list_of_negative_peps);
        // SharedService.setVar("list_of_positive_negative_peps", self.list_of_positive_negative_peps);
        // SharedService.setVar("list_of_negative_peps", self.list_of_negative_peps);
        // SharedService.setVar("list_of_positive_peps", self.list_of_positive_peps);
        self.proteinIdListMassCombinedWithAbundance = [];
        self.genesWithAbundance = [];
        for (var keyIter in self.ptmProteinToAbundance) {
            if (self.ptmProteinToAbundance.hasOwnProperty(keyIter)) {
                var valueIter = self.ptmProteinToAbundance[keyIter];
                if(!isNaN(valueIter))
                {
                    self.proteinIdListMassCombinedWithAbundance.push(keyIter + " " + valueIter)
                }
                else {
                    self.proteinIdListMassCombinedWithAbundance.push(keyIter)
                }
            }
        }

        for (var keyIter in self.geneToAbundance) {
            if (self.geneToAbundance.hasOwnProperty(keyIter)) {
                var valueIter = self.geneToAbundance[keyIter];
                if(!isNaN(valueIter))
                {
                    self.genesWithAbundance.push(keyIter + " " + valueIter)
                }
                else {
                    self.genesWithAbundance.push(keyIter)
                }
            }
        }


        //SharedService.setVar('peptideToModificationList', self.peptideToModificationList);
        SharedService.setVar("inputMassPtmProteins", self.proteinIdListMassCombinedWithAbundance);
        //SharedService.setVar("inputShorthandPtmProteins", self.geneIdListShorthandCombined);
        SharedService.setVar('genes',self.genesWithAbundance);



    }

    callVolcanoPlot = function (fc, pv) {
        var voldata = self.volcanoJson;

        // if (data.length > 0) {
        //console.log(fc);
        //console.log(pv);
        d3.select("#volcano").html("");

        self.sliderFoldChangeValue = fc;
        self.sliderLogFoldChangeValue = Math.log2(self.sliderFoldChangeValue);
        $scope.sliderFoldChangeValue = self.sliderFoldChangeValue;
        $scope.sliderLogFoldChangeValue = self.sliderLogFoldChangeValue;

        var yLabel = 'log<tspan baseline-shift="sub">10</tspan>P Value',
            xLabel = 'log<tspan baseline-shift="sub">2</tspan>Fold-change';

        var volcanoPlot = volcanoPlot()
            .xAxisLabel(xLabel)
            .yAxisLabel(yLabel)
            .foldChangeThreshold(fc)
            .significanceThreshold(pv)
            .sampleID("Peptide")
            .xColumn("log2(fold_change)")
            .yColumn("p_value");


        // d3.select("#chart6").select("svg").remove();
        // if (typeof svg6 === 'undefined') {
        //     var svg6 = d3.selectAll("#chart6").append("svg");
        // }


        //d3.select("#volcano").select("svg").remove();
        //d3.select("volcano").remove();
        d3.select('#volcano')
            .data([voldata])

            .call(volcanoPlot);
        //});

        // row parser to convert key values into numbers if possible
        function parser(d) {
            for (var key in d) {
                if (d.hasOwnProperty(key)) {
                    d[key] = numberParser(d[key]);
                }
            }
            return d;
        }

            // function to turn string into number if possible
        function numberParser(value) {
            return (+value) ? +value : value;
        }

        function volcanoPlot() {
            // var width = 960,
            //     height = 500,
            //     margin = {top: 20, right: 20, bottom: 40, left: 50},

            var width = 750,
                height = 400,
                margin = {top: 20, right: 20, bottom: 40, left: 60},
                xColumn, // name of the variable to be plotted on the axis
                yColumn,
                xAxisLabel, // label for the axis
                yAxisLabel,
                xAxisLabelOffset, // offset for the label of the axis
                yAxisLabelOffset,
                xTicks, // number of ticks on the axis
                yTicks,
                sampleID = "Peptide",
                significanceThreshold = 0.05, // significance threshold to colour by
                foldChangeThreshold = 1.0, // fold change level to colour by
                colorRange, // colour range to use in the plot
                xScale = d3.scale.linear(), // the values for the axes will be continuous
                yScale = d3.scale.log();


            function chart(selection) {
                var innerWidth = width - margin.left - margin.right, // set the size of the chart within its container
                    innerHeight = height - margin.top - margin.bottom;

                selection.each(function (data) {

                    // set up the scaling for the axes based on the inner width/height of the chart and also the range
                    // of value for the x and y axis variables. This range is defined by their min and max values as
                    // calculated by d3.extent()
                    xScale.range([0, innerWidth])
                        .domain(d3.extent(data, function (d) {
                            return d[xColumn];
                        }));
                    //.nice();

                    // normally would set the y-range to [height, 0] but by swapping it I can flip the axis and thus
                    // have -log10 scale without having to do extra parsing
                    yScale.range([0, innerHeight])
                        .domain(d3.extent(data, function (d) {
                            return d[yColumn];
                        }));
                    //.nice(); // adds "padding" so the domain extent is exactly the min and max values


                    function zoomed() {
                        container.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
                    }

                    var zoom2 = d3.behavior.zoom()
                        .scaleExtent([1, 20])
                        .scaleExtent([[0, 0], [width, height]])
                        .on('zoom', zoomFunction);
                    //.on('zoom', zoomed);


                    // append the svg object to the selection
                    d3.select(this).select('svg').remove();

                    //d3.select("volcano").remove();
                    var svg = d3.select(this).append('svg')
                        .attr('height', height)
                        .attr('width', width)
                        .append('g')
                        .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    //.call(zoom);

                    var zoom = d3.behavior.zoom()
                    // only scale up, e.g. between 1x and 50x
                        .scaleExtent([1, 50])
                        .on("zoom", function () {
                            // the "zoom" event populates d3.event with an object that has
                            // a "translate" property (a 2-element Array in the form [x, y])
                            // and a numeric "scale" property
                            var e = d3.event,
                                // now, constrain the x and y components of the translation by the
                                // dimensions of the viewport
                                tx = Math.min(0, Math.max(e.translate[0], width - width * e.scale)),
                                ty = Math.min(0, Math.max(e.translate[1], height - height * e.scale));
                            // then, update the zoom behavior's internal translation, so that
                            // it knows how to properly manipulate it on the next movement
                            zoom.translate([tx, ty]);
                            // and finally, update the <g> element's transform attribute with the
                            // correct translation and scale (in reverse order)

                            // var transform = d3.zoomTransform(this);
                            // //var transform = d3.event.transform;
                            // d3.selectAll('.dot')
                            //     .attr('transform', transform)


                            d3.selectAll('.dot').attr("transform", [
                                "translate(" + [tx, ty] + ")",
                                "scale(" + e.scale + ")"
                            ].join(" "));
                        });

                    // then, call the zoom behavior on the svg element, which will add
                    // all of the necessary mouse and touch event handlers.
                    // remember that if you call this on the <g> element, the even handlers
                    // will only trigger when the mouse or touch cursor intersects with the
                    // <g> elements' children!
                    svg.call(zoom);

                    // position the reset button and attach reset function
                    d3.select('#resetBtn')
                        .style('top', margin.top * 1.5 + 'px')
                        .style('left', margin.left * 1.25 + 'px')
                        .on('click', reset);

                    svg.append('defs').append('clipPath')
                        .attr('id', 'clip')
                        .append('rect')
                        .attr('height', innerHeight)
                        .attr('width', innerWidth);

                    // add the axes
                    var x = d3.scale.linear()
                        .domain(d3.extent(data, function (d) {
                            return d[xColumn];
                        }))
                        .range([0, innerWidth]);

                    var y = d3.scale.log()
                        .base(Math.E)
                        .domain(d3.extent(data, function (d) {
                            return d[yColumn];
                        }))
                        .range([0, innerHeight]);

                    //var xAxis = d3.svg.axis(xScale);
                    //var yAxis = d3.svg.axis(yScale)
                    //.orient('left')
                    //.ticks(5)
                    //.tickFormat(yTickFormat);


                    var xAxis = d3.svg.axis()
                        .scale(x)

                        .orient("bottom");

                    var yAxis = d3.svg.axis()
                        .scale(y)
                        .orient("left")

                        .tickFormat(yTickFormat);
                    //function(d) { return "e" + formatPower(Math.round(Math.log(d))); });
                    //d3.select(yAxis).style("font-size",30);

                    var gX = svg.append('g')
                        .attr('class', 'x axis')
                        .attr('transform', 'translate(0,' + innerHeight + ')')
                        .call(xAxis);

                    gX.append('text')
                        .attr('class', 'label')
                        .attr('transform', 'translate(' + width / 2 + ',' + (margin.bottom - 6) + ')')
                        .attr('text-anchor', 'middle')
                        .html(xAxisLabel || xColumn);

                    var gY = svg.append('g')
                        .attr('class', 'y axis')
                        .call(yAxis);

                    gY.append('text')
                        .attr('class', 'label')
                        .attr('transform', 'translate(' + (0 - margin.left / 1.25) + ',' + (height / 2) + ') rotate(-90)')
                        .style('text-anchor', 'middle')
                        .html(yAxisLabel || yColumn);

                    // this rect acts as a layer so that zooming works anywhere in the svg. otherwise, if zoom is called on
                    // just svg, zoom functionality will only work when the pointer is over a circle.
                    var zoomBox = svg.append('rect')
                        .attr('class', 'zoom')
                        .attr('height', innerHeight)
                        .attr('width', innerWidth);

                    var circles = svg.append('g')
                        .attr('class', 'circlesContainer');

                    circles.selectAll(".dot")
                        .data(data)
                        .enter().append('circle')
                        .attr('r', 3)
                        .attr('cx', function (d) {
                            return xScale(d[xColumn]);
                        })
                        .attr('cy', function (d) {
                            return yScale(d[yColumn]);
                        })
                        .attr('class', circleClass)
                        .on("mouseenter", tipEnter2)
                        .on("mouseout", function(d) {
                            d3.select("#myText").remove();
                        });
                        // .on('mouseleave', function (d) {
                        //     return text.style('visibility', 'hidden');
                        // });




                        // .on('mouseenter', tipEnter2)
                        // .on("mousemove", tipMove)
                        // .on('mouseleave', function (d) {
                        //     return tooltip.style('visibility', 'hidden');
                        // });

                    var thresholdLines = svg.append('g')
                        .attr('class', 'thresholdLines');

                    // add horizontal line at significance threshold
                    thresholdLines.append("svg:line")
                        .attr('class', 'threshold')
                        .attr("x1", 0)
                        .attr("x2", innerWidth)
                        .attr("y1", yScale(significanceThreshold))
                        .attr("y2", yScale(significanceThreshold));

                    // add vertical line(s) at fold-change threshold (and negative fold-change)
                    [foldChangeThreshold, -1 * foldChangeThreshold].forEach(function (threshold) {
                        thresholdLines.append("svg:line")
                            .attr('class', 'threshold')
                            .attr("x1", xScale(threshold))
                            .attr("x2", xScale(threshold))
                            .attr("y1", 0)
                            .attr("y2", innerHeight);
                    });

                    // var tooltip = d3.select("body")
                    //     .append("div")
                    //     .attr('class', 'tooltip');

                    function tipEnter(d) {
                        tooltip.style('visibility', 'visible')
                            .style('font-size', '11px')
                            .html(
                                '<strong>' + sampleID + '</strong>: ' + d[sampleID] + '<br/>' +
                                '<strong>' + xColumn + '</strong>: ' + d3.format('.2f')(d[xColumn]) + '<br/>' +
                                '<strong>' + yColumn + '</strong>: ' + d[yColumn]
                            );
                    }
                    function tipEnter2(d, i) {  // Add interactivity



                        // Specify where to put label of text
                        svg.append("text")
                            // .attr('cx', function (d) {
                            //     return xScale(d[xColumn]);
                            // })
                            // .attr('cy', function (d) {
                            //     return yScale(d[yColumn]);
                            // })
                            .attr("id", "myText")
                            .attr({
                            //id: "t" + d.x + "-" + d.y + "-" + i,  // Create an id for text so we can select it later for removing on mouseout
                            x: function() { return xScale(d[xColumn]); },
                            y: function() { return yScale(d[yColumn]); }
                            })

                            .text(function() {
                                return d[sampleID];  // Value of the text
                            });
                    }

                    // function tipEnter2(d) {
                    //     tooltip.style('visibility', 'visible')
                    //         .style('font-size', '11px')
                    //         .html(
                    //             '<strong>' + sampleID + '</strong>: ' + d[sampleID] + '<br/>' +
                    //             '<strong>' + xColumn + '</strong>: ' + d3.format('.2f')(d[xColumn]) + '<br/>' +
                    //             '<strong>' + yColumn + '</strong>: ' + d[yColumn]
                    //         );
                    // }

                    function tipMove() {
                        tooltip.style("top", (event.pageY - 5) + "px")
                            .style("left", (event.pageX + 20) + "px");
                    }

                    function yTickFormat(n) {
                        return d3.format(".2r")(getBaseLog(10, n));
                        function getBaseLog(x, y) {
                            return Math.log(y) / Math.log(x);
                        }
                    }


                    //var zoom = d3.behavior.zoom()
                    // only scale up, e.g. between 1x and 50x
                    //.scaleExtent([1, 50])
                    // .on("zoom", function() {
                    // the "zoom" event populates d3.event with an object that has
                    // a "translate" property (a 2-element Array in the form [x, y])
                    // and a numeric "scale" property
                    // var e = d3.event,
                    // now, constrain the x and y components of the translation by the
                    // dimensions of the viewport
                    //     tx = Math.min(0, Math.max(e.translate[0], width - width * e.scale)),
                    //     ty = Math.min(0, Math.max(e.translate[1], height - height * e.scale));
                    // then, update the zoom behavior's internal translation, so that
                    // it knows how to properly manipulate it on the next movement
                    // zoom.translate([tx, ty]);
                    // and finally, update the <g> element's transform attribute with the
                    // correct translation and scale (in reverse order)
                    //  g.attr("transform", [
                    //    "translate(" + [tx, ty] + ")",
                    //    "scale(" + e.scale + ")"
                    //  ].join(" "));
                    //});

                    // then, call the zoom behavior on the svg element, which will add
                    // all of the necessary mouse and touch event handlers.
                    // remember that if you call this on the <g> element, the even handlers
                    // will only trigger when the mouse or touch cursor intersects with the
                    // <g> elements' children!
                    //svg.call(zoom);

                    function zoomFunction2() {
                        var e = d3.event,
                            // now, constrain the x and y components of the translation by the
                            // dimensions of the viewport
                            tx = Math.min(0, Math.max(e.translate[0], width - width * e.scale)),
                            ty = Math.min(0, Math.max(e.translate[1], height - height * e.scale));
                        // then, update the zoom behavior's internal translation, so that
                        // it knows how to properly manipulate it on the next movement
                        zoom.translate([tx, ty]);
                        // and finally, update the <g> element's transform attribute with the
                        // correct translation and scale (in reverse order)
                        this.attr("transform", [
                            "translate(" + [tx, ty] + ")",
                            "scale(" + e.scale + ")"
                        ].join(" "));
                    };

                    // then, call the zoom behavior on the svg element, which will add
                    // all of the necessary mouse and touch event handlers.
                    // remember that if you call this on the <g> element, the even handlers
                    // will only trigger when the mouse or touch cursor intersects with the
                    // <g> elements' children!
                    //svg.call(zoom);

                    function zoomFunction() {

                        var transform = d3.zoomTransform(this);
                        //var transform = d3.event.transform;
                        d3.selectAll('.dot')
                            .attr('transform', transform)
                            .attr('r', 3 / Math.sqrt(d3.event.transform.k));
                        gX.call(xAxis.scale(d3.event.transform.rescaleX(xScale)));
                        gY.call(yAxis.scale(d3.event.transform.rescaleY(yScale)));
                        svg.selectAll('.threshold')
                            .attr('transform', transform)
                            .attr('stroke-width', 1 / transform.k);
                    }

                    function circleClass(d) {
                        //if (d[yColumn] <= significanceThreshold && Math.abs(d[xColumn]) >= foldChangeThreshold) return 'dot sigfold';
                        if (d[yColumn] <= significanceThreshold && d[xColumn] > foldChangeThreshold) {

                            return 'dot sigfoldPlus';
                        }


                        else if (d[yColumn] <= significanceThreshold && d[xColumn] < -foldChangeThreshold) {

                            return 'dot sigfoldMinus';
                        }
                        else if (d[yColumn] <= significanceThreshold) return 'dot sig';
                        else if (Math.abs(d[xColumn]) >= foldChangeThreshold) return 'dot fold';
                        else return 'dot';
                    }

                    function reset() {
                        var ease = d3.easePolyIn.exponent(4.0);
                        svg.transition().duration(750)
                            .ease(ease)
                            .call(zoom.transform, d3.zoomIdentity);
                    }
                });
            }

            chart.width = function (value) {
                if (!arguments.length) return width;
                width = value;
                return chart;
            };

            chart.height = function (value) {
                if (!arguments.length) return height;
                height = value;
                return chart;
            };

            chart.margin = function (value) {
                if (!arguments.length) return margin;
                margin = value;
                return chart;
            };

            chart.xColumn = function (value) {
                if (!arguments.length) return xColumn;
                xColumn = value;
                return chart;
            };

            chart.yColumn = function (value) {
                if (!arguments.length) return yColumn;
                yColumn = value;
                return chart;
            };

            chart.xAxisLabel = function (value) {
                if (!arguments.length) return xAxisLabel;
                xAxisLabel = value;
                return chart;
            };

            chart.yAxisLabel = function (value) {
                if (!arguments.length) return yAxisLabel;
                yAxisLabel = value;
                return chart;
            };

            chart.xAxisLabelOffset = function (value) {
                if (!arguments.length) return xAxisLabelOffset;
                xAxisLabelOffset = value;
                return chart;
            };

            chart.yAxisLabelOffset = function (value) {
                if (!arguments.length) return yAxisLabelOffset;
                yAxisLabelOffset = value;
                return chart;
            };

            chart.xTicks = function (value) {
                if (!arguments.length) return xTicks;
                xTicks = value;
                return chart;
            };

            chart.yTicks = function (value) {
                if (!arguments.length) return yTicks;
                yTicks = value;
                return chart;
            };

            chart.significanceThreshold = function (value) {
                if (!arguments.length) return significanceThreshold;
                significanceThreshold = value;
                return chart;
            };

            chart.foldChangeThreshold = function (value) {
                if (!arguments.length) return foldChangeThreshold;
                foldChangeThreshold = value;
                return chart;
            };

            chart.colorRange = function (value) {
                if (!arguments.length) return colorRange;
                colorRange = value;
                return chart;
            };

            chart.sampleID = function (value) {
                if (!arguments.length) return sampleID;
                sampleID = value;
                return chart;
            };


            return chart;
        }
        // }

        // setTimeout(function(){
        //     $scope.$broadcast('reCalcViewDimensions');
        // },500)
    }
    //callVolcanoPlot(1.5, 0.05);

    //callVolcanoPlot(2.0, 0.001);
    // if (self.showOutputex1orex2 === "ex2Id") {
    //
    //     callVolcanoPlot(self.sliderFoldChangeValue, self.sliderSignificanceValue);
    // }
    //$scope.sliderData = [$scope.sliderFoldChangeValue, $scope.sliderSignificanceValue];
    
    $(document).on('input', '#h_slider', function() {
        $('#h_slider_value').html( $(this).val() );
        ////console.log($(this).val());
        self.sliderFoldChangeValue = $(this).val();
        self.sliderLogFoldChangeValue = Math.log2(self.sliderFoldChangeValue);
        // $scope.sliderFoldChangeValue = self.sliderFoldChangeValue;
        // $scope.sliderLogFoldChangeValue = self.sliderLogFoldChangeValue;
        SharedService.setVar("sliderFoldChangeValue", self.sliderFoldChangeValue);
        //console.log(self.sliderFoldChangeValue);
        $scope.$apply();
        //$scope.sliderData = [$scope.sliderFoldChangeValue, $scope.sliderSignificanceValue];
        refineSelectedList(self.sliderFoldChangeValue, self.sliderSignificanceValue);
        callVolcanoPlot(self.sliderFoldChangeValue, self.sliderSignificanceValue);
    });
    //var timeout3;
    $(document).on('input', '#v_slider', function() {
        $('#v_slider_value').html( -1.0*($(this).val()) );
        self.sliderLogSignificanceValue = -1.0*($(this).val());
        //self.sliderSignificanceValue = Math.log10(self.sliderSignificanceValue);
        self.sliderSignificanceValue = Math.pow(10,self.sliderLogSignificanceValue);
        // $scope.sliderSignificanceValue = self.sliderSignificanceValue;
        // $scope.sliderLogSignificanceValue = self.sliderLogSignificanceValue;
        //$scope.sliderSignificanceValue = $(this).val();
        SharedService.setVar("sliderSignificanceValue", self.sliderSignificanceValue);
        $scope.$apply();
        //console.log(self.sliderSignificanceValue);
        refineSelectedList(self.sliderFoldChangeValue, self.sliderSignificanceValue);
        callVolcanoPlot(self.sliderFoldChangeValue, self.sliderSignificanceValue);

    });

//End of volcano plot ========================================================

    $scope.hslider = {
        minValue: -2,
        maxValue: 2,
        options: {
            floor: -10,
            ceil: 10,
            step: 0.1,
            showTicks: false
        }
    };
    //console.log($scope.hslider.minValue);
    //console.log($scope.hslider.maxValue);
    $scope.sliderFoldChange = {
        value: 0.5,
        options: {
            floor: 0,
            ceil: 2,
            step: 0.1,
            precision: 1
        }
    };
    $scope.sliderPValue = {
        value: 0.5,
        options: {
            floor: 0,
            ceil: 2,
            step: 0.1,
            precision: 1
        }
    };
    $scope.verticalSlider5 = {
        value: 50,
        options: {
            floor: 0,
            ceil: 100,
            vertical: true,
            showSelectionBar: true
        }
    };
    $scope.$watch(function () {
            return self.peptideAbundance
        }, function (newValue, oldValue) {
            //console.log("///////////////Change in peptideAbundance");
            //console.log(self.peptideAbundance);
        }
    );



    $scope.$watch(function () {
        return self.inputMassPtmProteins
    }, function (newValue, oldValue) {



        // if (self.inputMassPtmProteins.length > 0) {
        //     self.parsedInputMassPtmProteins = self.inputMassPtmProteins
        //         .split(self.rowSplitPatternGenes)
        //         .map(function (e) {
        //             if (e.indexOf('[') == -1) {
        //                 return e
        //             }
        //         });
        //     self.parsedGenes.clean(undefined);
        // }

        // .filter(function (el) {
        //         return (el !== null);
        //     });
        // .filter(function (el) {
        //     ////console.log(peptide.indexOf(el.modification));
        //     return (peptide.indexOf(el.modification) > -1);
        // })


        console.log(self.inputMassPtmProteins);
        // //console.log(self.genes);
        if (self.inputMassPtmProteins.length > 0) {
            self.ptmProteinToAbundanceMap = {};

            self.proteinAbundance = self.inputMassPtmProteins
                .split(self.rowSplitPattern)
                .map(function (e) {
                    if (e) {
                        // var str = e.split(/[\s,]+/).join();
                        // //console.log(str);
                        // var str2 = str.replace(/[\s,]+/g, ',');
                        // //console.log(str2);
                        var str2 = e.replace(/,/g, '').replace(/^\s\s*/, '').replace(/\s\s*$/, '').replace(/[\s,]+/g, ',');
                        ////console.log(str2);
                        if (str2.indexOf(',') > -1) {
                            str2 = str2.split(',').slice(1);

                            return str2[0];
                        }
                        else {

                            return "NA";
                        };

                    }


                });

            ////console.log(self.proteinAbundance);


            self.parsedPTMs = self.inputMassPtmProteins
                .split(self.rowSplitPatternGenes)
                .map(function (e) {
                    console.log(e.match(self.modificationPatternForAllPTMs));
                    return e.match(self.modificationPatternForAllPTMs);

                });


            self.parsedPTMProteins = self.inputMassPtmProteins
                .split(self.rowSplitPatternGenes)
                .map(function (e) {

                    var str2 = e.replace(/,/g, '').replace(/^\s\s*/, '').replace(/\s\s*$/, '').replace(/[\s,]+/g, ',');
                    //console.log(str2);
                    if (str2.indexOf(',') > -1) {
                        str2 = str2.split(',').slice(0);
                        console.log(str2[0]);
                        console.log(str2[0].match(self.modificationPatternForAllPTMs),"");
                        console.log(str2[0].replace(str2[0].match(self.modificationPatternForAllPTMs),""));
                        return str2[0].replace(str2[0].match(self.modificationPatternForAllPTMs),"");
                    }
                    else{
                        //console.log(e.replace(e.match(self.modificationPatternForAllPTMs),""));
                        return e.replace(e.match(self.modificationPatternForAllPTMs),"");
                    }

                    // if (e.indexOf('[') > -1) {
                    //     return e
                    // }
                    //return e.toUpperCase().match(self.modificationForptmProteins);;
                });
            console.log(self.parsedPTMProteins);
            self.inputMassPtmProteinsModified = self.inputMassPtmProteins
                .split(self.rowSplitPatternGenes)
                .map(function (e) {

                    var str2 = e.replace(/,/g, '').replace(/^\s\s*/, '').replace(/\s\s*$/, '').replace(/[\s,]+/g, ',');
                    //console.log(str2);
                    if (str2.indexOf(',') > -1) {
                        str2 = str2.split(',').slice(0);
                        //console.log(str2);
                        return str2[0];
                    }
                    else{
                        //console.log(e);
                        return e;
                    }

                    // if (e.indexOf('[') > -1) {
                    //     return e
                    // }
                    //return e.toUpperCase().match(self.modificationForptmProteins);;
                });



            for (var i = 0; i < self.inputMassPtmProteinsModified.length; i++) {
                self.ptmProteinToAbundanceMap[self.inputMassPtmProteinsModified[i]] = self.proteinAbundance[i];
                //Do something
            }
            //console.log("ptmProteinToAbundanceMap");
            //console.log(self.ptmProteinToAbundanceMap);

            self.parsedPTMProteins.clean(undefined);


        }
        if (self.parsedPTMProteins.length == 0) {
            self.showPhosphoGeneNetwork = false;
            SharedService.setVar('showPhosphoGeneNetwork', self.showPhosphoGeneNetwork);
            //console.log("self.showPhosphoGeneNetwork = false;");
        }
        // .filter(function (el) {
        //         return (el !== null);
        //     });
        //Because We need this for api query
        self.inputMassPtmProteinsModifiedForQuery = self.inputMassPtmProteinsModified.toString();
        //console.log(self.inputMassPtmProteinsModifiedForQuery);
        //console.log(self.parsedPTMProteins);
        //console.log(self.inputMassPtmProteinsModified);
        //console.log(self.parsedPTMs);
        //console.log(self.showPhosphoGeneNetwork);
        //console.log(self.showGeneNetwork);
        self.showPtmSubmit = true;
        SharedService.setVar('inputMassPtmProteins',self.inputMassPtmProteins);

    });

    // $scope.$watch(function () {
    //     return self.inputMassPtmProteins
    // }, function (newValue, oldValue) {
    //     if (self.inputMassPtmProteins.length > 0) {
    //         self.ptmProteinToAbundanceMap = {};
    //
    //         self.proteinAbundance = self.inputMassPtmProteins
    //             .split(self.rowSplitPattern)
    //             .map(function (e) {
    //                 if (e) {
    //                     // var str = e.split(/[\s,]+/).join();
    //                     // //console.log(str);
    //                     // var str2 = str.replace(/[\s,]+/g, ',');
    //                     // //console.log(str2);
    //                     var str2 = e.replace(/,/g, '').replace(/^\s\s*/, '').replace(/\s\s*$/, '').replace(/[\s,]+/g, ',');
    //                     ////console.log(str2);
    //                     if (str2.indexOf(',') > -1) {
    //                         str2 = str2.split(',').slice(1);
    //
    //                         return str2[0];
    //                     }
    //                     else {
    //
    //                         return "NA";
    //                     };
    //
    //                 }
    //
    //
    //             });
    //
    //         ////console.log(self.proteinAbundance);
    //
    //
    //         self.parsedPTMs = self.inputMassPtmProteins
    //             .split(self.rowSplitPatternGenes)
    //             .map(function (e) {
    //                 ////console.log(e.match(self.modificationPatternForAllPTMs));
    //                 return e.match(self.modificationPatternForAllPTMs);
    //
    //             });
    //
    //
    //         self.parsedPTMProteins = self.inputMassPtmProteins
    //             .split(self.rowSplitPatternGenes)
    //             .map(function (e) {
    //
    //                 var str2 = e.replace(/,/g, '').replace(/^\s\s*/, '').replace(/\s\s*$/, '').replace(/[\s,]+/g, ',');
    //                 ////console.log(str2);
    //                 if (str2.indexOf(',') > -1) {
    //                     str2 = str2.split(',').slice(0);
    //
    //                     return str2[0].match(self.modificationPatternForAllProteins);
    //                 }
    //                 else{
    //                     return e.match(self.modificationPatternForAllProteins);
    //                 }
    //
    //                 // if (e.indexOf('[') > -1) {
    //                 //     return e
    //                 // }
    //                 //return e.toUpperCase().match(self.modificationForptmProteins);;
    //             });
    //
    //         self.inputMassPtmProteinsModified = self.inputMassPtmProteins
    //             .split(self.rowSplitPatternGenes)
    //             .map(function (e) {
    //
    //                 var str2 = e.replace(/,/g, '').replace(/^\s\s*/, '').replace(/\s\s*$/, '').replace(/[\s,]+/g, ',');
    //                 ////console.log(str2);
    //                 if (str2.indexOf(',') > -1) {
    //                     str2 = str2.split(',').slice(0);
    //
    //                     return str2[0];
    //                 }
    //                 else{
    //                     return e;
    //                 }
    //
    //                 // if (e.indexOf('[') > -1) {
    //                 //     return e
    //                 // }
    //                 //return e.toUpperCase().match(self.modificationForptmProteins);;
    //             });
    //
    //
    //
    //         for (var i = 0; i < self.inputMassPtmProteinsModified.length; i++) {
    //             self.ptmProteinToAbundanceMap[self.inputMassPtmProteinsModified[i]] = self.proteinAbundance[i];
    //             //Do something
    //         }
    //         //console.log("ptmProteinToAbundanceMap");
    //         //console.log(self.ptmProteinToAbundanceMap);
    //
    //         self.parsedPTMProteins.clean(undefined);
    //
    //
    //     }
    //     if (self.parsedPTMProteins.length == 0) {
    //         self.showPhosphoGeneNetwork = false;
    //         SharedService.setVar('showPhosphoGeneNetwork', self.showPhosphoGeneNetwork);
    //         //console.log("self.showPhosphoGeneNetwork = false;");
    //     }
    //     // .filter(function (el) {
    //     //         return (el !== null);
    //     //     });
    //     //Because We need this for api query
    //     self.inputMassPtmProteinsModifiedForQuery = self.inputMassPtmProteinsModified.toString();
    //     //console.log(self.parsedGenes);
    //     //console.log(self.parsedPTMProteins);
    //     //console.log(self.inputMassPtmProteinsModified);
    //     //console.log(self.parsedPTMs);
    //     //console.log(self.showPhosphoGeneNetwork);
    //     //console.log(self.showGeneNetwork);
    //     self.showPtmSubmit = true;
    //     SharedService.setVar('inputMassPtmProteins',self.inputMassPtmProteins);
    //
    // });



    // $scope.$watch(function () {
    //     return self.inputMassPtmProteins
    // }, function (newValue, oldValue) {
    //
    //
    //
    //     // if (self.inputMassPtmProteins.length > 0) {
    //     //     self.parsedInputMassPtmProteins = self.inputMassPtmProteins
    //     //         .split(self.rowSplitPatternGenes)
    //     //         .map(function (e) {
    //     //             if (e.indexOf('[') == -1) {
    //     //                 return e
    //     //             }
    //     //         });
    //     //     self.parsedGenes.clean(undefined);
    //     // }
    //
    //     // .filter(function (el) {
    //     //         return (el !== null);
    //     //     });
    //     // .filter(function (el) {
    //     //     ////console.log(peptide.indexOf(el.modification));
    //     //     return (peptide.indexOf(el.modification) > -1);
    //     // })
    //     //console.log(self.inputMassPtmProteins);
    //     //console.log(self.genes);
    //     if (self.inputMassPtmProteins.length > 0) {
    //
    //         self.parsedPTMs = self.inputMassPtmProteins
    //             .split(self.rowSplitPatternGenes)
    //             .map(function (e) {
    //                 //console.log(e.match(self.modificationPatternForAllPTMs));
    //                 return e.match(self.modificationPatternForAllPTMs);
    //
    //             });
    //
    //
    //         self.parsedPTMProteins = self.inputMassPtmProteins
    //             .split(self.rowSplitPatternGenes)
    //             .map(function (e) {
    //
    //                 return e.match(self.modificationPatternForAllProteins);
    //                 // if (e.indexOf('[') > -1) {
    //                 //     return e
    //                 // }
    //                 //return e.toUpperCase().match(self.modificationForptmProteins);;
    //             });
    //
    //
    //
    //         self.parsedPTMProteins.clean(undefined);
    //     }
    //     if (self.parsedPTMProteins.length == 0) {
    //         self.showPhosphoGeneNetwork = false;
    //         SharedService.setVar('showPhosphoGeneNetwork', self.showPhosphoGeneNetwork);
    //         //console.log("self.showPhosphoGeneNetwork = false;");
    //     }
    //     // .filter(function (el) {
    //     //         return (el !== null);
    //     //     });
    //     //console.log(self.parsedGenes);
    //     //console.log(self.parsedPTMProteins);
    //     //console.log(self.parsedPTMs);
    //     //console.log(self.showPhosphoGeneNetwork);
    //     //console.log(self.showGeneNetwork);
    //     SharedService.setVar('inputMassPtmProteins', self.inputMassPtmProteins);
    //
    // });

    $scope.$watch(function () {
        return self.genes
    }, function (newValue, oldValue) {
        //console.log("in scope gene!---------------------------------------");
        //localStorage.setItem("genes", self.genes);
        //console.log("Setting genes -----");
        self.showGeneSubmit = false;
        // var localselfGenes = localStorage.getItem("genesForProtein2Pathways");
        // //console.log(localselfGenes);
        // $scope.showGeneNetworkProcessed = false;
        // $scope.showKinaseNetworkProcessed = false;
        // self.showGeneNetwork = true;
        //
        // SharedService.setVar('showGeneNetwork', self.showGeneNetwork);
        // SharedService.setVar('showGeneNetworkProcessed', $scope.showGeneNetworkProcessed);
        // SharedService.setVar('showKinaseNetworkProcessed', $scope.showKinaseNetworkProcessed);
        if (self.genes.length > 0) {
            //console.log(self.genes);
            self.geneToAbundanceMap = {};
            self.parsedGenes = self.genes
                .split(self.rowSplitPattern)
                .map(function (e) {
                    if (e) {

                        var str2 = e.replace(/,/g, '').replace(/^\s\s*/, '').replace(/\s\s*$/, '').replace(/[\s,]+/g, ',');
                        ////console.log(str2);
                        if (str2.indexOf(',') > -1) {
                            str2 = str2.split(',').slice(0);

                            return str2[0];
                        }
                        else {
                            return str2;
                        }
                        ;
                    }


                });


            // .split(self.rowSplitPatternGenes)
            // .map(function (e) {
            //     if (e.indexOf('[') == -1) {
            //         return e
            //     }
            // });
            self.parsedGenes.clean(undefined);
            //console.log(self.parsedGenes);
            self.geneAbundance = self.genes
                .split(self.rowSplitPattern)
                .map(function (e) {
                    if (e) {
                        // var str = e.split(/[\s,]+/).join();
                        // //console.log(str);
                        // var str2 = str.replace(/[\s,]+/g, ',');
                        // //console.log(str2);
                        var str2 = e.replace(/,/g, '').replace(/^\s\s*/, '').replace(/\s\s*$/, '').replace(/[\s,]+/g, ',');
                        ////console.log(str2);
                        if (str2.indexOf(',') > -1) {
                            str2 = str2.split(',').slice(1);

                            return str2[0];
                        }
                        else {
                            return "NA";
                        };
                    }


                });

            for (var i = 0; i < self.parsedGenes.length; i++) {
                self.geneToAbundanceMap[self.parsedGenes[i]] = self.geneAbundance[i];
                //Do something
            }
            //console.log("geneToAbundanceMap");
            //console.log(self.geneToAbundanceMap);
            //console.log(self.geneAbundance);
        }

        if (self.parsedGenes.length == 0) {
            self.showGeneNetwork = false;
            SharedService.setVar('showGeneNetwork', self.showGeneNetwork);
            //console.log("self.showGeneNetwork = false;");
        }
        // .filter(function (el) {
        //         return (el !== null);
        //     });
        // .filter(function (el) {
        //     ////console.log(peptide.indexOf(el.modification));
        //     return (peptide.indexOf(el.modification) > -1);
        // })
        // if (self.genes.length > 0) {
        //     self.parsedPTMProteins = self.genes
        //         .split(self.rowSplitPatternGenes)
        //         .map(function (e) {
        //             if (e.indexOf('[') > -1) {
        //                 return e
        //             }
        //             //return e.toUpperCase().match(self.modificationForptmProteins);;
        //         });
        //     self.parsedPTMProteins.clean(undefined);
        // }
        // if (self.parsedPTMProteins.length == 0) {
        //     self.showPhosphoGeneNetwork = false;
        //     //console.log("self.showPhosphoGeneNetwork = false;");
        // }
        // .filter(function (el) {
        //         return (el !== null);
        //     });
        //console.log(self.parsedGenes);
        // //console.log(self.parsedPTMProteins);
        // //console.log(self.showPhosphoGeneNetwork);
        //console.log(self.showGeneNetwork);
        SharedService.setVar('genes', self.genes);
    });
    var timeout;
    $scope.$watch(function () {
        return self.parsedGenes
    }, function (nV, oV) {
        //self.showOutputPathway = false;
        self.flagFoundNPCG = false;
        self.waitingPathway = true;
        //self.showOutputPathway = false;
        //console.log("self.showOutputPathway");
        //console.log(self.showOutputPathway);
        //console.log(self.parsedGenes);

        // This is for slicing the input genes because it makes problems if we have long list of genes in the http.get

        if (timeout) {
            $timeout.cancel(timeout);
        };
        $timeout(function () {
            self.genePlaces = [];
            self.inputGeneInfo = [];
            self.nonValidGenes = [];
            // self.network = {};
            // self.kinaseNetwork = {};
            self.numberOfAllInputGenes = 0;
            self.numberOfAllValidGenes = 0;
            //console.log("self.parsedGenes.length");
            //console.log(self.parsedGenes.length);
            var genePartitioned = function splitarray(input, spacing) {
                var output = [];

                for (var i = 0; i < input.length; i += spacing) {
                    output[output.length] = input.slice(i, i + spacing);
                }

                return output;
            }(self.parsedGenes, self.parsedGenes.length)

            //console.log(genePartitioned);
            //console.log(genePartitioned.length);
            // var flag = true;
            // while (flag){
            //     var queryGeneList = [];
            //     self.parsedGenes
            //
            // }
            if (genePartitioned.length > 0) {
                for (var i = 0; i < genePartitioned.length; i++) {
                    $http.get("api/pcg/checkgenes/" + genePartitioned[i])
                        .success(function (genePositions) {
                            //console.log("genePositions");
                            //console.log(genePositions);
                            self.genePlaces = genePositions;
                            for (var geneIter = 0; geneIter < self.genePlaces.length; geneIter++) {
                                self.numberOfAllInputGenes = self.numberOfAllInputGenes + 1;
                                if (self.genePlaces[geneIter] != -1) {
                                    self.numberOfAllValidGenes = self.numberOfAllValidGenes + 1;
                                }
                                else {
                                    self.flagFoundNPCG = true;
                                    self.nonValidGenes.push(self.parsedGenes[geneIter]);
                                    //console.log("self.nonValidGenes");
                                    //console.log(self.nonValidGenes);
                                }
                            }
                            // self.genePlaces.forEach(function (e) {
                            //     self.numberOfAllInputGenes = self.numberOfAllInputGenes + 1;
                            //     if (e != -1) {
                            //         self.numberOfAllValidGenes = self.numberOfAllValidGenes + 1;
                            //     }
                            //     else
                            //     {
                            //         self.nonValidGenes.push(self.parsedGenes[])
                            //     }
                            //     ;
                            // });

                            $http.get("api/pcg/geneinfo/" + self.genePlaces)
                                .success(function (geneInfos) {
                                    //console.log(geneInfos);
                                    for (var geneInfoIter = 0; geneInfoIter < geneInfos.length; geneInfoIter++) {
                                        self.inputGeneInfo.push(geneInfos[geneInfoIter]);
                                    }
                                    //console.log(self.inputGeneInfo);
                                })
                                .error(function () {
                                    //console.log("Error in obtaining gene info from api/pcg/geneinfo/");
                                });
                        })
                        .error(function () {
                            //console.log("Error in obtaining gene place from api/pcg/checkgenes/");
                        });
                }
            }

        }, 1100);

    });

    // document.getElementById('files').onchange = function() {
    //     this.form.submit();
    // };

    // $(document).ready(function() {
    //     $("#upload-file-input").on("change", uploadFilePost);
    // });

    /**
     * Upload the file sending it via Ajax at the Spring Boot server.
     */
    // $scope.uploadFileAngular = function() {
    //     //console.log("uploadFileAngular");
    //     var fd = new FormData();
    //     var file = $scope.file;
    //     fd.append('file', file);
    //     $http.post("api/uploadFile",fd,
    //         {
    //             headers : {
    //                 'Content-Type' : undefined
    //             }
    //         }).success(function(data) {
    //         debugger;
    //     }).error(function(data) {
    //         debugger;
    //     })
    // }

    $scope.uploadFileAndOnSubmit = function(){
        self.progressText = "Getting the Peptide to Protein Mapping";
        self.showOutputex1orex2 = "ex2Id";
        SharedService.setVar("showOutputex1orex2",self.showOutputex1orex2);
        //console.log("uploadFile");
        var file = $scope.myFile;
        var fd = new FormData();
        self.uploadWaiting = true;
        self.showOutput = false;
        fd.append('file', file);
        //We can send anything in name parameter,
//it is hard coded to abc as it is irrelavant in this case.
        var uploadUrl = "api/upload?organism=" + self.organismForm + self.proteinForm;
        $http.get("api/increment/" + 1)
            .success(function (siteVisit) {

                self.siteVisit = siteVisit;

            })
            .error(function (data, status) {

                self.siteVisit = {"all": "", "peptide": "", "gene": "", "ptm": ""}

            });
        //console.log(uploadUrl);
        $http.post(uploadUrl, fd, {
            transformRequest: angular.identity,
            headers: {'Content-Type': undefined}
        })
            .success(function(response){
                self.progressText = "Peptides are Mapped to Proteins, Searching for Connected Proteins.";
                //console.log(uploadUrl);
                //console.log("successs");
                //console.log(response);
                self.uploadedFalg = true;
                self.uploadWaiting = false;

                self.parsedMotifs = response["localMotifs"];
                self.parsedPeptides = response["localPeptides"];
                self.uploadErrorTag = response["tag"];
                self.uploadErrorText = response["message"];
                self.inputArray = response["inputArray"];
                self.dataForAllPeptides = response["dataForAllPeptides"];
                self.volcanoJson = response["volcanoArray"];
                self.peptideAbundance = [];
                self.parsedModificationsFromUpload = [];

                SharedService.setVar("uploadErrorTag",self.uploadErrorTag);
                SharedService.setVar("uploadErrorText",self.uploadErrorText);
                SharedService.setVar("inputArray",self.inputArray);
                SharedService.setVar("dataForAllPeptides",self.dataForAllPeptides);
                SharedService.setVar("volcanoJson",self.volcanoJson);


                self.inputArray.forEach(function (e) {
                    if (e["fc"] != null) {
                        self.peptideAbundance.push(e["fc"]);
                    }
                    else{
                        self.peptideAbundance.push("NA");
                    }
                    self.parsedModificationsFromUpload.push(e["modification"]);
                });


                //This is to maje sure we have updated ModOntology
                self.ontologyMappings = [];
                self.ontologyMappingsUnique = [];
                distinct = [];
                //firstPrositeResponseFiltered = [];
                // self.plnFormatOne = [];
                // self.plnFormatTwo = [];
                //self.plnFirstHit = [];
                var elMass;
                var elShorthand;
                var originalMAss;


                self.parsedModificationsFromUpload.forEach(function (e) {
                    if (e != null) {
                        e.forEach(function (el) {
                            (function (el) {
                                //if (self.formatInput) {
                                // //console.log('el');
                                // //console.log(el);

                                if(el.toUpperCase().contains('MOD')) {
                                    $http.get("api/proteinptm/" + el.substr(1, el.length))
                                        .success(function (data) {


                                            // if (el.toUpperCase().contains('UNIMOD')) {
                                            //     var originalMAss = data.averageDeltaMass;
                                            //     $http.get("api/proteinptmbymass/" + originalMAss+"/delta/0.01")
                                            //         .success(function (data) {
                                            //             ////console.log(data);
                                            //
                                            //             var sorted_data = data.sort(function(a, b){
                                            //                 return Math.abs(a.averageDeltaMass-originalMAss) - Math.abs(b.averageDeltaMass-originalMAss);
                                            //             });
                                            //             ////console.log(sorted_data);
                                            //             var closest_sorted = sorted_data[0];
                                            //             ////console.log(closest_sorted);
                                            //             var result = {};
                                            //             result.mass = originalMAss;
                                            //             result.input = el;
                                            //             result.identifier = closest_sorted.accession;
                                            //             result.diffavg = closest_sorted.averageDeltaMass;
                                            //
                                            //             result.description = closest_sorted.description;
                                            //             result.formula = closest_sorted.formula;
                                            //             var similarToPTM = [];
                                            //             sorted_data.forEach(function(element) {
                                            //                 var similarToPTMAll = "{"+ element.accession+"},{"+element.averageDeltaMass +"},{"+ element.formula+"},{"+element.description +"}";
                                            //                 ////console.log(element);
                                            //                 var similarToPTMItem = {};
                                            //                 // similarToPTMItem["identifier"] = element.accession;
                                            //                 similarToPTMItem["descriptionAll"] = similarToPTMAll;
                                            //
                                            //                 similarToPTM.push(similarToPTMItem);
                                            //             });
                                            //             // for (var i = 0; i < sorted_data.length; i++) {
                                            //             //     similarToPTMItem = "{"+ sorted_data.[i].accession+","+sorted_data[i].averageDeltaMass +","+ sorted_data[i].formula+","+sorted_data[i].description +"}";
                                            //             //
                                            //             //     similarToPTM.push(similarToPTMItem);
                                            //             //     //Do something
                                            //             // }
                                            //
                                            //             result.similar = similarToPTM;
                                            //             ////console.log(result);
                                            //
                                            //             if (self.ontologyMappingsUnique.indexOf(el) === -1) {
                                            //                 self.ontologyMappingsUnique.push(el);
                                            //                 self.ontologyMappings.push(result);
                                            //                 ////console.log(result);
                                            //
                                            //             }
                                            //
                                            //             //self.ontologyMappings.push(result);
                                            //
                                            //         })
                                            //         .error(function (data, status) {
                                            //             // //console.log(data);
                                            //             // //console.log(status);
                                            //             var result = {};
                                            //             result.identifier = "";
                                            //             result.mass = "";
                                            //             result.input = el;
                                            //             result.formula = "";
                                            //             result.diffavg = "";
                                            //             result.description = "Error!";
                                            //             result.similar = [];
                                            //
                                            //
                                            //
                                            //
                                            //
                                            //
                                            //             // var result = {};
                                            //             // result.identifier = "";
                                            //             //
                                            //             // result.modification = elMass;
                                            //             // if (self.modificationMapReverse[elMass.match(self.patt3)]) {
                                            //             //     elShorthand = "[" + self.modificationMapReverse[elMass.match(self.patt3)] + elMass.match(self.patt1) + "]";
                                            //             // }
                                            //             // else {
                                            //             //     elShorthand = ""
                                            //             // }
                                            //             // result.shorthand = elShorthand;
                                            //             // result.diffavg = "";
                                            //             // result.description = "Error!";
                                            //             // result.similar = "";
                                            //             //self.ontologyMappings.push(result);
                                            //             if (self.ontologyMappingsUnique.indexOf(el) === -1) {
                                            //                 self.ontologyMappingsUnique.push(el);
                                            //                 self.ontologyMappings.push(result);
                                            //             }
                                            //
                                            //         });
                                            //
                                            // }
                                            // else {
                                                var result = {};
                                                result.input = el;
                                                if (data.length === 0) {
                                                    result.identifier = "";
                                                    // result.original = data.string;
                                                    // result.modification = elMass;
                                                    // result.shorthand = shorthandInput;
                                                    result.diffavg = "";
                                                    result.mass = "";
                                                    result.similar = [];
                                                    result.formula = "";
                                                    result.description = "";

                                                }

                                                result.identifier = data.accession;
                                                result.diffavg = data.averageDeltaMass;
                                                result.mass = data.averageDeltaMass;
                                                result.description = data.description;
                                                result.formula = data.formula;


                                                var similarToPTM = [];

                                                var similarToPTMAll = "{" + data.accession + "},{" + data.averageDeltaMass + "},{" + data.formula + "},{" + data.description + "}";
                                                ////console.log(element);
                                                var similarToPTMItem = {};
                                                // similarToPTMItem["identifier"] = element.accession;
                                                similarToPTMItem["descriptionAll"] = similarToPTMAll;

                                                similarToPTM.push(similarToPTMItem);

                                                // for (var i = 0; i < sorted_data.length; i++) {
                                                //     similarToPTMItem = "{"+ sorted_data.[i].accession+","+sorted_data[i].averageDeltaMass +","+ sorted_data[i].formula+","+sorted_data[i].description +"}";
                                                //
                                                //     similarToPTM.push(similarToPTMItem);
                                                //     //Do something
                                                // }

                                                result.similar = similarToPTM;


                                                if (self.ontologyMappingsUnique.indexOf(el) === -1) {
                                                    self.ontologyMappingsUnique.push(el);
                                                    self.ontologyMappings.push(result);
                                                }

                                                //self.ontologyMappings.push(result);
                                            // }

                                        })
                                        .error(function (data, status) {
                                            // //console.log(data);
                                            // //console.log(status);
                                            var result = {};
                                            result.identifier = "";
                                            result.input = el;
                                            result.mass = "";
                                            result.formula = "";
                                            result.diffavg = "";
                                            result.description = "Error!";
                                            result.similar = [];
                                            //self.ontologyMappings.push(result);
                                            if (self.ontologyMappingsUnique.indexOf(el) === -1) {
                                                self.ontologyMappingsUnique.push(el);
                                                self.ontologyMappings.push(result);
                                            }

                                        });



                                }
                                else {
                                    if (!el.contains('+')) {

                                        elMass = el.match(self.patt1) + "[+" + self.modificationMap[el.match(self.patt2)] + "]";
                                        // //console.log(el.match(self.patt2));
                                        // //console.log(self.modificationMap[el.match(self.patt2)]);
                                        originalMAss = self.modificationMap[el.match(self.patt2)];
                                        var shorthandInput = el;
                                        var originalModFromInput = el;
                                        var modificationType = "";
                                        var modificationAmino = "";
                                        modificationType = self.modificationNameMap[el.match(self.patt2)];
                                        modificationAmino = self.modificationAminoMap[el.match(self.patt1)];
                                        console.log("---------");
                                        console.log("unimod or psimod");
                                        console.log(el.match(self.patt2));
                                        console.log(modificationType);
                                        console.log(el.match(self.patt1));
                                        console.log(modificationAmino);

                                        console.log(shorthandInput);
                                        console.log(originalModFromInput);
                                        console.log(originalMAss);
                                        console.log(elMass);
                                        (function (modificationType, modificationAmino, originalModFromInput) {
                                            $http.get("api/proteinptmbydescription/" + modificationType)
                                                .success(function (res_data) {
                                                    console.log("api/proteinptmbydescription/" + modificationType);
                                                    console.log("res_data");
                                                    console.log(res_data);
                                                    var data = [];
                                                    for(var i = 0; i < res_data.length; i++) {
                                                        var obj = res_data[i];
                                                        if (obj["description"].includes(modificationAmino) ||
                                                            obj["name"].includes(modificationAmino) ||
                                                            obj["shortName"].includes(modificationAmino)
                                                        ){
                                                            data.push(obj);
                                                        }

                                                    }
                                                    console.log("data:");
                                                    console.log(data);
                                                    //var data = res_data;

                                                    var sorted_data = data.sort(function (a, b) {
                                                        return Math.abs(b.averageDeltaMass - originalMAss) - Math.abs(a.averageDeltaMass - originalMAss);
                                                    });
                                                    ////console.log(sorted_data);
                                                    var closest_sorted = sorted_data[0];
                                                    ////console.log(closest_sorted);
                                                    var result = {};
                                                    result.mass = originalMAss;
                                                    result.input = el;
                                                    result.identifier = closest_sorted.accession;
                                                    result.diffavg = closest_sorted.averageDeltaMass;

                                                    result.description = closest_sorted.description;
                                                    result.formula = closest_sorted.formula;
                                                    var similarToPTM = [];
                                                    sorted_data.forEach(function (element) {
                                                        var similarToPTMAll = "{" + element.accession + "},{" + element.averageDeltaMass + "},{" + element.formula + "},{" + element.description + "}";
                                                        ////console.log(element);
                                                        var similarToPTMItem = {};
                                                        // similarToPTMItem["identifier"] = element.accession;
                                                        similarToPTMItem["descriptionAll"] = similarToPTMAll;

                                                        similarToPTM.push(similarToPTMItem);
                                                    });
                                                    // for (var i = 0; i < sorted_data.length; i++) {
                                                    //     similarToPTMItem = "{"+ sorted_data.[i].accession+","+sorted_data[i].averageDeltaMass +","+ sorted_data[i].formula+","+sorted_data[i].description +"}";
                                                    //
                                                    //     similarToPTM.push(similarToPTMItem);
                                                    //     //Do something
                                                    // }

                                                    result.similar = similarToPTM;
                                                    ////console.log(result);

                                                    if (self.ontologyMappingsUnique.indexOf(el) === -1) {
                                                        self.ontologyMappingsUnique.push(el);
                                                        self.ontologyMappings.push(result);
                                                        //console.log(result);

                                                    }

                                                    //self.ontologyMappings.push(result);

                                                })
                                                .error(function (data, status) {
                                                    // //console.log(data);
                                                    // //console.log(status);
                                                    var result = {};
                                                    result.identifier = "";
                                                    result.input = el;
                                                    result.formula = "";
                                                    result.diffavg = "";
                                                    result.description = "Error!";
                                                    result.similar = [];


                                                    // var result = {};
                                                    // result.identifier = "";
                                                    //
                                                    // result.modification = elMass;
                                                    // if (self.modificationMapReverse[elMass.match(self.patt3)]) {
                                                    //     elShorthand = "[" + self.modificationMapReverse[elMass.match(self.patt3)] + elMass.match(self.patt1) + "]";
                                                    // }
                                                    // else {
                                                    //     elShorthand = ""
                                                    // }
                                                    // result.shorthand = elShorthand;
                                                    // result.diffavg = "";
                                                    // result.description = "Error!";
                                                    // result.similar = "";
                                                    //self.ontologyMappings.push(result);
                                                    if (self.ontologyMappingsUnique.indexOf(el) === -1) {
                                                        self.ontologyMappingsUnique.push(el);
                                                        self.ontologyMappings.push(result);
                                                    }

                                                });
                                        }(modificationType, modificationAmino, originalModFromInput));
                                    } else {

                                        elMass = el;
                                        var originalModFromInput = el;

                                        var shorthandInput = '';
                                        var originalMAss = el.replace(/[a-zA-Z+\[\]']/g, '');
                                        console.log("---------");
                                        console.log("+++++++");
                                        console.log(shorthandInput);
                                        console.log(originalModFromInput);
                                        console.log(originalMAss);
                                        console.log(elMass);
                                        console.log(originalMAss);
                                        (function (originalMAss, shorthandInput, originalModFromInput) {
                                            $http.get("api/proteinptmbymass/" + originalMAss + "/delta/0.001")
                                                .success(function (data) {
                                                    console.log("api/proteinptmbymass/"+ originalMAss + "/delta/0.001");
                                                    console.log("data:");
                                                    console.log(data);

                                                    var sorted_data = data.sort(function (a, b) {
                                                        return Math.abs(b.averageDeltaMass - originalMAss) - Math.abs(a.averageDeltaMass - originalMAss);
                                                    });
                                                    ////console.log(sorted_data);
                                                    var closest_sorted = sorted_data[0];
                                                    console.log(closest_sorted);
                                                    var result = {};
                                                    result.mass = originalMAss;
                                                    result.input = el;
                                                    result.identifier = closest_sorted.accession;
                                                    result.diffavg = closest_sorted.averageDeltaMass;

                                                    result.description = closest_sorted.description;
                                                    result.formula = closest_sorted.formula;
                                                    var similarToPTM = [];
                                                    sorted_data.forEach(function (element) {
                                                        var similarToPTMAll = "{" + element.accession + "},{" + element.averageDeltaMass + "},{" + element.formula + "},{" + element.description + "}";
                                                        ////console.log(element);
                                                        var similarToPTMItem = {};
                                                        // similarToPTMItem["identifier"] = element.accession;
                                                        similarToPTMItem["descriptionAll"] = similarToPTMAll;

                                                        similarToPTM.push(similarToPTMItem);
                                                    });
                                                    // for (var i = 0; i < sorted_data.length; i++) {
                                                    //     similarToPTMItem = "{"+ sorted_data.[i].accession+","+sorted_data[i].averageDeltaMass +","+ sorted_data[i].formula+","+sorted_data[i].description +"}";
                                                    //
                                                    //     similarToPTM.push(similarToPTMItem);
                                                    //     //Do something
                                                    // }

                                                    result.similar = similarToPTM;
                                                    ////console.log(result);

                                                    if (self.ontologyMappingsUnique.indexOf(el) === -1) {
                                                        self.ontologyMappingsUnique.push(el);
                                                        self.ontologyMappings.push(result);
                                                        // //console.log(result);

                                                    }

                                                    //self.ontologyMappings.push(result);

                                                })
                                                .error(function (data, status) {
                                                    // //console.log(data);
                                                    // //console.log(status);
                                                    var result = {};
                                                    result.identifier = "";
                                                    result.input = el;
                                                    result.formula = "";
                                                    result.diffavg = "";
                                                    result.description = "Error!";
                                                    result.similar = [];


                                                    // var result = {};
                                                    // result.identifier = "";
                                                    //
                                                    // result.modification = elMass;
                                                    // if (self.modificationMapReverse[elMass.match(self.patt3)]) {
                                                    //     elShorthand = "[" + self.modificationMapReverse[elMass.match(self.patt3)] + elMass.match(self.patt1) + "]";
                                                    // }
                                                    // else {
                                                    //     elShorthand = ""
                                                    // }
                                                    // result.shorthand = elShorthand;
                                                    // result.diffavg = "";
                                                    // result.description = "Error!";
                                                    // result.similar = "";
                                                    //self.ontologyMappings.push(result);
                                                    if (self.ontologyMappingsUnique.indexOf(el) === -1) {
                                                        self.ontologyMappingsUnique.push(el);
                                                        self.ontologyMappings.push(result);
                                                    }

                                                });
                                        }(originalMAss, shorthandInput, originalModFromInput));

                                    }
                                }
                            }(el));
                        })
                    }
                    //console.log(self.ontologyMappings);
                });

                //updateModOntology(self.parsedModificationsFromUpload);
                //End of update ModOntology

                self.inputArrayTable = new NgTableParams({
                    count: 5
                }, {
                    total: self.inputArray.length,  dataset: self.inputArray,counts: [5, 10, 25]});
                SharedService.setVar("inputArrayTable", self.inputArrayTable);



                // This is start of onsubmit
                self.progressPercent = 0;
                d3.selectAll("svg > *").remove();
                self.showPLN = false;
                self.showOverAllParallelSVG = false;
                // //console.log("test logging");
                // //console.log("psi-mod");
                // //console.log(self.ontologyMappings);
                self.showPhosphoGeneNetwork = false;
                SharedService.setVar('showPhosphoGeneNetwork', self.showPhosphoGeneNetwork);
                self.showOutputPathway = false;
                SharedService.setVar('showOutputPathway', self.showOutputPathway);
                self.showInstruction = false;
                self.waiting = true;
                self.showOutput = false;
                self.showUpload = false;
                self.sequence_acList = [];
                self.geneIdList = [];
                self.geneIdListPhosphorylation = [];
                self.geneIdListShorthandCombined = [];
                self.geneIdListMassCombined = [];
                self.geneIdListAcetylations = [];
                self.geneIdListMethylation = [];
                self.sequence_acListComplete = [];
                self.numResponsesFromProsite = 0;
                self.numResponsesFromUniprot = 0;
                self.responseRaw = [];
                self.responseRawLocal = [];
                self.prResponseList = [];
                self.prResponseJson = {};
                self.uniprotJsonObjectAll = {};
                self.uniprotResponseRaw = [];
                self.uniprotResponseRawJson = [];
                var prositeHttpResponse = [];
                self.uniprotQueryList = [];
                self.motifLength = self.parsedMotifs.length;
                self.uniprotFound = " ";
                self.uniprotFoundNum = 0;
                self.prositeFound = " ";
                self.prositeFoundNum = 0;
                self.uniprotLength = 0;
                self.showOverAllParallelSVG = false;


                self.subCellularTableData = [];
                self.subCellularValues = [];
                self.subCellularLabels = [];

                self.reactomeTableData = [];
                self.reactomeValues = [];
                self.reactomeLabels = [];

                self.goTableData = [];
                self.goLabels = [];
                self.goValues = [];

                self.go_dic = {};
                self.reactome_dic = {};
                self.subcellular_location_dic = {};
                //Capturing response from the prosite api
                var urlProsite = 'api/prosite2/';
                var urlPir = 'api/pir/';
                var urlPeptide = 'api/peptide/organism/';
                var urlUniprot = 'api/uniprot/organism/';
                var useProsite = false;
                //console.log(" in onsubmit --------------------------------------------------------");
                //console.log(self.parsedMotifs);
                //console.log(self.parsedPeptides);
                d3.select("svg").remove();

                //d3.selectAll("svg > *").remove();



                var prositeResponseIterator = 0;
                self.uniprotResponseIteratorTotal = 0;
                self.uniprotResponseIterator = 0;

                if(self.uploadErrorTag === 400)
                {
                    self.uploadedFalg = false;

                    self.uploadWaiting = false;
                }
                //The file upload was ok!
                    else {
                    //Not using prosite for the peptide search
                    (function (localMotifs, localPeptides) {
                        //console.log("localMotifs");
                        //console.log(localMotifs);
                        //console.log("localPeptides");
                        //console.log(localPeptides);
                        //console.log("organismForm");
                        //console.log(self.organismForm);
                        //console.log("proteinForm");
                        //console.log(self.proteinForm);
                        self.showOutput = true;
                        // $http({
                        //     method: 'GET',
                        //     url: urlPeptide + self.organismForm + self.proteinForm + "/peptides/" + localMotifs,
                        //     //withCredentials : true,
                        //     //headers: URLobj.headers,
                        //     timeout: 1000 * 60 * 2
                        // }).success(

                        // refineSelectedList(self.sliderFoldChangeValue, self.sliderSignificanceValue);
                        // callVolcanoPlot(self.sliderFoldChangeValue, self.sliderSignificanceValue);



                        (function (dataForAll) {


                            //var str = "{ hello: 'world', places: ['Africa', 'America', 'Asia', 'Australia'] }"
                            //data = JSON.stringify(eval('(' + dataStr.toString() + ')'));
                            //var data = JSON.stringify(eval("(" + data2 + ")"));


                            //console.log("dataForAll!");
                            //console.log(dataForAll);
                            //Assume that 20 percent is done!
                            self.showOutput = true;
                            self.progressPercent = 20;

                            //console.log(dataForAll);
                            //console.log(self.proteinDb);
                            self.uniprotResponseIteratorTotalForPercentage = 0;
                            self.uniprotResponseIteratorTotal = 0;

                            //Handling the Trembl and Swissprot

                            if (self.proteinDb === 'sp') {
                                var dataForAllModified = {};
                                for (var key in dataForAll) {
                                    // if(key === "ALQLLHCFPLDIR"){
                                    //
                                    // }
                                    if (dataForAll.hasOwnProperty(key)) {
                                        ////console.log(key + " -> " + dataForAll[key]);
                                        var n_matchModified = 0;
                                        var matchsetModified = [];
                                        dataForAll[key].matchset.map(function (e2) {
                                            if (e2.sequence_db == 'sp') {
                                                matchsetModified.push(e2);
                                                n_matchModified = n_matchModified + 1;
                                            }
                                        })

                                        var valueModified = {};
                                        valueModified['n_match'] = n_matchModified;
                                        valueModified['matchset'] = matchsetModified;
                                        dataForAllModified[key] = valueModified;
                                    }
                                }
                                dataForAll = dataForAllModified;
                            }

                            if (self.proteinDb == 'tr') {
                                var dataForAllModified = {};
                                for (var key in dataForAll) {
                                    if (dataForAll.hasOwnProperty(key)) {
                                        ////console.log(key + " -> " + dataForAll[key]);
                                        var n_matchModified = 0;
                                        var matchsetModified = [];
                                        dataForAll[key].matchset.map(function (e2) {
                                            if (e2.sequence_db == 'tr') {
                                                matchsetModified.push(e2);
                                                n_matchModified = n_matchModified + 1;
                                            }
                                        })

                                        var valueModified = {};
                                        valueModified['n_match'] = n_matchModified;
                                        valueModified['matchset'] = matchsetModified;
                                        dataForAllModified[key] = valueModified;
                                    }
                                }
                                dataForAll = dataForAllModified;
                            }
                            //console.log("dataForAllModified");
                            //console.log(dataForAllModified);
                            // self.uniprotResponseIterator = 0;
                            for (var localPeptideIterator = 0; localPeptideIterator < localMotifs.length; localPeptideIterator++) {

                                var localMotif = localMotifs[localPeptideIterator];
                                // //console.log(localPeptideIterator);
                                // //console.log(localMotif);
                                // //console.log(dataForAll[localMotif]);
                                self.uniprotResponseIteratorTotalForPercentage += dataForAll[localMotif].n_match;
                                //self.uniprotResponseIteratorTotal += dataForAll[localMotif].n_match;
                            }
                            //console.log("self.uniprotResponseIteratorTotalForPercentage");
                            //console.log(self.uniprotResponseIteratorTotalForPercentage);
                            for (localPeptideIterator = 0; localPeptideIterator < localMotifs.length; localPeptideIterator++) {

                                self.responseRawLocal = [];
                                var localMotif = self.parsedMotifs[localPeptideIterator];
                                var localPeptide = self.parsedPeptides[localPeptideIterator];
                                ////console.log(localMotif);
                                var data = dataForAll[localMotif];
                                ////console.log(data);

                                var matchset = data.matchset;
                                ////console.log(matchset);

                                var nMatch = data.n_match;
                                self.uniprotResponseIteratorTotal += nMatch;
                                if (nMatch >= 0) {
                                    self.prositeFoundNum = self.prositeFoundNum + 1;
                                    self.prositeFound = localPeptide;
                                    // self.progressPercent = 1.0 * self.prositeFoundNum / self.motifLength * 95.0;
                                    // self.getPercentage = function () {
                                    //     //console.log(self.prositeFoundNum);
                                    //     //console.log(self.motifLength);
                                    //     return (Math.round(self.prositeFoundNum / self.motifLength * 95.0));
                                }
                                //
                                //     //document.getElementById("progress").style.width = self.progressPercent + "px";
                                //     self.prositeFound = localPeptide;
                                //
                                // }

                                matchset.map(function (e) {
                                    e.motif = localMotif;
                                    e.peptide = localPeptide;
                                    return e;
                                });
                                self.numResponsesFromProsite++;
                                var flagFound = 1;
                                if (nMatch === 0) {
                                    flagFound = 0;

                                    self.responseRawLocal = self.responseRawLocal.concat([
                                        {
                                            "motif": localMotif,
                                            "peptide": localPeptide,
                                            "sequence_ac": "",
                                            "sequence_id": "",
                                            "sequence_db": "Not found in canonical uniprot data base!",
                                            "start": "",
                                            "stop": "",
                                            "signature_ac": ""
                                        }]);
                                }
                                else {
                                    self.responseRawLocal = self.responseRawLocal.concat(matchset);
                                }

                                self.responseRaw = self.responseRaw.concat(self.responseRawLocal);

                                self.prResponseJson = {
                                    "motif": localMotif,
                                    "peptide": localPeptide,
                                    "length": self.responseRawLocal.length,
                                    "response": self.responseRawLocal
                                }
                                self.prResponseList = self.prResponseList.concat(self.prResponseJson);

                                prositeResponseIterator = 0;
                                if (flagFound === 0) {


                                    if (self.numResponsesFromProsite >= self.parsedMotifs.length && self.uniprotResponseIterator >= self.uniprotResponseIteratorTotal) {

                                        self.showOutput = true;
                                        self.waiting = false;
                                        //console.log("Before updating pln! ");

                                        //console.log("--------------");
                                        //console.log("uniprotResponseIterator");
                                        //console.log(self.uniprotResponseIterator);
                                        //console.log("uniprotResponseIteratorTotal");
                                        //console.log(self.uniprotResponseIteratorTotal);

                                        //console.log("numResponsesFromProsite");
                                        //console.log(self.numResponsesFromProsite);
                                        //console.log("parsedMotifs.length");
                                        //console.log(self.parsedMotifs.length);

                                        self.updatePln(self.peptideNormalizeFlag, self.parsedMotifs, self.textArea, self.responseRaw, self.proteinMap, self.parsedMotifs, self.parsedPeptides, self.peptideAbundance, self.sequence_acListComplete);

                                    }
                                }
                                // var nMatchIterator = 0;
                                if (flagFound === 1) {

                                    while (prositeResponseIterator < self.responseRawLocal.length) {


                                        var uniprotQuery = self.responseRawLocal[prositeResponseIterator].sequence_ac;

                                        if (!self.uniprotJsonObjectAll.hasOwnProperty(uniprotQuery)) {
                                            self.uniprotJsonObjectAll[uniprotQuery] = [];
                                            self.uniprotLength = self.uniprotLength + 1;
                                        }
                                        var startMotif = self.responseRawLocal[prositeResponseIterator].start;
                                        var stopMotif = self.responseRawLocal[prositeResponseIterator].stop;
                                        var motifMotif = self.responseRawLocal[prositeResponseIterator].motif;
                                        var motifPeptide = self.responseRawLocal[prositeResponseIterator].peptide;


                                        // if (self.sequence_acList.indexOf(uniprotQuery) === -1) {
                                        //     self.sequence_acList.push(uniprotQuery);
                                        //     ////console.log("sequence_acList: " + self.sequence_acList);
                                        //     var sequence_acListMember = {
                                        //         "id": self.sequence_acList.length,
                                        //         "name": uniprotQuery,
                                        //         "length": 1,
                                        //         "members": emptyList
                                        //     };
                                        //     self.sequence_acListComplete = self.sequence_acListComplete.concat(sequence_acListMember);

                                        //     protPlace = self.sequence_acList.length - 1;
                                        //     self.uniprotLength = self.sequence_acList.length;
                                        //     //console.log("sequence_acListComplete");
                                        //     //console.log(self.sequence_acListComplete);
                                        // }
                                        // else {
                                        //     for (var prot = 0; prot < self.sequence_acListComplete.length; prot++) {
                                        //         if (uniprotQuery === self.sequence_acListComplete[prot].name) {
                                        //             protPlace = prot;
                                        //             ////console.log("Adding a member to" + uniprotQuery);
                                        //             self.sequence_acListComplete[prot].length = self.sequence_acListComplete[prot].length + 1;
                                        //             prot = self.sequence_acListComplete.length;
                                        //         }
                                        //     }
                                        // }

                                        // //console.log("self.sequence_acListComplete");
                                        // //console.log(self.sequence_acListComplete);

                                        var uniprotQueryMember = {
                                            "uniprotQuery": uniprotQuery,
                                            "startMotif": startMotif,
                                            "stopMotif": stopMotif,
                                            "motifMotif": motifMotif,
                                            "motifPeptide": motifPeptide
                                            //"protPlace" : protPlace
                                        };


                                        self.uniprotJsonObjectAll[uniprotQuery].push(uniprotQueryMember);


                                        //self.uniprotQueryList.push(uniprotQueryMember);
                                        //nMatchIterator++;
                                        prositeResponseIterator++;


                                    }


                                }


                                // //console.log("self.uniprotJsonObjectAll");
                                // //console.log(self.uniprotJsonObjectAll);

                            }//End of loop over peptides


                            (function (uniprotJsonObjectAll) {

                                var protPlaceVariable = 0;
                                self.uniprotResponseIterator = 0;
                                // //console.log("*************************");
                                // //console.log("*************************");
                                // //console.log("*************************");
                                // //console.log("uniprotJsonObjectAll");
                                // //console.log(uniprotJsonObjectAll);
                                // //console.log("self.uniprotResponseIteratorTotal");
                                // //console.log(self.uniprotResponseIteratorTotal);


                                for (var key in uniprotJsonObjectAll) {
                                    if (uniprotJsonObjectAll.hasOwnProperty(key)) {

                                        // //console.log(key + " -> " + uniprotJsonObjectAll[key]);
                                        var emptyList = [];
                                        var valueOfUniprotJsonObjecItem = uniprotJsonObjectAll[key];
                                        uniprotQuery = key;

                                        var sequence_acListMember = {

                                            "name": uniprotQuery,
                                            "length": valueOfUniprotJsonObjecItem.length,
                                            "members": emptyList
                                        };
                                        self.sequence_acListComplete = self.sequence_acListComplete.concat(sequence_acListMember);


                                        (function (uniprotIdForInsideQuery, valueOfUniprotJsonObjecItemForInsideQuery, protPlaceVar) {

                                            // $http.get(urlUniprot + self.organismForm + "/uniprot/" + uniprotIdForInsideQuery)
                                            $http.get("api/uniprotdb/organism/" + self.organismForm + "/accession/" + uniprotIdForInsideQuery)

                                                .success(function (data) {

                                                    var uniprotJsonObject = data;
                                                    // console.log(self.organismForm);
                                                    // console.log(uniprotIdForInsideQuery);
                                                    // console.log(uniprotJsonObject);
                                                    if ("reactome" in uniprotJsonObject) {
                                                        var uniprotReactome = uniprotJsonObject["reactome"];
                                                        for (var i = 0; i < uniprotReactome.length; i++) {
                                                            var reactId = uniprotReactome[i]["id"];
                                                            var reactValue = uniprotReactome[i]["value"];
                                                            if (!(reactId in self.reactome_dic)) {
                                                                self.reactome_dic[reactId] = {
                                                                    "value": reactValue,
                                                                    "num": 1,
                                                                    proteins: [uniprotIdForInsideQuery]
                                                                };
                                                            }
                                                            else {
                                                                self.reactome_dic[reactId]["num"] += 1;
                                                                if (self.reactome_dic[reactId]["proteins"].indexOf(uniprotIdForInsideQuery) === -1) {
                                                                    self.reactome_dic[reactId]["proteins"].push(uniprotIdForInsideQuery);
                                                                }
                                                            }

                                                            ////console.log(obj.id);
                                                        }
                                                    }

                                                    if ("go" in uniprotJsonObject) {
                                                        var uniprotGo = uniprotJsonObject["go"];
                                                        for (var i = 0; i < uniprotGo.length; i++) {
                                                            var goId = uniprotGo[i]["id"];
                                                            var goValue = uniprotGo[i]["value"];
                                                            if (!(goId in self.go_dic)) {
                                                                self.go_dic[goId] = {
                                                                    "value": goValue,
                                                                    "num": 1,
                                                                    proteins: [uniprotIdForInsideQuery]
                                                                };
                                                            }
                                                            else {
                                                                self.go_dic[goId]["num"] += 1;
                                                                if (self.go_dic[goId]["proteins"].indexOf(uniprotIdForInsideQuery) === -1) {
                                                                    self.go_dic[goId]["proteins"].push(uniprotIdForInsideQuery);
                                                                }
                                                            }

                                                            ////console.log(obj.id);
                                                        }
                                                    }

                                                    if ("subcellular_location" in uniprotJsonObject) {
                                                        var uniprotSubCellular = uniprotJsonObject["subcellular_location"];
                                                        for (var i = 0; i < uniprotSubCellular.length; i++) {
                                                            var subCellularId = uniprotSubCellular[i];

                                                            if (!(subCellularId in self.subcellular_location_dic)) {
                                                                self.subcellular_location_dic[subCellularId] = {
                                                                    "num": 1,
                                                                    proteins: [uniprotIdForInsideQuery]
                                                                };
                                                            }
                                                            else {
                                                                self.subcellular_location_dic[subCellularId]["num"] += 1;
                                                                if (self.subcellular_location_dic[subCellularId]["proteins"].indexOf(uniprotIdForInsideQuery) === -1) {
                                                                    self.subcellular_location_dic[subCellularId]["proteins"].push(uniprotIdForInsideQuery);
                                                                }
                                                            }

                                                            ////console.log(obj.id);
                                                        }
                                                    }
                                                    //
                                                    // var uniprotGo = uniprotJsonObject["go"];
                                                    // var uniprotSubcellular_location = uniprotJsonObject["subcellular_location"];
                                                    //
                                                    // var uniprotReactomeParsed = uniprotJsonObject["reactome"];
                                                    // var uniprotGoParsed = uniprotJsonObject["go"];
                                                    // var uniprotSubcellular_locationParsed = uniprotJsonObject["subcellular_location"];
                                                    // self.go_dic = {};
                                                    // self.reactome_dic = {};
                                                    // self.subcellular_location_dic = {};


                                                    // self.goTableData =[{"id":"gc1","value":"cc1","percent":14},
                                                    //     {"id":"gc2","value":"cc2","percent":14},
                                                    //     {"id":"gc4","value":"cc4","percent":14},
                                                    //     {"id":"gc5","value":"cc5","percent":14},
                                                    //     {"id":"gc6","value":"cc6","percent":14},
                                                    //     {"id":"gc3","value":"cc3","percent":14}];
                                                    // self.goLabels = ['gEuropean Union', 'gRussian Federation', 'gBrazil', 'gIndia', 'gRest of World' ];
                                                    // self.goValues = [43, 6, 5, 4.333, 41.666];
                                                    // uniprotJsonObject["go"]
                                                    // uniprotJsonObject["reactome"]
                                                    // uniprotJsonObject["subcellular_location"]
                                                    self.uniprotJsonObjectAll[uniprotIdForInsideQuery] = uniprotJsonObject;

                                                    self.uniprotFound = uniprotIdForInsideQuery;
                                                    if (self.uniprotFoundNum < self.uniprotLength) {
                                                        self.uniprotFoundNum = self.uniprotFoundNum + 1;
                                                    }
                                                    ;
                                                    self.showOutput = true;
                                                    // //console.log(uniprotIdForInsideQuery);
                                                    // //console.log(data);


                                                    // //console.log("Uniprot Response");
                                                    // //console.log(uniprotJsonObject);
                                                    //Defining uniprot to gene map

                                                    var valueOfGeneId = uniprotJsonObject.primary_gene_name;
                                                    // //console.log(valueOfGeneId);
                                                    // //console.log(uniprotJsonObject.primary_gene_name);
                                                    // //console.log(uniprotJsonObject["primary_gene_name"]);
                                                    // //console.log("-------------");
                                                    //Some times TREMBL proteins don't match any genes!!!!!

                                                    // if (valueOfGeneId.length == 0) {
                                                    //     valueOfGeneId = ['NA'];
                                                    // }

                                                    if (valueOfGeneId){
                                                        if (valueOfGeneId.length == 0) {
                                                            valueOfGeneId = ['NA'];
                                                        }
                                                    }
                                                    else{
                                                        valueOfGeneId = ['NA'];
                                                    }
                                                    // //console.log("valueOfGeneId");
                                                    // //console.log(valueOfGeneId);
                                                    self.proteinMap[uniprotIdForInsideQuery] = valueOfGeneId;


                                                    //var geneId = uniprotJsonObject.primary_gene_name;
                                                    for (var geneIdIter = 0; geneIdIter < valueOfGeneId.length; geneIdIter++) {
                                                        if (self.geneIdList.indexOf(valueOfGeneId[geneIdIter]) === -1 && valueOfGeneId[geneIdIter] != 'NA') {
                                                            self.geneIdList.push(valueOfGeneId[geneIdIter]);
                                                            self.genes = self.geneIdList;
                                                            // //console.log("self.genes ");
                                                            // //console.log(self.genes );
                                                        }

                                                    }


                                                    // self.uniprotResponseIterator += 1;
                                                    // //console.log(self.uniprotResponseIterator);
                                                    // //console.log(self.uniprotResponseIteratorTotalForPercentage);
                                                    for (var valueIter = 0; valueIter < valueOfUniprotJsonObjecItemForInsideQuery.length; valueIter++) {
                                                        var uniprotJsonObjectTmp = {};
                                                        var valueItem = valueOfUniprotJsonObjecItemForInsideQuery[valueIter];
                                                        // //console.log("uniprotIdForInsideQuery");
                                                        // //console.log(uniprotIdForInsideQuery);
                                                        // //console.log("valueItem");
                                                        // //console.log(valueItem);

                                                        var uniprotQueryItem = valueItem.uniprotQuery;
                                                        var startMotifItem = valueItem.startMotif;
                                                        var stopMotifItem = valueItem.stopMotif;
                                                        var motifMotifItem = valueItem.motifMotif;
                                                        var motifPeptideItem = valueItem.motifPeptide;


                                                        //Each uniprot query adds one portion from 20 percent to 99 percent
                                                        self.progressPercent += 79 / self.uniprotResponseIteratorTotalForPercentage;
                                                        // //console.log(self.progressPercent);


                                                        // //console.log(self.responseRaw[prositeResponseIterator].stop);
                                                        uniprotJsonObjectTmp["start"] = startMotifItem;
                                                        uniprotJsonObjectTmp["stop"] = stopMotifItem;
                                                        uniprotJsonObjectTmp["motif"] = motifMotifItem;
                                                        uniprotJsonObjectTmp["peptide"] = motifPeptideItem;
                                                        uniprotJsonObjectTmp["sequence_ac"] = uniprotQueryItem;
                                                        uniprotJsonObjectTmp["length"] = uniprotJsonObject.length;
                                                        uniprotJsonObjectTmp["sequence"] = uniprotJsonObject.sequence;
                                                        uniprotJsonObjectTmp["primary_gene_name"] = uniprotJsonObject.primary_gene_name;

                                                        //returnVar.concat(uniprotJsonObject);
                                                        // //console.log("uniprotJsonObject");
                                                        // //console.log(uniprotJsonObject);

                                                        // data.matchset.map(function (e) {
                                                        //     e.motif = localMotif;
                                                        //     return e;
                                                        // });
                                                        //+++++++++++++++++++++++++++++++++++++++++++++++++++
                                                        //var matchset = data.matchset;
                                                        //self.uniprotResponseRaw = self.uniprotResponseRaw.concat(uniprotJsonObject.toString());
                                                        // //console.log("self.sequence_acListCompleteBefore");
                                                        // //console.log(self.sequence_acListComplete);
                                                        // //console.log(protPlaceVar);
                                                        ////console.log(self.sequence_acListComplete[protPlaceVar].members);
                                                        //self.uniprotJsonObjectAll[uniprotQuery].push(uniprotQueryMember);

                                                        self.sequence_acListComplete[protPlaceVar].members = self.sequence_acListComplete[protPlaceVar].members.concat(uniprotJsonObjectTmp);

                                                        //self.sequence_acListComplete[protPlaceVar].members.push(uniprotJsonObject);
                                                        // //console.log("self.sequence_acListComplete[protPlaceVar].members");
                                                        // //console.log(self.sequence_acListComplete[protPlaceVar].members);
                                                        // //console.log("---------------------------------");
                                                        // //console.log("protPlace: " + protPlace);
                                                        ////console.log("sequence_acListComplete.name: " + self.sequence_acListComplete[protPlace].name);
                                                        // //console.log("sequence_acListComplete2.length: " + self.sequence_acListComplete[protPlace].length);
                                                        // //console.log("sequence_acListComplete3.members: " + self.sequence_acListComplete[protPlace].members);
                                                        // for(var foo = 0; foo < self.sequence_acListComplete[protPlace].members.length; foo++)
                                                        // {
                                                        //     //console.log("foo   "+ foo);
                                                        //     //console.log(self.sequence_acListComplete[protPlace].members[foo].sequence_ac);
                                                        //     //console.log(self.sequence_acListComplete[protPlace].members[foo].motif);
                                                        //
                                                        // }

                                                        //self.uniprotResponseRaw = self.uniprotResponseRaw.concat(uniprotJsonObject);


                                                        //self.uniprotResponseRaw = self.uniprotResponseRaw.concat(JSON.stringify(data));

                                                        ////console.log("ResponseRaw: " + self.responseRaw);

                                                        // //console.log("--------------");
                                                        // //console.log("uniprotResponseIterator");
                                                        // //console.log(self.uniprotResponseIterator);
                                                        // //console.log("uniprotResponseIteratorTotal");
                                                        // //console.log(self.uniprotResponseIteratorTotal);
                                                        //
                                                        // //console.log("numResponsesFromProsite");
                                                        // //console.log(self.numResponsesFromProsite);
                                                        // //console.log("parsedMotifs.length");
                                                        // //console.log(self.parsedMotifs.length);


                                                        // //console.log(self.uniprotResponseIterator);
                                                        // //console.log(self.responseRawLocal.length);
                                                        // //console.log(self.numResponsesFromProsite);
                                                        // //console.log(self.parsedMotifs.length);
                                                        self.uniprotResponseIterator++;
                                                        // //console.log("self.uniprotResponseIterator");
                                                        // //console.log(self.uniprotResponseIterator);
                                                        // //console.log(self.sequence_acListComplete);
                                                        // //console.log("++++++++++++++++++++++++++++");
                                                        if (self.numResponsesFromProsite >= self.parsedMotifs.length && self.uniprotResponseIterator >= self.uniprotResponseIteratorTotal) {

                                                            self.showOutput = true;
                                                            self.waiting = false;
                                                            //console.log("Before updating pln! ");

                                                            //console.log("--------------");
                                                            //console.log("uniprotResponseIterator");
                                                            //console.log(self.uniprotResponseIterator);
                                                            //console.log("uniprotResponseIteratorTotal");
                                                            //console.log(self.uniprotResponseIteratorTotal);

                                                            //console.log("numResponsesFromProsite");
                                                            //console.log(self.numResponsesFromProsite);
                                                            //console.log("parsedMotifs.length");
                                                            //console.log(self.parsedMotifs.length);
                                                            //console.log("self.sequence_acListComplete");
                                                            //console.log(self.sequence_acListComplete);
                                                            self.updatePln(self.peptideNormalizeFlag, self.parsedMotifs, self.textArea, self.responseRaw, self.proteinMap, self.parsedMotifs, self.parsedPeptides, self.peptideAbundance, self.sequence_acListComplete);

                                                        }
                                                    }

                                                    //prositeResponseIterator++;
                                                })
                                                .error(function (data, status) {
                                                    //self.noResponse = true;
                                                    // //console.log(data);
                                                    // //console.log(status);
                                                    //console.log("uniprot error");
                                                    //Each uniprot query adds one portion from 20 percent to 99 percent
                                                    self.uniprotResponseIterator += 1;
                                                    //console.log(self.uniprotResponseIterator);
                                                    //console.log(self.uniprotResponseIteratorTotalForPercentage);
                                                    self.progressPercent += 79 / self.uniprotResponseIteratorTotalForPercentage;


                                                    // //console.log(self.uniprotResponseIterator);
                                                    // //console.log(self.responseRawLocal.length);
                                                    //
                                                    //
                                                    // //console.log(self.uniprotResponseIterator);
                                                    // //console.log(self.responseRawLocal.length);
                                                    // //console.log(self.numResponsesFromProsite);
                                                    // //console.log(self.parsedMotifs.length);
                                                    //protPlaceVar = protPlaceVar + 1;
                                                    if (self.numResponsesFromProsite >= self.parsedMotifs.length && self.uniprotResponseIterator >= self.uniprotResponseIteratorTotal) {

                                                        self.showOutput = true;
                                                        //console.log("Before updating pln! ");

                                                        //console.log("--------------");
                                                        //console.log("uniprotResponseIterator");
                                                        //console.log(self.uniprotResponseIterator);
                                                        //console.log("uniprotResponseIteratorTotal");
                                                        //console.log(self.uniprotResponseIteratorTotal);

                                                        //console.log("numResponsesFromProsite");
                                                        //console.log(self.numResponsesFromProsite);
                                                        //console.log("parsedMotifs.length");
                                                        //console.log(self.parsedMotifs.length);
                                                        self.showOutput = true;
                                                        self.waiting = false;
                                                        //console.log("Before updating pln! number of numResponsesFromProsite");
                                                        //console.log(self.numResponsesFromProsite);

                                                        self.updatePln(self.peptideNormalizeFlag, self.parsedMotifs, self.textArea, self.responseRaw, self.proteinMap, self.parsedMotifs, self.parsedPeptides, self.peptideAbundance, self.sequence_acListComplete);

                                                    }

                                                    //prositeResponseIterator++;
                                                });
                                        })(uniprotQuery, valueOfUniprotJsonObjecItem, protPlaceVariable)
                                        protPlaceVariable = protPlaceVariable + 1;
                                    }

                                }//End of loop for keys

                            })(self.uniprotJsonObjectAll);


                            // //console.log("prositeResponseIterator");
                            // //console.log(prositeResponseIterator);

                            //++++++++++++++++++++++++++++++++++++++
                        })(self.dataForAllPeptides)

                        //Error in api/peptide
                        //     .error(function (data, status) {
                        //         self.noResponse = true;
                        //         self.prositeFoundNum = self.prositeFoundNum + 1;
                        //         self.prositeFound = localMotif;
                        //         self.showOutput = true;
                        //         //console.log("api/peptide error");
                        //         //console.log(localMotif);
                        //         //console.log(data);
                        //         //console.log(status);
                        //         self.responseRawLocal = [];
                        //         //self.prResponseList = [];
                        //         self.responseRaw = [];
                        //         self.responseRawLocal = self.responseRawLocal.concat({
                        //             "motif": localMotif,
                        //             "peptide": localPeptide,
                        //             "sequence_ac": "",
                        //             "sequence_id": "",
                        //             "sequence_db": " Prosite Response Error! ",
                        //             "start": "",
                        //             "stop": "",
                        //             "signature_ac": ""
                        //         });
                        //
                        //         self.responseRaw = self.responseRaw.concat(self.responseRawLocal);
                        //
                        //         self.prResponseJson = {
                        //             "motif": localMotif,
                        //             "peptide": localPeptide,
                        //             "length": self.responseRawLocal.length,
                        //             "response": self.responseRaw
                        //         };
                        //         self.prResponseList = self.prResponseList.concat(self.prResponseJson);
                        //         //for ()
                        //         //self.prResponseList
                        //         // //console.log("Response Local");
                        //         // //console.log(self.responseRawLocal);
                        //         //
                        //         // //console.log("Response Raw");
                        //         // //console.log(self.responseRaw);
                        //         //
                        //         // //console.log("total response");
                        //         // //console.log(self.prResponseJson);
                        //
                        //
                        //         // //console.log("--------------");
                        //         // //console.log("uniprotResponseIterator");
                        //         // //console.log(self.uniprotResponseIterator);
                        //         // //console.log("uniprotResponseIteratorTotal");
                        //         // //console.log(self.uniprotResponseIteratorTotal);
                        //         // //console.log("here1, before checking for updating pln");
                        //         // //console.log("numResponsesFromProsite");
                        //         // //console.log(self.numResponsesFromProsite);
                        //         // //console.log("parsedMotifs.length");
                        //         // //console.log(self.parsedMotifs.length);
                        //         // //console.log("here2, before checking for updating pln");
                        //         //
                        //         // //console.log(self.numResponsesFromProsite >= self.parsedMotifs.length);
                        //         // //console.log(self.uniprotResponseIterator >= self.responseRawLocal.length);
                        //         // //console.log(self.uniprotResponseIterator );
                        //         // //console.log(self.responseRawLocal.length);
                        //         // //console.log(self.responseRawLocal);
                        //         ////console.log("here3, before checking for updating pln");
                        //
                        //         //console.log(self.uniprotResponseIterator);
                        //         //console.log(self.uniprotResponseIteratorTotal);
                        //         if (self.numResponsesFromProsite >= self.parsedMotifs.length && self.uniprotResponseIterator >= self.uniprotResponseIteratorTotal) {
                        //
                        //             self.showOutput = true;
                        //             //console.log("Before updating pln! ");
                        //
                        //             //console.log("--------------");
                        //             //console.log("uniprotResponseIterator");
                        //             //console.log(self.uniprotResponseIterator);
                        //             //console.log("uniprotResponseIteratorTotal");
                        //             //console.log(self.uniprotResponseIteratorTotal);
                        //
                        //             //console.log("numResponsesFromProsite");
                        //             //console.log(self.numResponsesFromProsite);
                        //             //console.log("parsedMotifs.length");
                        //             //console.log(self.parsedMotifs.length);
                        //             self.showOutput = true;
                        //             self.waiting = false;
                        //             //console.log("Before updating pln in the error section! ");
                        //             //console.log("Before updating pln! number of numResponsesFromProsite");
                        //             //console.log(self.numResponsesFromProsite);
                        //
                        //             self.updatePln(self.peptideNormalizeFlag, self.parsedMotifs, self.textArea, self.responseRaw, self.proteinMap, self.parsedMotifs, self.parsedPeptides, self.peptideAbundance, self.sequence_acListComplete);
                        //
                        //         }
                        //
                        //
                        //     })

                    })(self.parsedMotifs, self.parsedPeptides);

                }
            })
            .error(function(response){
                //console.log("error");
                //console.log(response);
                self.uploadedFalg = false;
                self.uploadWaiting = false;
            });
    }

    // function uploadFilePost() {
    //     //console.log("in uploadFilePost");
    //     $.ajax({
    //         url: "api/uploadFile",
    //         type: "POST",
    //         data: new FormData($("#upload-file-form")[0]),
    //         enctype: 'multipart/form-data',
    //         processData: false,
    //         contentType: false,
    //         cache: false,
    //         success: function () {
    //             // Handle upload success
    //             $("#upload-file-message").text("File successfully uploaded");
    //         },
    //         error: function () {
    //             $("#message").ajaxError(function(event, request, settings){
    //                 $(this).show();
    //                 $(this).append("<li>Error requesting page " + settings.url + "</li>");
    //             });
    //             // Handle upload error
    //             $("#upload-file-message").text(
    //                 "File not uploaded (please follow the example and check the format of .xlsx file)");
    //         }
    //     });
    // } // function uploadFile



    // var file = $("#uploadMedia").find("#fileMedia")[0].files[0];
    // if (typeof file !== "undefined") {
    //     uploadFile(file);
    // }
    //
    // var uploadFile = function(file, callback) {
    //     // Create a new FormData object
    //     var formData = new FormData();
    //     formData.append('file', file);
    //
    //     $.ajax({
    //         url: WEBSERVICE_URL + "uploadFile",
    //         beforeSend: function(xhr) {
    //             if (WEBSERVICE_USER !== "") {
    //                 xhr.setRequestHeader("Authorization", "Basic " + btoa(WEBSERVICE_USER + ":" + WEBSERVICE_PASS));
    //             }
    //         },
    //         data: formData,
    //         method: "POST",
    //         processData: false, // tell jQuery not to process the data
    //         contentType: false, // tell jQuery not to set contentType
    //         success: function(data, textStatus, jqXHR) {
    //             alert(data);
    //         },
    //         error: function(jqXHR, textStatus, errorThrown) {
    //             alert("ERROR");
    //         },
    //         complete: function(jqXHR, textStatus) {
    //             if (typeof callback === "function") {
    //                 callback();
    //             }
    //         }
    //     });
    // };




    $scope.submitForUpload = function () {
        var file = document.getElementById('files');
        // file.onchange = function() {
        //     this.form.submit();
        // }
        function csvJSON(csv){

            var lines=csv.split("\n");

            var result = [];

            var headers=lines[0].toString().replace(/"/g,"").split(",");
//console.log(headers);
            for(var i=1;i<lines.length;i++){

                var obj = {};
                var currentline=lines[i].replace(/"/g,"").split(",");

                for(var j=0;j<headers.length;j++){
                    ////console.log(headers[j]);
                    obj[headers[j]] = currentline[j];
                }

                result.push(obj);

            }

            //return result; //JavaScript object
            return JSON.parse(JSON.stringify(result));
            //return JSON.stringify(result); //JSON
        }



        if(file.files.length)
        {
            var reader = new FileReader();

            reader.onload = function(e)
            {
                //document.getElementById('outputDiv').innerHTML = e.target.result;
                // //console.log(e.target.result);
                //console.log(e.target.result);
                var csvJSONVarFromUpload = csvJSON(e.target.result);
                //var csvJSONVarFromUpload = JSON.parse(csvJSONVar);
                //var csvJSONVarFromUpload = JSON.stringify(csvJSONVar);


                //console.log(csvJSONVarFromUpload);

                self.textArea = '';
                for(var i in csvJSONVarFromUpload)
                {
                    ////console.log(csvJSONVarFromUpload[i]);
                    // //console.log(csvJSONVarFromUpload[i]['peptide']);
                    if (csvJSONVarFromUpload[i]['peptide'] != "")
                    {
                        for (var key in csvJSONVarFromUpload[i]) {
                            if (csvJSONVarFromUpload[i].hasOwnProperty(key)) {

                                self.textArea += csvJSONVarFromUpload[i][key] + "  "

                            }
                        }

                            self.textArea += "\n";

                    }
                }
                //delete the last \n
                self.textArea = self.textArea.substring(0, self.textArea.length - 2);


                //console.log(self.textArea);
                $scope.$apply();

            };

            reader.readAsBinaryString(file.files[0]);
        }
        //console.log(reader);

    }
    $scope.uploadFormFile = function(files) {
        // var fd = new FormData();
        // //Take the first selected file
        // fd.append("file", files[0]);
        // var file = files;
        function csvJSON(csv){

            var lines=csv.split("\n");

            var result = [];

            var headers=lines[0].toString().replace(/"/g,"").split(",");
            //console.log(headers);
            for(var i=1;i<lines.length;i++){

                var obj = {};
                var currentline=lines[i].replace(/"/g,"").split(",");

                for(var j=0;j<headers.length;j++){
                    ////console.log(headers[j]);
                    obj[headers[j]] = currentline[j];
                }

                result.push(obj);

            }

            //return result; //JavaScript object
            return JSON.parse(JSON.stringify(result));
            //return JSON.stringify(result); //JSON
        }



        if(files.length)
        {
            var reader = new FileReader();

            reader.onload = function(e)
            {
                //document.getElementById('outputDiv').innerHTML = e.target.result;
                // //console.log(e.target.result);
                //console.log(e.target.result);
                var csvJSONVarFromUpload = csvJSON(e.target.result);
                //var csvJSONVarFromUpload = JSON.parse(csvJSONVar);
                //var csvJSONVarFromUpload = JSON.stringify(csvJSONVar);


                //console.log(csvJSONVarFromUpload);

                self.textArea = '';
                for(var i in csvJSONVarFromUpload)
                {
                    ////console.log(csvJSONVarFromUpload[i]);
                    // //console.log(csvJSONVarFromUpload[i]['peptide']);
                    if (csvJSONVarFromUpload[i]['peptide'] != "")
                    {
                        for (var key in csvJSONVarFromUpload[i]) {
                            if (csvJSONVarFromUpload[i].hasOwnProperty(key)) {

                                self.textArea += csvJSONVarFromUpload[i][key] + "  "

                            }
                        }

                        self.textArea += "\n";

                    }
                }
                //delete the last \n
                self.textArea = self.textArea.substring(0, self.textArea.length - 2);


                //console.log(self.textArea);
                $scope.$apply();

            };

            reader.readAsBinaryString(files[0]);
        }




        // $http.post(uploadUrl, fd, {
        //     withCredentials: true,
        //     headers: {'Content-Type': undefined },
        //     transformRequest: angular.identity
        // }).success(
        //     //console.log("success")
        // )
        //     .error(
        //         //console.log("error")
        // );

    };


    $scope.submitForUpload2 = function (file2) {
        var file = document.getElementById('files');
//console.log(file2);
        function csvJSON(csv){

            var lines=csv.split("\n");

            var result = [];

            var headers=lines[0].toString().replace(/"/g,"").split(",");
            //console.log(headers);
            for(var i=1;i<lines.length;i++){

                var obj = {};
                var currentline=lines[i].replace(/"/g,"").split(",");

                for(var j=0;j<headers.length;j++){
                    ////console.log(headers[j]);
                    obj[headers[j]] = currentline[j];
                }

                result.push(obj);

            }

            //return result; //JavaScript object
            return JSON.parse(JSON.stringify(result));
            //return JSON.stringify(result); //JSON
        }



        if(file.files.length)
        {
            var reader = new FileReader();

            reader.onload = function(e)
            {
                //document.getElementById('outputDiv').innerHTML = e.target.result;
                // //console.log(e.target.result);
                //console.log(e.target.result);
                var csvJSONVarFromUpload = csvJSON(e.target.result);
                //var csvJSONVarFromUpload = JSON.parse(csvJSONVar);
                //var csvJSONVarFromUpload = JSON.stringify(csvJSONVar);


                //console.log(csvJSONVarFromUpload);

                self.textArea = '';
                for(var i in csvJSONVarFromUpload)
                {
                    ////console.log(csvJSONVarFromUpload[i]);
                    // //console.log(csvJSONVarFromUpload[i]['peptide']);
                    if (csvJSONVarFromUpload[i]['peptide'] != "")
                    {
                        for (var key in csvJSONVarFromUpload[i]) {
                            if (csvJSONVarFromUpload[i].hasOwnProperty(key)) {

                                self.textArea += csvJSONVarFromUpload[i][key] + "  "

                            }
                        }

                        self.textArea += "\n";

                    }
                }
                //delete the last \n
                self.textArea = self.textArea.substring(0, self.textArea.length - 2);


                //console.log(self.textArea);
                $scope.$apply();

            };

            reader.readAsBinaryString(file.files[0]);
        }
        ////console.log(reader);

    }
    // $(document).ready(function () {
    //
    //     $("#btnSubmit").click(function (event) {
    //
    //         var file = document.getElementById('files');
    //
    //         if(file.files.length)
    //         {
    //             var reader = new FileReader();
    //
    //             reader.readAsBinaryString(file.files[0]);
    //             self.textArea = reader.target.result;
    //             //console.log(self.textArea);
    //         }
    //         //console.log(reader);
    //
    //     });
    //
    // });

    function fire_ajax_submit() {

        // Get form
        var form = $('#fileUploadForm')[0];
        //console.log(form);
        var data = new FormData(form);




        data.append("CustomField", "This is some extra data, testing");
        //console.log(data);
        $("#btnSubmit").prop("disabled", true);

        $.ajax({
            type: "POST",
            enctype: 'multipart/form-data',
            url: "/pln/api/upload/multi",
            data: data,
            //http://api.jquery.com/jQuery.ajax/
            //https://developer.mozilla.org/en-US/docs/Web/API/FormData/Using_FormData_Objects
            processData: false, //prevent jQuery from automatically transforming the data into a query string
            contentType: false,
            cache: false,
            timeout: 600000,
            success: function (data) {

                $("#result").text(data);
                //console.log("SUCCESS : ", data);
                $("#btnSubmit").prop("disabled", false);
                self.showUploadFlag = true;
                //console.log(self.showUploadFlag);


                function readTextFile(file)
                {
                    var rawFile = new XMLHttpRequest();
                    rawFile.open("GET", file, false);
                    rawFile.onreadystatechange = function ()
                    {
                        if(rawFile.readyState === 4)
                        {
                            if(rawFile.status === 200 || rawFile.status == 0)
                            {
                                var allText = rawFile.responseText;
                                alert(allText);
                            }
                        }
                    }
                    rawFile.send(null);
                }
                var fileAddress = "file:///Users/shamsabz/Documents/tmp/" + data.replace('Successfully uploaded - ','');;
                //console.log(fileAddress);
                readTextFile(fileAddress);

            },
            error: function (e) {

                $("#result").text(e.responseText);
                //console.log("ERROR : ", e);
                $("#btnSubmit").prop("disabled", false);
                self.showUploadFlag = true;
                //console.log(self.showUploadFlag);

            }
        });

    }
//End of uploading controller

    //
    // $filter('treeJSON', function () {
    //     function prettyPrintJson(json) {
    //         return JSON ? '\n' + JSON.stringify(json, null, ' ') : 'your browser does not support JSON so can not show the Json format.';
    //     }
    //
    //     return prettyPrintJson;
    // });





    $scope.initPlotly = function () {
        //console.log("in initplotly");
        var subCellularData = [{
            values: self.subCellularValues,
            labels: self.subCellularLabels,
            domain: {column: 0},
            textposition: 'inside',
            name: '',
            hoverinfo: 'label+percent+name',
            hole: .4,
            type: 'pie'
        }
        ];

        var subCellularLayout = {
            title: '',
            height: 400,
            width: 400,
            grid: {rows: 1, columns: 1},
            showlegend: false,
            annotations: [
                {
                    font: {
                        size: 14
                    },
                    showarrow: false,
                    text: '',
                    x: 0.5,
                    y: 0.5
                }
            ]
        };

        Plotly.newPlot('subcellularDiv', subCellularData, subCellularLayout);
        // ===============================================================
        // ===============================================================
        // ===============================================================

        var reactomeData = [{
            values: self.reactomeValues,
            labels: self.reactomeLabels,
            domain: {column: 0},
            textposition: 'inside',
            name: '',
            hoverinfo: 'label+percent+name',
            hole: .4,
            type: 'pie'
        }
        ];

        var reactomeLayout = {
            title: '',
            height: 400,
            width: 400,
            grid: {rows: 1, columns: 1},
            showlegend: false,
            annotations: [
                {
                    font: {
                        size: 14
                    },
                    showarrow: false,
                    text: '',
                    x: 0.5,
                    y: 0.5
                }
            ]
        };

        Plotly.newPlot('reactomeDiv', reactomeData, reactomeLayout);
        // ===============================================================
        // ===============================================================
        // ===============================================================


        var goData = [{
            values: self.goValues,
            labels: self.goLabels,
            domain: {column: 0},
            textposition: 'inside',
            name: '',
            hoverinfo: 'label+percent+name',
            hole: .4,
            type: 'pie'
        }
        ];

        var goLayout = {
            title: '',
            height: 400,
            width: 400,
            grid: {rows: 1, columns: 1},
            showlegend: false,
            annotations: [
                {
                    font: {
                        size: 14
                    },
                    showarrow: false,
                    text: '',
                    x: 0.5,
                    y: 0.5
                }
            ]
        };

        Plotly.newPlot('goDiv', goData, goLayout);

        if (self.volcanoJson.length > 0) {
            callVolcanoPlot(self.sliderFoldChangeValue, self.sliderSignificanceValue);
        }

    };

    //self.proteinForm = "";//"" for canonical, "{+iso" for canonical+isoform
    //console.log(self.organismForm);
    //console.log(self.proteinForm);

//This is for navigation tabs
    $scope.tabs = SharedService.getVar('tabs');


    // $scope.selectedTab = $scope.tabs[0];
    $scope.setSelectedTab = function (tab) {
        $scope.selectedTab = tab;
        //console.log($scope.selectedTab.link);
        //console.log($scope.selectedTab.label);
        self.activeSite = $scope.selectedTab.link;

        //console.log("url");
        $location.url(self.activeSite);
        self.url = $location.url();
        //console.log(self.url);

    }
    // //console.log($scope.selectedTab.link);
    // //console.log($scope.selectedTab.label);
    <!--This is for the tooltip on mouse over of navbar-->

    $(document).ready(function () {
        $('[data-toggle="tooltip"]').tooltip({
            trigger: 'hover'
        });
    });
    $scope.tabClass = function (tab) {
        if ($scope.selectedTab == tab) {
            self.activeSite = $scope.selectedTab.link;
            return "active";

        } else {
            return "";
        }
    }

    //This is for the formatting PLN
    $scope.changePLNJsonInlineInchAllhits2 = function(input) {


            self.plnFormatted = input;
//console.log(self.plnFormatted);

        //     <div ng-if="!ctrl.formatAsInchOrAllhits">
        //     <!--<textarea class="form-control" rows="3" style="background-color: #D9EDF7" ></textarea>-->
        //     {{self.plnFormatOne | inline}}
        // </div>
        // <div ng-if="ctrl.formatAsInchOrAllhits">
        //     {{self.plnFormatTwo | inline}}

        return self.plnFormatted;
    }
//This is for the formatting PLN
    $scope.changePLNFormat = function(plnFormat) {

        self.plnFormatted = plnFormat;
        return self.plnFormatted;

    }
//This is for the progress tab
    $scope.getPercentage = function () {
        // //console.log("self.progressPercent---------------");
        // //console.log(self.progressPercent.toFixed(0));
        return self.progressPercent.toFixed(0);
        //$scope.$apply();
        //return 98;
        //return (Math.round(self.prositeFoundNum / self.motifLength * 95.0));
    }
    //This is for submitting message in contact us

    self.onSubmitMessage = function () {
        var x = document.getElementById("frm");

        //var nameValue = document.getElementById("uniqueID").value;

        // function myFunction() {
        //
        //     //document.getElementById("demo").innerHTML = y;
        // }


        var text = "";
        var i;
        for (i = 0; i < x.length; i++) {
            text += x.elements[i].value + "<br>";
        }
        //console.log(text);
        var y = document.getElementById("frm").elements[0].value + " | " + document.getElementById("frm").elements[1].value + " | " + document.getElementById("frm").elements[2].value + " | " + document.getElementById("frm").elements[3].value + " | ";
        var valid = true;
        var email = document.getElementById("frm").elements[1];
        var email_validation = document.getElementById("email_validation");
        var name = document.getElementById("frm").elements[0];
        var name_validation = document.getElementById("name_validation");
        var message_validation = document.getElementById("frm").elements[3];
        var filter = /^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/;

        if (name.value === "") {
            valid = false;
            name_validation.innerHTML = "Field Required";
            name_validation.style.display = "block";
            name_validation.parentNode.style.backgroundColor = "#FFDFDF";
        } else {
            name_validation.style.display = "none";
            name_validation.parentNode.style.backgroundColor = "transparent";
        }

        if (message.value === "") {
            valid = false;
            message_validation.innerHTML = "Field Required";
            message_validation.style.display = "block";
            message_validation.parentNode.style.backgroundColor = "#FFDFDF";
        } else {
            message_validation.style.display = "none";
            message_validation.parentNode.style.backgroundColor = "transparent";
        }

        if (email.value === "") {
            valid = false;
            email_validation.innerHTML = "Field Required";
            email_validation.style.display = "block";
            email_validation.parentNode.style.backgroundColor = "#FFDFDF";
        } else {
            email_validation.style.display = "none";
            email_validation.parentNode.style.backgroundColor = "transparent";
        }

        if (!filter.test(email.value)) {
            valid = false;
            email_validation.innerHTML = "Invalid email address";
            email_validation.style.display = "block";
            email_validation.parentNode.style.backgroundColor = "#FFDFDF";
        } else {
            email_validation.style.display = "none";
            email_validation.parentNode.style.backgroundColor = "transparent";
        }
        //console.log(y);
        if (valid) {


            var url = 'api/sendEmail/';
            (function (query) {
                //console.log(query);
                $http.get(url + query)
                    .success(function (data) {
                        //console.log("Message sent.");
                        // setTimeout(function() {
                        //     document.getElementById('messageSuccess').style.display='none';
                        //     document.getElementById("messageSuccess").innerHTML = "Your message is sent, somebody from our team " +
                        //         "will contact you via the provided email address, shortly.";
                        // }, 10000);


                        $("#messageSuccess").fadeIn();
                        document.getElementById("messageSuccess").innerHTML = "Your message is sent, somebody from our team " +
                            "will contact you via the provided email address, shortly.";
                        //$("messageSuccess").fadeIn();
                        $("#messageSuccess").fadeOut(15000);
                        // $("#messageSuccess").delay(10000).hide(0);
                        // $("messageSuccess").replaceWith(function() {
                        //     return $(txt).hide().fadeIn(1000);});

                    })
                    .error(function (data, status) {

                        //console.log(data);
                        //console.log(status);

                    });


            })(y);
        }
    };
    // This is for the splash
    $(document).ready(function () {
        if ($(".splash").is(":visible")) {
            $(".wrapper").css({"opacity": "0"});
        }
        $(".splash-arrow").click(function () {
            $(".splash").slideUp("800", function () {
                $(".wrapper").delay(100).animate({"opacity": "1.0"}, 800);
            });
        });
    });

    // for mydropdown
    var ddData = [
        {
            text: "Homo sapiens",
            value: 1,
            selected: true,
            //scription with LinkedIn",
            imageSrc: "images/human5.png"
        },
        {
            text: "Mus musculus",
            value: 2,
            selected: false,
            //description: "Description with Facebook",
            imageSrc: "images/mouse5.png"
        },
        {
            text: "Rattus norvegicus",
            value: 3,
            selected: false,
            //description: "Description with Twitter",
            imageSrc: "images/rat5.png"
        }
    ];

    $('#myDropdown').ddslick({
        data: ddData,
        width: 300,
        height: 600,
        // selectText: "Select your preferred social network",
        imagePosition: "right",
        onSelected: function (selectedData) {
            //callback function: do something with selectedData;
        }
    });


    (function ($) {

        /* -------------------------------------------------------- */
        /*	//set Global variables
         /* -------------------------------------------------------- */
        var cards = $(".card-drop"),
            toggler = cards.find(".toggle"),
            links = cards.find("ul>li>a"),
            li = links.parent('li'),
            count = links.length,
            width = links.outerWidth();

        //set z-Index of drop Items
        links.parent("li").each(function (i) {
            $(this).css("z-index", count - i); //invert the index values
        });

        //set top margins & widths of li elements
        function setClosed() {
            li.each(function (index) {
                $(this).css("top", index * 2)
                    .css("width", width - index * 2)
                    .css("margin-left", (index * 2) / 2);
            });
            li.addClass('closed');
            toggler.removeClass("active");
        }

        setClosed();

        /* -------------------------------------------------------- */
        /*	Toggler Click handler
         /* -------------------------------------------------------- */
        toggler.on("mousedown", function () {
            var $this = $(this); //cache $(this)
            //if the menu is active:
            if ($this.is(".active")) {
                setClosed();
            } else {
                //if the menu is un-active:
                $this.addClass("active");
                li.removeClass('closed');
                //set top margins
                li.each(function (index) {
                    $(this).css("top", 60 * (index + 1))
                        .css("width", "100%")
                        .css("margin-left", "0px");
                });
            }
        });

        /* -------------------------------------------------------- */
        /*	Links Click handler
         /* -------------------------------------------------------- */
        links.on("click", function (e) {
            var $this = $(this),
                label = $this.data("label");
            icon = $this.children("i").attr("class");

            li.removeClass('active');
            if ($this.parent("li").is("active")) {
                $this.parent('li').removeClass("active");
            } else {
                $this.parent("li").addClass("active");
            }
            toggler.children("span").text(label);
            toggler.children("i").removeClass().addClass(icon);
            setClosed();
            e.preventDefault;
        });

    })(jQuery);
    (function ($) {

        /* -------------------------------------------------------- */
        /*	//set Global variables
         /* -------------------------------------------------------- */
        var cards = $(".card-drop2"),
            toggler = cards.find(".toggle"),
            links = cards.find("ul>li>a"),
            li = links.parent('li'),
            count = links.length,
            width = links.outerWidth();

        //set z-Index of drop Items
        links.parent("li").each(function (i) {
            $(this).css("z-index", count - i); //invert the index values
        });

        //set top margins & widths of li elements
        function setClosed() {
            li.each(function (index) {
                $(this).css("top", index * 2)
                    .css("width", width - index * 2)
                    .css("margin-left", (index * 2) / 2);
            });
            li.addClass('closed');
            toggler.removeClass("active");
        }

        setClosed();

        /* -------------------------------------------------------- */
        /*	Toggler Click handler
         /* -------------------------------------------------------- */
        toggler.on("mousedown", function () {
            var $this = $(this); //cache $(this)
            //if the menu is active:
            if ($this.is(".active")) {
                setClosed();
            } else {
                //if the menu is un-active:
                $this.addClass("active");
                li.removeClass('closed');
                //set top margins
                li.each(function (index) {
                    $(this).css("top", 60 * (index + 1))
                        .css("width", "100%")
                        .css("margin-left", "0px");
                });
            }
        });

        /* -------------------------------------------------------- */
        /*	Links Click handler
         /* -------------------------------------------------------- */
        links.on("click", function (e) {
            var $this = $(this),
                label = $this.data("label");
            icon = $this.children("i").attr("class");

            li.removeClass('active');
            if ($this.parent("li").is("active")) {
                $this.parent('li').removeClass("active");
            } else {
                $this.parent("li").addClass("active");
            }
            toggler.children("span").text(label);
            toggler.children("i").removeClass().addClass(icon);
            setClosed();
            e.preventDefault;
        });

    })(jQuery);

    (function ($) {

        /* -------------------------------------------------------- */
        /*	//set Global variables
         /* -------------------------------------------------------- */
        var cards = $(".card-drop3"),
            toggler = cards.find(".toggle"),
            links = cards.find("ul>li>a"),
            li = links.parent('li'),
            count = links.length,
            width = links.outerWidth();

        //set z-Index of drop Items
        links.parent("li").each(function (i) {
            $(this).css("z-index", count - i); //invert the index values
        });

        //set top margins & widths of li elements
        function setClosed() {
            li.each(function (index) {
                $(this).css("top", index * 2)
                    .css("width", width - index * 2)
                    .css("margin-left", (index * 2) / 2);
            });
            li.addClass('closed');
            toggler.removeClass("active");
        }

        setClosed();

        /* -------------------------------------------------------- */
        /*	Toggler Click handler
         /* -------------------------------------------------------- */
        toggler.on("mousedown", function () {
            var $this = $(this); //cache $(this)
            //if the menu is active:
            if ($this.is(".active")) {
                setClosed();
            } else {
                //if the menu is un-active:
                $this.addClass("active");
                li.removeClass('closed');
                //set top margins
                li.each(function (index) {
                    $(this).css("top", 60 * (index + 1))
                        .css("width", "100%")
                        .css("margin-left", "0px");
                });
            }
        });

        /* -------------------------------------------------------- */
        /*	Links Click handler
         /* -------------------------------------------------------- */
        links.on("click", function (e) {
            var $this = $(this),
                label = $this.data("label");
            icon = $this.children("i").attr("class");

            li.removeClass('active');
            if ($this.parent("li").is("active")) {
                $this.parent('li').removeClass("active");
            } else {
                $this.parent("li").addClass("active");
            }
            toggler.children("span").text(label);
            toggler.children("i").removeClass().addClass(icon);
            setClosed();
            e.preventDefault;
        });

    })(jQuery);

    /*
     $(window).scroll(function() {
     var windTop = $(window).scrollTop();
     var splashHeight = $(".splash").height();

     if(windTop>(100)){
     $(window).off("scroll");
     $(".splash").slideUp("800", function() {
     $("html, body").animate({"scrollTop":"0px"},100);
     });
     $(".wrapper").animate({"opacity":"1.0"},800);
     }
     else {

     }
     });
     */

    $(window).scroll(function () {
        $(window).off("scroll");
        $(".splash").slideUp("800", function () {
            $("html, body").animate({"scrollTop": "0px"}, 100);
            $(".wrapper").delay(100).animate({"opacity": "1.0"}, 800);
        });
    });

//Dropdown plugin data


    // $('myDropdown').ddslick({
    //     data:ddData,
    //     width:300,
    //     selectText: "Select your preferred social network",
    //     imagePosition:"left",
    //     onSelected: function(selectedData){
    //         //callback function: do something with selectedData;
    //     }
    // });

    function JSONToCSVConvertor(JSONData, ReportTitle, ShowLabel) {
        //If JSONData is not an object then JSON.parse will parse the JSON string in an Object
        var arrData = typeof JSONData != 'object' ? JSON.parse(JSONData) : JSONData;

        var CSV = '';
        //Set Report title in first row or line

        //CSV += ReportTitle + '\r\n\n';

        //This condition will generate the Label/Header
        if (ShowLabel) {
            var row = "";

            //This loop will extract the label from 1st index of on array
            for (var index in arrData[0]) {

                //Now convert each value to string and comma-seprated
                row += index + ',';
            }

            row = row.slice(0, -1);

            //append Label row with line break
            CSV += row + '\r\n';
        }

        //1st loop is to extract each row
        for (var i = 0; i < arrData.length; i++) {
            var row = "";

            //2nd loop will extract each column and convert it in string comma-seprated
            for (var index in arrData[i]) {
                row += '"' + arrData[i][index] + '",';
            }

            row.slice(0, row.length - 1);

            //add a line break after each row
            CSV += row + '\r\n';
        }

        if (CSV == '') {
            alert("Invalid data");
            return;
        }

        //Generate a file name
        var fileName = "";
        //this will remove the blank-spaces from the title and replace it with an underscore
        fileName += ReportTitle.replace(/ /g,"_");

        //Initialize file format you want csv or xls
        var uri = 'data:text/csv;charset=utf-8,' + escape(CSV);

        // Now the little tricky part.
        // you can use either>> window.open(uri);
        // but this will not work in some browsers
        // or you will not get the correct file extension

        //this trick will generate a temp <a /> tag
        var link = document.createElement("a");
        link.href = uri;

        //set the visibility hidden so it will not effect on your web-layout
        link.style = "visibility:hidden";
        link.download = fileName + ".csv";

        //this part will append the anchor tag and remove it after automatic click
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }


    $scope.downloadMascotCSVExample = function () {


        d3.csv('./example/mascot.csv', function (data) {
            //console.log(data);
            JSONToCSVConvertor(data, "Mascot", true);
            // alasql('SELECT * INTO XLSX("example.xlsx",{headers:true}) FROM ?', [data]);
        })
    }

    // $scope.downloadCSVExample1 = function () {
    //
    //
    //     d3.csv('./example/example.xlsx', function (data) {
    //         //console.log(data);
    //         JSONToCSVConvertor(data, "Example", true);
    //         // alasql('SELECT * INTO XLSX("example.xlsx",{headers:true}) FROM ?', [data]);
    //     })
    // }

    function downloadfromXML(data, dataName) {
        var wb = XLSX.utils.book_new();
        wb.Props = {
            Title: "SheetJS Tutorial",
            Subject: "Test",
            Author: "Red Stapler",
            CreatedDate: new Date(2017,12,19)
        };
        wb.SheetNames.push("Test Sheet");
        //console.log(data);

        var ws_data = [['peptide' , 'abundance'],['IYQY[+79.966]IQSR' , -0.034547727],['TPKDS[+79.966]PGIPPSANAHQLFR' , -0.0000267]]
        var ws_data = [['peptide' , 's_1', 's_2', 's_3', 'c_1', 'c_2', 'c_3'],['IYQY[+79.966]IQSR' , -0.334547727, -0.434547727, -0.534547727, -1.334547727, -1.434547727, -1.534547727],['TPKDS[+79.966]PGIPPSANAHQLFR' , -0.0000267, -0.1000267, -0.2000267, -1.0000267, -1.1000267, -1.2000267]]
        var ws_data = [];
        var first_iter = true;

        for (var i = 0; i < data.length; i++){
            var obj = data[i];


            if (first_iter) {
                var keysOfEachRow = [];
                for (var key in obj) {

                    var attrName = key;

                    keysOfEachRow.push(attrName);

                }
                ws_data.push(keysOfEachRow);
                first_iter = false;
                ////console.log(keysOfEachRow);

            }
            else {
                var valsOfEachRow = [];
                for (var key in obj) {

                    var attrValue = obj[key];
                    valsOfEachRow.push(attrValue);

                }
                ws_data.push(valsOfEachRow);
                ////console.log(valsOfEachRow);
            }


        }

        //var ws_data = [['hello' , 'world']];  //a row with 2 columns
        var ws = XLSX.utils.aoa_to_sheet(ws_data);
        wb.Sheets["Test Sheet"] = ws;
        var wbout = XLSX.write(wb, {bookType:'xlsx',  type: 'binary'});
        function s2ab(s) {
            var buf = new ArrayBuffer(s.length); //convert s to arrayBuffer
            var view = new Uint8Array(buf);  //create uint8array as viewer
            for (var i=0; i<s.length; i++) view[i] = s.charCodeAt(i) & 0xFF; //convert to octet
            return buf;

        }
        var dataNameReturn = dataName + ".xlsx"
        return saveAs(new Blob([s2ab(wbout)],{type:"application/octet-stream"}), dataNameReturn);
    }

    $scope.downloadCSVExample1 = function () {



// IMPORTANT NOTE! Here myData is still null

        d3.csv('./example/probe_with_fold_change.csv', function (data) {

            ////console.log(data);
            downloadfromXML(data, "probe_with_log_fold_change");


            // JSONToCSVConvertor(data, "Example", true);
            // alasql('SELECT * INTO XLSX("example.xlsx",{headers:true}) FROM ?', [data]);
        })
    }



    $scope.downloadCSVExample2 = function(){
        d3.csv('./example/probe_with_treatment_and_control.csv', function (data) {
            var objKeys = Object.keys(data[0]);
            console.log(objKeys);
            var headers = {};
            for (var i = 0; i < objKeys.length; i++){
                headers[objKeys[i]] = objKeys[i];
            }
            var fileTitle = 'pinet_probe_with_treatment_and_control'; // or 'my-unique-title'

            exportCSVFile(headers, data, fileTitle); // call the exportCSVFile() function to process the JSON and trigger the download

        })
        // format the data

    }





    // $scope.downloadCSVExample2 = function () {
    //
    //
    //     d3.csv('./example/probe_with_treatment_and_control.csv', function (data) {
    //
    //         ////console.log(data);
    //         downloadfromXML(data, "probe_with_treatment_and_control");
    //
    //
    //         // JSONToCSVConvertor(data, "Example", true);
    //         // alasql('SELECT * INTO XLSX("example.xlsx",{headers:true}) FROM ?', [data]);
    //     })
    // }

    $scope.downloadPLN = function (formatOne, formatTwo, formatThree, formatAsInchOrAllhits) {

        //console.log(formatAsInchOrAllhits);

        self.plnForDownload = [];
        console.log(formatOne);
        console.log(formatTwo);
        console.log(formatThree);
        console.log(formatAsInchOrAllhits);
        //
        // self.namearray = [
        //     {name: 'Tobias'},
        //     {name: 'Jeff'},
        //     {name: 'Brian'},
        //     {name: 'Igor'},
        //     {name: 'James'},
        //     {name: 'Brad'}
        // ];
        // self.filteredArray = filterFilter(self.namearray, {name:'Igor'});
        // //console.log(self.filteredArray);
        // //console.log(filteredItems);
        //console.log(formatOne);
        //console.log(formatTwo);
        // //console.log(self.someSetting);

        // var peptides = self.textArea
        //     .split(self.rowSplitPattern);

        //console.log(peptides);

        var peptides = self.textArea
            .split(self.rowSplitPattern)
            .map(function (e) {
                if (e) {
                    // var str = e.split(/[\s,]+/).join();
                    // //console.log(str);
                    // var str2 = str.replace(/[\s,]+/g, ',');
                    // //console.log(str2);
                    var str2 = e.replace(/,/g, '').replace(/^\s\s*/, '').replace(/\s\s*$/, '').replace(/[\s,]+/g, ',');
                    ////console.log(str2);
                    if (str2.indexOf(',') > -1) {
                        str2 = str2.split(',').slice(0);
                        //console.log(str2[0]);
                        return str2[0];
                    }
                    else {
                        //console.log(str2);
                        return str2;
                    }
                    ;
                }
                //return e.replace(/,/g , '').replace(/^\s\s*/, '').replace(/\s\s*$/, '').replace(/[\s,]+/g, ',');

                // if (e.length() == 1){
                //     return e[1];
                // }
                // if (!self.formatInput) {
                //     return e.match(self.modificationPatternWithLetter);
                // } else {
                //     return e.match(self.modificationPatternSecondFormat);
                // }

            });



        $scope.inlineForDownload = function (peptidesList, plnArray) {
            var output = '\n';
            var layerSep;
            var groupSep;
            var itemSep;
            var FormatREF;
            var FormatSYM;
            var FormatDES;
            var FormatVAR;
            var FormatPTM;
            var FormatProteoForm;
            for (var i = 0; i < plnArray.length; i++) {
                var plnLocal = plnArray[i];

                var plnKey = Object.keys(plnLocal.PLN)[0];
                var plnValue = plnLocal.PLN[plnKey];

                var refKey = Object.keys(plnLocal.REF)[0];
                var refValue = plnLocal.REF[refKey];

                var symKey = Object.keys(plnLocal.SYM)[0];
                var symValue = plnLocal.SYM[symKey];

                var PTM = [];
                var ProteoForm = [];
                itemSep = "&";
                if (plnValue == "InChl-like") {
                    layerSep = "/";
                    groupSep = ";";
                    FormatREF = "r=";
                    FormatSYM = "s=";
                    FormatDES = "d=";
                    FormatVAR = "v=";
                    FormatPTM = "m=";
                } else if (plnValue == "ProteoForm") {
                    layerSep = "/";
                    groupSep = ";";
                    FormatREF = "r=";
                    FormatSYM = "s=";
                    FormatDES = "d=";
                    FormatVAR = "v=";
                    FormatPTM = "m=";
                    FormatProteoForm = "f=";
                } else {
                    layerSep = ";";
                    groupSep = ",";
                    FormatREF = "REF=";
                    FormatSYM = "SYM=";
                    FormatDES = "DES=";
                    FormatVAR = "VAR=";
                    FormatPTM = "PTM=";

                }


                plnLocal.PTM.map(function (ptmGroup) {
                        ////console.log(ptmGroup);

                        var ptmForHit = [];

                        for (var index = 0; index < ptmGroup.length; index++) {
                            ptmForHit.push(ptmGroup[index].identifier + "@" + ptmGroup[index].location);
                        }

                        PTM.push(ptmForHit.join(itemSep));
                    }
                );


                if (plnValue == "ProteoForm") {
                    output =
                        "PLN=" + plnKey + ":" + plnValue + layerSep +
                        FormatREF + refKey + ":" + refValue.join(groupSep + refKey + ":") + layerSep +
                        FormatSYM + symKey + ":" + symValue.join(groupSep + symKey + ":") + layerSep +
                        FormatDES + layerSep +
                        FormatVAR + layerSep +
                        FormatPTM + PTM.join(groupSep)
                        + layerSep +
                        FormatProteoForm + ProteoForm + "#" ;
                }
                else {
                    output =
                        "PLN=" + plnKey + ":" + plnValue + layerSep +
                        FormatREF + refKey + ":" + refValue.join(groupSep + refKey + ":") + layerSep +
                        FormatSYM + symKey + ":" + symValue.join(groupSep + symKey + ":") + layerSep +
                        FormatDES + layerSep +
                        FormatVAR + layerSep +
                        FormatPTM + PTM.join(groupSep) + "#" ;

                }


                var plnElem = {};
                plnElem["peptide"] = peptidesList[i];
                plnElem["pln"] = output;


                self.plnForDownload.push(plnElem);


            }


        };


        if (formatAsInchOrAllhits == 0) {
            $scope.inlineForDownload(peptides, formatOne);
            //console.log("here1");
        }


        if (formatAsInchOrAllhits == 1) {
            $scope.inlineForDownload(peptides, formatTwo);
            //console.log("here2");
        }

        if (formatAsInchOrAllhits == 2) {
            $scope.inlineForDownload(peptides, formatThree);
            //console.log("here2");
        }


        console.log(self.plnForDownload);
       // alasql('SELECT * INTO XLSX("PLN.xlsx",{headers:true}) FROM ?', [self.plnForDownload]);

        $scope.exportCsvGeneral(self.plnForDownload,'pinet-Protein-Line-Notation(PLN)');
        //
        // //console.log(self.ontologyMappingsForDownload);
        // alasql('SELECT * INTO XLSX("PSI-MOD-ontologyMappings.xlsx",{headers:true}) FROM ?', [self.ontologyMappingsForDownload]);


    };

    function convertToCSV(objArray) {
        var array = typeof objArray != 'object' ? JSON.parse(objArray) : objArray;
        var str = '';

        for (var i = 0; i < array.length; i++) {
            var line = '';
            for (var index in array[i]) {
                if (line != '') line += ','

                line += array[i][index];
            }

            str += line + '\r\n';
        }

        return str;
    }

    function exportCSVFile(headers, items, fileTitle) {
        console.log(items);
        if (headers) {
            items.unshift(headers);
        }
        console.log(items);
        // Convert Object to JSON
        var jsonObject = JSON.stringify(items);
        console.log(jsonObject);
        var csv = convertToCSV(jsonObject);

        var exportedFilenmae = fileTitle + '.csv' || 'export.csv';

        var blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        if (navigator.msSaveBlob) { // IE 10+
            navigator.msSaveBlob(blob, exportedFilenmae);
        } else {
            var link = document.createElement("a");
            if (link.download !== undefined) { // feature detection
                // Browsers that support HTML5 download attribute
                var url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", exportedFilenmae);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }
    }

    $scope.exportCsvGeneral = function(data,name){
        var objKeys = Object.keys(data[0]);
        var headers = {};
        for (var i = 0; i < objKeys.length; i++){
            headers[objKeys[i]] = objKeys[i];
        }
        exportCSVFile(headers, data, name);

    }

    $scope.exportDataontologyMappings = function (ontologyMappings) {
        //console.log(self.sequence_acListComplete);
        self.ontologyMappingsForDownload = [];
        //console.log(ontologyMappings);
        //console.log(ontologyMappings);

        ontologyMappings.map(function (e) {

            var input = e.input;
            var inputMass = e.mass;
            var identifierAccession = e.identifier;
            var identifierMass = e.diffavg;
            var identifierDescription = e.description;
            var identifierFromula = e.formula;

            var ontologyMappingsElem = {};


            ontologyMappingsElem["input"] = input;
            ontologyMappingsElem["inputMass"] = inputMass;
            ontologyMappingsElem["identifierAccession"] = identifierAccession;
            ontologyMappingsElem["identifierMass"] = identifierMass;
            ontologyMappingsElem["identifierDescription"] = identifierDescription;
            ontologyMappingsElem["identifierFromula"] = identifierFromula;
            // ontologyMappingsElem["mostSimilar"] = mostSimilarElem;
            // ontologyMappingsElem["family"] = familyElem;

            self.ontologyMappingsForDownload.push(ontologyMappingsElem);

        });
        console.log(self.ontologyMappingsForDownload);
        $scope.exportCsvGeneral(self.ontologyMappingsForDownload,'pinet-PSI-MOD-ontologyMappings');

        //alasql('SELECT * INTO XLSX("PSI-MOD-ontologyMappings.xlsx",{headers:true}) FROM ?', [self.ontologyMappingsForDownload]);

    };



    $scope.exportDataprResponseList = function () {
        //console.log(self.prResponseList);
        self.prResponseListForDownload = [];
        self.prResponseList.map(function (e) {

            if (typeof e.response !== 'undefined' && 0 < e.response.length) {
                e.response.map(function (e2) {
                    var prResponseElem = {};
                    prResponseElem["motif"] = e.motif;
                    prResponseElem["peptide"] = e.peptide;
                    // ontologyMappingsElem["hits"] = e.length;

                    prResponseElem["start"] = e2.start;
                    prResponseElem["stop"] = e2.stop;
                    prResponseElem["length"] = e2.length;
                    prResponseElem["sequence_ac"] = e2.sequence_ac;
                    prResponseElem["sequence_id"] = e2.sequence_id;
                    self.prResponseListForDownload.push(prResponseElem);
                });
            }

        });
        $scope.exportCsvGeneral(self.prResponseListForDownload,'pinet-peptideToProtein');
        //alasql('SELECT * INTO XLSX("peptideToProtein.xlsx",{headers:true}) FROM ?', [self.prResponseListForDownload]);
    };

    $scope.exportDatasequence_acListComplete = function () {
        //console.log(self.sequence_acListComplete);
        self.sequence_acListCompleteForDownload = [];
        self.sequence_acListComplete.map(function (e) {

            if (typeof e.members !== null) {
                e.members.map(function (e2) {
                    var sequence_acElem = {};
                    var genes = ""
                    sequence_acElem["sequence_ac"] = e.name;
                    sequence_acElem["peptide"] = e2.peptide;
                    sequence_acElem["motif"] = e2.motif;
                    e2.primary_gene_name.map(function (e3) {
                        genes = genes + e3 + "   "
                    })
                    sequence_acElem["gene symbols"] = genes;
                    sequence_acElem["sequence"] = e2.sequence;
                    sequence_acElem["start"] = e2.start;
                    sequence_acElem["stop"] = e2.stop;


                    sequence_acElem["length"] = e2.length;
                    // ontologyMappingsElem["hits"] = e.length;



                    self.sequence_acListCompleteForDownload.push(sequence_acElem);
                });
            }

        });
        $scope.exportCsvGeneral(self.sequence_acListCompleteForDownload,'pinet-proteinToPeptide');
        //alasql('SELECT * INTO XLSX("proteinToPeptide.xlsx",{headers:true}) FROM ?', [self.sequence_acListCompleteForDownload]);
    };

    $scope.exportDatapeptideToModificationList = function () {
        //console.log(self.parallelJson);
        $scope.exportCsvGeneral(self.parallelJson,'pinet-peptideToModificationList');
        //alasql('SELECT * INTO XLSX("peptideToModificationList.xlsx",{headers:true}) FROM ?', [self.parallelJson]);
    };


    function convertToCSV(objArray) {
        var array = typeof objArray != 'object' ? JSON.parse(objArray) : objArray;
        var str = '';

        for (var i = 0; i < array.length; i++) {
            var line = '';
            for (var index in array[i]) {
                if (line != '') line += ','

                line += array[i][index];
            }

            str += line + '\r\n';
        }

        return str;
    }

    function exportCSVFile(headers, items, fileTitle) {
        console.log(items);
        if (headers) {
            items.unshift(headers);
        }
        console.log(items);
        // Convert Object to JSON
        var jsonObject = JSON.stringify(items);
        console.log(jsonObject);
        var csv = convertToCSV(jsonObject);

        var exportedFilenmae = fileTitle + '.csv' || 'export.csv';

        var blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        if (navigator.msSaveBlob) { // IE 10+
            navigator.msSaveBlob(blob, exportedFilenmae);
        } else {
            var link = document.createElement("a");
            if (link.download !== undefined) { // feature detection
                // Browsers that support HTML5 download attribute
                var url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", exportedFilenmae);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }
    }

    $scope.exportCsvGeneral = function(data,name){
        var objKeys = Object.keys(data[0]);
        var headers = {};
        for (var i = 0; i < objKeys.length; i++){
            headers[objKeys[i]] = objKeys[i];
        }
        exportCSVFile(headers, data, name);

    }
    $scope.exportDataGeneInfo = function () {
        //console.log(self.inputGeneInfo);
        $scope.exportCsvGeneral(self.inputGeneInfo,'pinet-geneInfo');
        //alasql('SELECT * INTO XLSX("geneInfo.xlsx",{headers:true}) FROM ?', [self.inputGeneInfo]);
    };

    $scope.sort = function (keyname) {
        $scope.sortKey = keyname;   //set the sortKey to the param passed
        $scope.reverse = !$scope.reverse; //if true make it false and vice versa
    };

    // $scope.newPage = function (){
    //     location.href = '#/new-page.html';
    // };


    self.showSection1Function = function () {
        //console.log("self.showSection1");
        //console.log(self.showSection1);
        self.showSection1 = !self.showSection1;
    }

    self.showSection2Function = function () {
        //console.log("self.showSection2");
        //console.log(self.showSection2);
        self.showSection2 = !self.showSection2;
    }

    self.showSection3Function = function () {
        //console.log("self.showSection3");
        //console.log(self.showSection3);
        self.showSection3 = !self.showSection3;
    }

    self.showSection4Function = function () {
        //console.log("self.showSection4");
        //console.log(self.showSection4);
        self.showSection4 = !self.showSection4;
    }


    self.changePLNShow = function () {
        self.showPLN = !self.showPLN;
    }

    //function($scope, $window) {
    $scope.customNavigateApi = function (msg) {
        $window.open("/pln/api/pathway/genes/" + msg, '_blank');
    };

    $scope.customNavigateGraphics = function (msg) {
        //$window.sessionStorage.setItem("genes", msg);
        //$window.open("/pln/enrichment.html", '_blank');
        //self.inputGenesForPathway = $window.sessionStorage.getItem("genes");
        //var inputGenesForPathway = $window.sessionStorage.getItem("genes");
        //console.log("inputGenes");
        //console.log(self.inputGenesForPathway);
        //console.log(inputGenesForPathway);
    };
    // self.changePLNForDropdown = function (similarmod, originalmod, similardescription, originaldescription, similaMass, originalMass) {

    self.changePLNForDropdown = function (itemScope, similar, originalmod,  originaldescription,  originalFormula,  originalMass) {

        //console.log("In change PLN For Dropdown ");
        //console.log(itemScope);
        //itemScopeSplitted = itemScope.split("{");
        itemScopeSplitted = itemScope.descriptionAll.split("},{");
        //itemScopeSplitted = itemScopeSplitted.split("}");
        //console.log(itemScopeSplitted);
        var similarmod = itemScopeSplitted[0].split("{")[1];
        var similardiffavg = itemScopeSplitted[1];
        var similarFormula = itemScopeSplitted[2];
        var similardescription = itemScopeSplitted[3].split("}")[0];
        //console.log(similarmod);
        //console.log(similardescription);
        //console.log(similar);
        //console.log(originalmod);
        ////console.log(similardescription);
        //console.log(originaldescription);
        ////console.log(similaMass);
        //console.log(originalMass);
            ////console.log($scope.itemScope);
        ////console.log($scope.descriptionAllSent);
        ////console.log($scope.similar.descriptionAll);
        ////console.log(self.ontologyMappings);
        // //console.log(self.plnFormatOne);
        // //console.log(self.plnFormatTwo);
        self.ontologyMappings.map(function (e) {
            // //console.log(e);
            if (e.identifier === originalmod) {
                e.identifier = similarmod;
                e.description = similardescription;
                e.diffavg = similardiffavg;
                e.formula = similarFormula;
                // e.similar.map(function (e2) {
                //     // //console.log(e2);
                //     if (e2.string === similarmod) {
                //         e2.string = originalmod;
                //         e2.description = originaldescription;
                //
                //     }
                // })
                // }
            }


        })
        // var radios = document.getElementsByTagName('inputRadioPLN');
        // for (i = 0; i < radios.length; i++) {
        //     radios[i].onclick = function (e3) {
        //         if (e3.ctrlKey) {
        //             this.checked = false;
        //         }
        //     }
        // }
        self.plnFormatOne.map(function (e4) {
            // //console.log(e4);
            e4.PTM.map(function (e5) {
                e5.map(function (e6) {
                    //console.log("e6");
                    //console.log(e6);
                    if (e6.identifier === originalmod) {
                        // //console.log(e6.identifier);
                        // //console.log(similarmod);
                        e6.identifier = similarmod;
                    }
                })
            })
        })
        self.plnFormatTwo.map(function (e7) {
            e7.PTM.map(function (e8) {
                e8.map(function (e9) {

                    if (e9.identifier === originalmod) {

                        // //console.log(originalmod);
                        e9.identifier = similarmod;
                    }
                })
            })
        })
        SharedService.setVar('plnFormatOne', self.plnFormatOne);
        SharedService.setVar('plnFormatTwo', self.plnFormatTwo);

        //console.log(self.plnFormatOne);
        //console.log(self.plnFormatTwo);
    };

    self.changePLN = function (similarmod, originalmod, similardescription, originaldescription) {

        // //console.log(similarmod);
        // //console.log(originalmod);
        // //console.log(similardescription);
        // //console.log(originaldescription);
        // // //console.log(self.ontologyMappings);
        // //console.log(self.plnFormatOne);
        // //console.log(self.plnFormatTwo);
        self.ontologyMappings.map(function (e) {
            // //console.log(e);
            if (e.identifier === originalmod) {
                e.identifier = similarmod;
                e.description = similardescription;

                e.similar.map(function (e2) {
                    // //console.log(e2);
                    if (e2.string === similarmod) {
                        e2.string = originalmod;
                        e2.description = originaldescription;

                    }
                })
                // }
            }


        })
        var radios = document.getElementsByTagName('inputRadioPLN');
        for (i = 0; i < radios.length; i++) {
            radios[i].onclick = function (e3) {
                if (e3.ctrlKey) {
                    this.checked = false;
                }
            }
        }
        self.plnFormatOne.map(function (e4) {
            // //console.log(e4);
            e4.PTM.map(function (e5) {
                e5.map(function (e6) {
                    //console.log("e6");
                    //console.log(e6);
                    if (e6.identifier === originalmod) {
                        // //console.log(e6.identifier);
                        // //console.log(similarmod);
                        e6.identifier = similarmod;
                    }
                })
            })
        })
        self.plnFormatTwo.map(function (e7) {
            e7.PTM.map(function (e8) {
                e8.map(function (e9) {

                    if (e9.identifier === originalmod) {

                        // //console.log(originalmod);
                        e9.identifier = similarmod;
                    }
                })
            })
        })
        SharedService.setVar('plnFormatOne', self.plnFormatOne);
        SharedService.setVar('plnFormatTwo', self.plnFormatTwo);

        //console.log(self.plnFormatOne);
        //console.log(self.plnFormatTwo);
    };

    self.changePLNMostSimilar = function (similarmod, originalmod, similardescription, originaldescription, modification, originalmostSimilarDiffAvg, originaldiffavg) {

        // //console.log(similarmod);
        // //console.log(originalmod);
        // //console.log(similardescription);
        // //console.log(originaldescription);
        // // //console.log(self.ontologyMappings);
        // //console.log(self.plnFormatOne);
        // //console.log(self.plnFormatTwo);
        self.ontologyMappings.map(function (e) {
            // //console.log(e);
            if (e.modification === modification) {
                e.identifier = similarmod;
                e.description = similardescription;
                e.mostSimilarDiffAvg = originaldiffavg;
                e.diffavg = originalmostSimilarDiffAvg;

                e.mostSimilar.map(function (e2) {
                    // //console.log(e2);
                    if (e2.string === similarmod) {
                        e2.string = originalmod;
                        e2.description = originaldescription;

                    }
                })
                // }
            }


        })
        var radios = document.getElementsByTagName('inputRadioPLN2');
        for (i = 0; i < radios.length; i++) {
            radios[i].onclick = function (e3) {
                if (e3.ctrlKey) {
                    this.checked = false;
                }
            }
        }
        //console.log(self.plnFormatOne);
        self.plnFormatOne.map(function (e4) {
            // //console.log(e4);
            e4.PTM.map(function (e5) {
                e5.map(function (e6) {
                    // //console.log(e6);
                    // //console.log("e6");
                    // //console.log(e6);
                    if (modification.includes(e6.ptmMassSite[0]) && modification.includes(e6.ptmMassModification[0])) {
                        // //console.log(e6.identifier);
                        // //console.log(similarmod);
                        e6.identifier = similarmod;
                    }
                })
            })
        })
        // //console.log(self.plnFormatOne);
        self.plnFormatTwo.map(function (e7) {
            // //console.log(e7);
            e7.PTM.map(function (e8) {
                e8.map(function (e9) {
                    // //console.log(e9);
                    // //console.log("e9");
                    //  //console.log(e9.ptmMassSite[0]);
                    // //console.log(e9.ptmMassModification[0]);
                    if (modification.includes(e9.ptmMassSite[0]) && modification.includes(e9.ptmMassModification[0])) {

                        // //console.log(originalmod);
                        e9.identifier = similarmod;
                    }
                })
            })
        })
        SharedService.setVar('plnFormatOne', self.plnFormatOne);
        SharedService.setVar('plnFormatTwo', self.plnFormatTwo);

        //console.log(self.plnFormatOne);
        //console.log(self.plnFormatTwo);
    };

    self.changePLNFamily = function (familymod, originalmod, familydescription, originaldescription, modification, originaldiffavg, familydiffavg) {

        // //console.log(similarmod);
        // //console.log(originalmod);
        // //console.log(similardescription);
        // //console.log(originaldescription);
        // // //console.log(self.ontologyMappings);
        // //console.log(self.plnFormatOne);
        // //console.log(self.plnFormatTwo);
        self.ontologyMappings.map(function (e) {
            // //console.log(e);
            if (e.modification === modification) {
                e.identifier = familymod;
                e.description = familydescription;
                e.diffavg = familydiffavg;

                e.is_a.map(function (e2) {
                    // //console.log(e2);
                    if (e2.mod === familymod) {
                        e2.mod = originalmod;
                        e2.defstr = originaldescription;
                        e2.DiffAvg = originaldiffavg;

                    }
                })
                // }
            }


        })
        var radios = document.getElementsByTagName('inputRadioPLN3');
        for (i = 0; i < radios.length; i++) {
            radios[i].onclick = function (e3) {
                if (e3.ctrlKey) {
                    this.checked = false;
                }
            }
        }
        //console.log(self.plnFormatOne);
        self.plnFormatOne.map(function (e4) {
            // //console.log(e4);
            e4.PTM.map(function (e5) {
                e5.map(function (e6) {
                    // //console.log(e6);
                    // //console.log("e6");
                    // //console.log(e6);
                    if (modification.includes(e6.ptmMassSite[0]) && modification.includes(e6.ptmMassModification[0])) {
                        // //console.log(e6.identifier);
                        // //console.log(similarmod);
                        e6.identifier = familymod;
                    }
                })
            })
        })
        // //console.log(self.plnFormatOne);
        self.plnFormatTwo.map(function (e7) {
            // //console.log(e7);
            e7.PTM.map(function (e8) {
                e8.map(function (e9) {
                    // //console.log(e9);
                    // //console.log("e9");
                    //  //console.log(e9.ptmMassSite[0]);
                    // //console.log(e9.ptmMassModification[0]);
                    if (modification.includes(e9.ptmMassSite[0]) && modification.includes(e9.ptmMassModification[0])) {

                        // //console.log(originalmod);
                        e9.identifier = familymod;
                    }
                })
            })
        })
        SharedService.setVar('plnFormatOne', self.plnFormatOne);
        SharedService.setVar('plnFormatTwo', self.plnFormatTwo);

        //console.log(self.plnFormatOne);
        //console.log(self.plnFormatTwo);
    };


    $scope.retrieveGenesAndPtm = function () {
        //self.showSplash = false;
        //self.firstVisit = false;
        //self.genes = localStorage.getItem("genesForProtein2Pathways");
        ////console.log("in retrieveGenesAndPtm");
        ////console.log(self.genes);
        //localStorage.setItem("genesForProtein2Pathways", "");
        //self.inputMassPtmProteins = localStorage.getItem("massPtmProteinsForProtein2Pathways");
        //localStorage.setItem("massPtmProteinsForProtein2Pathways", "");
        //self.inputShorthandPtmProteins = localStorage.getItem("shorthandPtmProteinsForProtein2Pathways");
        //localStorage.setItem("massPtmProteinsForProtein2Pathways", "");
        //self.organismFormProteinToPathway = localStorage.getItem("organism");
        //self.uniprotJsonObjectAllForProtein2Pathways = localStorage.getItem("uniprotJsonObjectAllForProtein2Pathways");
        //self.ptmToModifierPtmOrGene = localStorage.getItem("ptmToModifierPtmOrGene");
        // //console.log("$routeParams.id");
        // //console.log($routeParams.id);

        //console.log(self.genes);
        ////console.log(self.organismFormProteinToPathway);
        //alert(self.genes);



        // $http.get("api/increment/" + 0)
        //     .success(function (siteVisit) {
        //         //console.log("siteVisit");
        //         //console.log(siteVisit);
        //         self.siteVisit = siteVisit;
        //
        //     })
        //     .error(function (data, status) {
        //
        //         //console.log(data);
        //         //console.log(status);
        //
        //
        //     });
        // $window.sessionStorage.setItem("genesForProtein2Pathways", self.geneIdList);
        // $window.sessionStorage.setItem("massPtmProteinsForProtein2Pathways", self.geneIdListMassCombined);
        // $window.sessionStorage.setItem("shorthandPtmProteinsForProtein2Pathways", self.geneIdListShorthandCombined);
        // self.inputGenesForPathway = $window.sessionStorage.getItem("genes");
        // var inputGenesForPathway = $window.sessionStorage.getItem("genes");
        // //console.log("inputGenes");
        // //console.log(self.inputGenesForPathway);
        // //console.log(inputGenesForPathway);
        //
        //
        // self.makeParallelGrid(self.peptideToModificationList);
        // //console.log(self.geneIdListShorthandCombined);
        // //console.log(self.geneIdListMassCombined);
        // self.inputMassPtmProteins = self.geneIdListMassCombined;



    };


    //$scope.aboutInit = function () {
        // self.showSplash = false;
        // self.firstVisit = false;
        // $http.get("api/increment/" + 0)
        //     .success(function (siteVisit) {
        //         //console.log("siteVisit");
        //         //console.log(siteVisit);
        //         self.siteVisit = siteVisit;
        //
        //     })
        //     .error(function (data, status) {
        //
        //         //console.log(data);
        //         //console.log(status);
        //
        //
        //     });
    //};

    $scope.retrievePeptides = function () {
        self.showSplash = false;
        SharedService.setVar('showSplash', false);
        self.firstVisit = false;
        SharedService.setVar('firstVisit', false);
        //self.textAreaFormatMD = localStorage.getItem("textAreaForPeptide2Protein");

        // //console.log("in the retrievePeptides");
        // //console.log("self.textArea");
        // //console.log(self.textArea);
        //
        // //console.log("self.showOutput");
        // //console.log(self.showOutput);
        //self.waiting = localStorage.getItem("waitingForPeptideToProtein");
        //self.showOutput = localStorage.getItem("showOutputForPeptideToProtein");
        // //console.log("self.waiting");
        // //console.log(self.waiting);

        // //console.log("self.showOutput");
        // //console.log(self.showOutput);

        //localStorage.setItem("genesForProtein2Pathways", "");
        //self.inputMassPtmProteins = localStorage.getItem("massPtmProteinsForProtein2Pathways");
        //localStorage.setItem("massPtmProteinsForProtein2Pathways", "");
        //self.inputShorthandPtmProteins = localStorage.getItem("shorthandPtmProteinsForProtein2Pathways");
        //localStorage.setItem("massPtmProteinsForProtein2Pathways", "");
        //self.organismFormProteinToPathway = localStorage.getItem("organism");
        //self.uniprotJsonObjectAllForProtein2Pathways = localStorage.getItem("uniprotJsonObjectAllForProtein2Pathways");
        // //console.log(self.genes);
        // //console.log(self.organismFormProteinToPathway);


        // $http.get("api/increment/" + 0)
        //     .success(function (siteVisit) {
        //         //console.log("siteVisit");
        //         //console.log(siteVisit);
        //         self.siteVisit = siteVisit;
        //
        //     })
        //     .error(function (data, status) {
        //
        //         //console.log(data);
        //         //console.log(status);
        //
        //
        //     });
        // $window.sessionStorage.setItem("genesForProtein2Pathways", self.geneIdList);
        // $window.sessionStorage.setItem("massPtmProteinsForProtein2Pathways", self.geneIdListMassCombined);
        // $window.sessionStorage.setItem("shorthandPtmProteinsForProtein2Pathways", self.geneIdListShorthandCombined);
        // self.inputGenesForPathway = $window.sessionStorage.getItem("genes");
        // var inputGenesForPathway = $window.sessionStorage.getItem("genes");
        // //console.log("inputGenes");
        // //console.log(self.inputGenesForPathway);
        // //console.log(inputGenesForPathway);
        //
        //
        // self.makeParallelGrid(self.peptideToModificationList);
        // //console.log(self.geneIdListShorthandCombined);
        // //console.log(self.geneIdListMassCombined);
        // self.inputMassPtmProteins = self.geneIdListMassCombined;

        //$scope.$apply();

    };
    //:dataBase/:proteinForm/:list/:organism'
    //This part is for updating the view based on the URL
    self.listOfPeptidesFromURL = [];
    self.listOfPeptidesFromURL = $routeParams.list;
    // self.proteinDb = $routeParams.dataBase;
    // self.formatFromURL = $routeParams.format;
    // self.proteinForm = $routeParams.proteinForm;


    if ($routeParams.organism == '9606' || $routeParams.organism == '10090' || $routeParams.organism == '10116') {
        self.organismForm = $routeParams.organism;
        SharedService.setVar('organismForm', self.organismForm);
    }

    // if (self.formatFromURL == 'massDifference')
    // {
    //     self.formatInput = false;
    //     SharedService.setVar('formatInput',self.formatInput);
    //
    // }
    // else if ( self.formatFromURL == 'shortHand')
    // {
    //     self.formatInput = true;
    //     SharedService.setVar('formatInput',self.formatInput);
    //
    // }
    //
    // if (typeof self.listOfPeptidesFromURL !== 'undefined' && self.listOfPeptidesFromURL.length > 0 && !self.formatInput)
    // {
    //
    //     self.textAreaFormatMD = self.listOfPeptidesFromURL;
    //
    // }
    // else if (typeof self.listOfPeptidesFromURL !== 'undefined' && self.listOfPeptidesFromURL.length > 0 && self.formatInput)
    // {
    //
    //     self.textAreaFormatSN = self.listOfPeptidesFromURL;
    //
    // }

    if (typeof self.listOfPeptidesFromURL !== 'undefined' && self.listOfPeptidesFromURL.length > 0 )
    {

        self.textArea = self.listOfPeptidesFromURL;

    }


    // //console.log("---------");
    // //console.log($routeParams.tab);
    // //console.log("---------");
    // //console.log("---------");
    //console.log(self.proteinDb);
    //console.log("---------");



    $('input[name=r1][value=' + self.organismForm + ']').prop('checked',true);
    $('input[name=r2][value=' + self.proteinForm + ']').prop('checked',true);
    $('input[name=r3][value=' + self.proteinDb + ']').prop('checked',true);
    $('input[name=r4][value=' + self.peptideNormalizeFlag + ']').prop('checked',true);
    //This is for radio button for index.html
    if (!$("input[name='r1']").is(":checked")) {
        //console.log("checked no");
        $("#homosapiens").prop("checked", true);
    }
    if (!$("input[name='r2']").is(":checked")) {
        //console.log("checked no");
        $("#canonical").prop("checked", true);
    }
    if (!$("input[name='r3']").is(":checked")) {
        //console.log("checked no");
        self.proteinDb = 'sp';
        $("#uniprotSp").prop("checked", true);
    }
    if (!$("input[name='r4']").is(":checked")) {
        //console.log("checked no");
        self.peptideNormalizeFlag = false;
        $("#norm-no").prop("checked", true);
    }
    // $("#homosapiens").prop("checked", true);


    $("input[name='r1']").click(function () {
        self.organismForm = this.value;
        SharedService.setVar('organismForm',self.organismForm);
        //console.log(self.organismForm);
    });

    $("input[name='r2']").click(function () {
        self.proteinForm = this.value;
        SharedService.setVar('proteinForm',self.proteinForm);
        //console.log(self.proteinForm);
    });
    $("input[name='r3']").click(function () {
        self.proteinDb = this.value;
        SharedService.setVar('proteinDb',self.proteinDb);
        //console.log(self.proteinDb);
    });
    $("input[name='r4']").click(function () {
        if (this.value === 'true')
        {
            self.peptideNormalizeFlag = true;
        }
        else{
            self.peptideNormalizeFlag = false;
        }
        //self.peptideNormalizeFlag = this.value;
        SharedService.setVar('peptideNormalizeFlag',self.peptideNormalizeFlag);
        //console.log(self.peptideNormalizeFlag);
    });


    // $scope.$watch(function () {
    //     return self.formatInput
    // }, function (newValue, oldValue) {
    //     if (!self.formatInput) {
    //
    //         self.textArea = self.textAreaFormatMD;
    //         SharedService.setVar("formatInput", self.formatInput);
    //     } else {
    //         self.textArea = self.textAreaFormatSN;
    //         SharedService.setVar("formatInput", self.formatInput);
    //     }
    // });



    $scope.$watch(function () {
        return self.showOutput
    }, function (newValue, oldValue) {
        //localStorage.setItem("showOutputForPeptideToProtein", self.showOutput);
        SharedService.setVar("showOutputForPeptideToProtein", self.showOutput);
    });

    //self.showOutput2 = localStorage.getItem("showOutputForPeptideToProtein");
    // track changes in user input
    trFunc1 = function(text){
        if (self.modificationMapReverse[text.match(self.patt3)]) {

            var text1 = "[" + self.modificationMapReverse[text.match(self.patt3)] + text.match(self.patt1) + "]";
        }
        else {
            var text1 = ""
        };
        //console.log(text1);
        return text1;
    }
    trFunc2 = function(text){
        var text2 = text.match(self.patt1) + "[+" + self.modificationMap[text.match(self.patt2)] + "]";

        //console.log(text2);
        return text2;
    }
    translateSh2Md = function(textArea){
        var translated = textArea;
        while (match = self.modificationPatternWithLetter.exec(textArea)) {
            translated = translated.replace(match[0], trFunc1(match[0]));
            //console.log("Found", match[0], "at", match.index);
        }
        //var translated = textArea.replace(self.modificationPatternWithLetter, trFunc1(self.modificationPatternWithLetter));
        //console.log(translated);
        return translated;
    };
    translateMd2Sh = function(textArea){
        var translated = textArea;
        while (match = self.modificationPatternSecondFormat.exec(textArea)) {
            translated = translated.replace(match[0], trFunc2(match[0]));
            //console.log("Found", match[0], "at", match.index);
        }
        //var translated = textArea.replace(self.modificationPatternSecondFormat, trFunc2(self.modificationPatternSecondFormat));
        // //console.log(translated);
        return translated;
    };
    //
    // $scope.$watch(function () {
    //     return self.textAreaFormatMD
    // }, function (newValue, oldValue) {
    //     if (!self.formatInput) {
    //
    //         self.textArea = self.textAreaFormatMD;
    //
    //     } else {
    //
    //         self.textArea = self.textAreaFormatSH;
    //     }
    // });
    //
    // $scope.$watch(function () {
    //     return self.textAreaFormatSH
    // }, function (newValue, oldValue) {
    //         if (!self.formatInput) {
    //
    //             self.textArea = self.textAreaFormatMD;
    //
    //         } else {
    //
    //             self.textArea = self.textAreaFormatSH;
    //         }
    //     }
    // );

    $scope.$watch(function () {
        return self.textArea
    }, function (newValue, oldValue) {
        //$window.sessionStorage.setItem("textAreaForPeptide2Protein", self.textArea);
        // //console.log("Setting textArea");
        //self.textArea = localStorage.getItem("textAreaForPeptide2Protein");

        SharedService.setVar('textArea', self.textArea);
        // parse motifs
        self.parsedMotifs = self.textArea.replace('"','')
            .split(self.rowSplitPattern)
            .map(function (e) {
                if (e) {
                    return e.replace(/ *\([^)]*\) */g, "").replace(self.modificationPattern, '')
                }
            });

        // parse peptides
        // self.parsedPeptides = self.textArea.replace('"','')
        //     .split(self.rowSplitPattern);

        // //console.log('text area');
        // //console.log(self.textArea);
        self.parsedModifications = self.textArea.replace('"','')
            .split(self.rowSplitPattern)
            .map(function (e) {
                if (e) {
                    var modList = [];
                    //var eMod;
                    while (eMod = self.paranthesesPattern.exec(e))
                    {
                        modList.push(eMod[0]);
                    };
                    while (eMod = self.modificationPatternWithLetter.exec(e))
                    {
                        modList.push(eMod[0]);
                    };
                    while (eMod = self.modificationPatternSecondFormat.exec(e))
                    {
                        modList.push(eMod[0]);
                    };

                    // e.match(self.modificationPatternWithLetter).map(function (eMod) {
                    //     if (eMod) {
                    //         modList.push(eMod);
                    //     }
                    // })
                    // e.match(self.modificationPatternSecondFormat).map(function (eMod) {
                    //     if (eMod) {
                    //         modList.push(eMod);
                    //     }
                    // })

                    // modList.push(e.match(self.modificationPatternWithLetter));
                    // modList.push(e.match(self.modificationPatternSecondFormat));
                    // //if (!self.formatInput) {
                    //     //console.log(e.match(self.modificationPatternWithLetter));
                    //  //   return e.match(self.modificationPatternWithLetter);
                    // //} else {
                    //     //console.log(e.match(self.modificationPatternSecondFormat));
                        return modList ;
                    //}
                }
            });
        var tmpTextArea = self.textArea;

        self.parsedPeptides = self.textArea
            .split(self.rowSplitPattern)
            .map(function (e) {
                if (e) {
                    // var str = e.split(/[\s,]+/).join();
                    // //console.log(str);
                    // var str2 = str.replace(/[\s,]+/g, ',');
                    // //console.log(str2);
                    var str2 = e.replace(/,/g, '').replace(/^\s\s*/, '').replace(/\s\s*$/, '').replace(/[\s,]+/g, ',');
                    ////console.log(str2);
                    if (str2.indexOf(',') > -1) {
                        str2 = str2.split(',').slice(0);
                        ////console.log(str2[0]);
                        return str2[0];
                    }
                    else {
                        // //console.log(str2);
                        return str2;
                    }
                    ;
                }
                //return e.replace(/,/g , '').replace(/^\s\s*/, '').replace(/\s\s*$/, '').replace(/[\s,]+/g, ',');

                // if (e.length() == 1){
                //     return e[1];
                // }
                // if (!self.formatInput) {
                //     return e.match(self.modificationPatternWithLetter);
                // } else {
                //     return e.match(self.modificationPatternSecondFormat);
                // }

            });

        // //console.log("self.textArea");
        // //console.log(self.textArea);
        self.peptideAbundance = self.textArea
            .split(self.rowSplitPattern)
            .map(function (e) {
                if (e) {
                    // var str = e.split(/[\s,]+/).join();
                    // //console.log(str);
                    // var str2 = str.replace(/[\s,]+/g, ',');
                    // //console.log(str2);
                    var str2 = e.replace(/,/g, '').replace(/^\s\s*/, '').replace(/\s\s*$/, '').replace(/[\s,]+/g, ',');
                    ////console.log(str2);
                    if (str2.indexOf(',') > -1) {
                        str2 = str2.split(',').slice(1);

                        return str2[0];
                    }
                    else {
                        return "NA";
                    }
                    ;
                }
                //return e.replace(/,/g , '').replace(/^\s\s*/, '').replace(/\s\s*$/, '').replace(/[\s,]+/g, ',');

                // if (e.length() == 1){
                //     return e[1];
                // }
                // if (!self.formatInput) {
                //     return e.match(self.modificationPatternWithLetter);
                // } else {
                //     return e.match(self.modificationPatternSecondFormat);
                // }

            });

        ////console.log(self.peptideAbundance);
        //self.peptideAbundance = tmpTextArea.replace(/,/g , '').replace(/^\s\s*/, '').replace(/\s\s*$/, '').replace(/[\s,]+/g, ',');

        ////console.log(self.peptideAbundance);
        // format parsed modifiacations
        self.parsedModificationsForOntology = self.parsedModifications;

        self.parsedModificationsFormatter = [];
        self.parsedModificationsFormatter = self.parsedModifications
            .map(function (e) {
                if (e != null)
                    return e.join(" ");
            });


        self.plnFirstHit = [];

        // if (!self.formatInput) {
        //
        //     self.textAreaFormatSH = translateMd2Sh(self.textArea);
        //     SharedService.setVar('textAreaFormatSH', self.textAreaFormatSH);
        // } else {
        //
        //     self.textAreaFormatMD = translateSh2Md(self.textArea);
        //     SharedService.setVar('textAreaFormatMD', self.textAreaFormatMD);
        // }

    });

    //This is for the peptides/proteins/pathwaysa/lincs buttons
    $(document).ready(function () {

        $('#arrowBar1 a').click(function () {

            $('#results1').html("Clicked = " + $(this).attr('href').slice(1));

        });

        $('#arrowBar2 a').click(function () {

            $('#results2').html("Clicked = " + $(this).attr('href').slice(1));
        });
    });


    $(document).ready(function () {
        $("#div1").scroll(function () {
            $("#div2").scrollTop($("#div1").scrollTop());
            $("#div2").scrollLeft($("#div1").scrollLeft());
            $("#div1-2").scrollTop($("#div1").scrollTop());
            $("#div1-2").scrollLeft($("#div1").scrollLeft());
        });
        $("#div1-2").scroll(function () {
            $("#div2").scrollTop($("#div1-2").scrollTop());
            $("#div2").scrollLeft($("#div1-2").scrollLeft());
            $("#div1").scrollTop($("#div1-2").scrollTop());
            $("#div1").scrollLeft($("#div1-2").scrollLeft());
        });
        $("#div2").scroll(function () {
            $("#div1").scrollTop($("#div2").scrollTop());
            $("#div1").scrollLeft($("#div2").scrollLeft());
            $("#div1-2").scrollTop($("#div2").scrollTop());
            $("#div1-2").scrollLeft($("#div2").scrollLeft());
        });

    });

    $(document).ready(function () {
        $("#div3").scroll(function () {
            $("#div4").scrollTop($("#div3").scrollTop());
            $("#div4").scrollLeft($("#div3").scrollLeft());
        });
        $("#div4").scroll(function () {
            $("#div3").scrollTop($("#div4").scrollTop());
            $("#div3").scrollLeft($("#div4").scrollLeft());
        });

    });


    $(document).ready(function () {
        $("#div5").scroll(function () {
            $("#div6").scrollTop($("#div5").scrollTop());
            $("#div6").scrollLeft($("#div5").scrollLeft());
        });
        $("#div6").scroll(function () {
            $("#div5").scrollTop($("#div6").scrollTop());
            $("#div5").scrollLeft($("#div6").scrollLeft());
        });

    });


    $(document).ready(function () {
        $("#div7").scroll(function () {
            $("#div8").scrollTop($("#div7").scrollTop());
            $("#div8").scrollLeft($("#div7").scrollLeft());
        });
        $("#div8").scroll(function () {
            $("#div7").scrollTop($("#div8").scrollTop());
            $("#div7").scrollLeft($("#div8").scrollLeft());
        });

    });

    $(document).ready(function () {
        $("#div9").scroll(function () {
            $("#div10").scrollTop($("#div9").scrollTop());
            $("#div10").scrollLeft($("#div9").scrollLeft());
        });
        $("#div10").scroll(function () {
            $("#div9").scrollTop($("#div10").scrollTop());
            $("#div9").scrollLeft($("#div10").scrollLeft());
        });

    });

    $(document).ready(function () {
        $("#div11").scroll(function () {
            $("#div12").scrollTop($("#div11").scrollTop());
            $("#div12").scrollLeft($("#div11").scrollLeft());
        });
        $("#div12").scroll(function () {
            $("#div11").scrollTop($("#div12").scrollTop());
            $("#div11").scrollLeft($("#div12").scrollLeft());
        });

    });
    // track changes in user input
    // //console.log("self.showSplash");
    // //console.log(self.showSplash);

    $scope.goToPeptideToProtein = function () {
        $location.url("/peptideToProtein");
        self.url = $location.url();
        //console.log($location.url());
    };

    $scope.goToPtmToModifier = function () {
        //$location.url("/ptmToModifier?tab="+self.ptmToModifierPtmOrGene);
        $location.url("/ptmToModifier");
        self.url = $location.url();
        //console.log(self.url);
    };

    $scope.goToProteinToPathway = function () {
        //$location.url("/ptmToModifier?tab="+self.ptmToModifierPtmOrGene);
        $location.url("/proteinToPathway");
        self.url = $location.url();
        //console.log(self.url);
    };

    $scope.goToAbout = function () {
        $location.url("/help");
        self.url = $location.url();
    };



    $scope.goToProteinToPathway = function () {
        $location.url("/proteinToPathway");
        self.url = $location.url();
    };

    $scope.changeSplashAndGoToEnrichment = function (flag) {

        // $http.get("api/increment/" + 0)
        //     .success(function (siteVisit) {
        //         //console.log("siteVisit");
        //         //console.log(siteVisit);
        //         self.siteVisit = siteVisit;
        //         self.showSplash = false;
        //         // //console.log("url");
        //         $location.url("/ptmToModifier");
        //         self.url = $location.url();
        //     })
        //     .error(function (data, status) {
        //
        //         //console.log(data);
        //         //console.log(status);
        //
        //
        //     });
        self.firstVisit = false;
        SharedService.setVar('firstVisit', false);

        self.showSplash = false;
        SharedService.setVar('showSplash', false);
        if (!flag)
        {self.ptmToModifierPtmOrGene = 'geneList'}
        else
        {self.ptmToModifierPtmOrGene = 'ptmProteinList'};

        SharedService.setVar('ptmToModifierPtmOrGene', self.ptmToModifierPtmOrGene);
        // //console.log("url");
        $location.url("/ptmToModifier?tab="+self.ptmToModifierPtmOrGene);
        //$location.url("/ptmToModifier");
        self.url = $location.url();


        // $window.sessionStorage.setItem("genesForProtein2Pathways", self.geneIdList);
        // $window.sessionStorage.setItem("uniprotJsonObjectAllForProtein2Pathways",self.uniprotJsonObjectAll);
        // $window.sessionStorage.setItem("massPtmProteinsForProtein2Pathways", self.geneIdListMassCombined);
        // $window.sessionStorage.setItem("shorthandPtmProteinsForProtein2Pathways", self.geneIdListShorthandCombined);

        // //console.log(self.url);
        // //console.log("self.showSplash3");
        // //console.log(self.showSplash);
    };

    $scope.changeSplashAndGoToProtein = function () {

        $http.get("api/increment/" + 0)
            .success(function (siteVisit) {
                // //console.log("siteVisit");
                // //console.log(self.siteVisit);
                self.siteVisit = siteVisit;
                self.showSplash = false;
                SharedService.setVar('showSplash', false);
                $location.url("/ptmToModifier");
                self.url = $location.url();
                // //console.log("url");

            })
            .error(function (data, status) {

                // //console.log(data);
                // //console.log(status);
                self.showSplash = false;
                SharedService.setVar('showSplash', false);
                self.siteVisit = {"all": "", "peptide": "", "gene": "", "ptm": ""}
                $location.url("/ptmToModifier");
                self.url = $location.url();

            });
        self.firstVisit = false;
        SharedService.setVar('firstVisit', false);
        //$window.sessionStorage.setItem("peptidesForPeptideToProtein", self.textArea);
        // //console.log("self.showSplash2");
        // //console.log(self.showSplash);
    };
    $scope.changeSplashAndGoToAbout = function () {

        $http.get("api/increment/" + 0)
            .success(function (siteVisit) {
                // //console.log("siteVisit");
                // //console.log(self.siteVisit);
                self.siteVisit = siteVisit;
                self.showSplash = false;
                SharedService.setVar('showSplash', false);
                $location.url("/help");
                self.url = $location.url();
                // //console.log("url");

            })
            .error(function (data, status) {

                // //console.log(data);
                // //console.log(status);
                self.showSplash = false;
                SharedService.setVar('showSplash', false);
                self.siteVisit = {"all": "", "peptide": "", "gene": "", "ptm": ""}
                $location.url("/help");
                self.url = $location.url();

            });
        self.firstVisit = false;
        SharedService.setVar('firstVisit', false);
        //$window.sessionStorage.setItem("peptidesForPeptideToProtein", self.textArea);
        // //console.log("self.showSplash2");
        // //console.log(self.showSplash);
    };

    $scope.changeSplashAndGoToPathway = function () {

        $http.get("api/increment/" + 0)
            .success(function (siteVisit) {
                // //console.log("siteVisit");
                // //console.log(self.siteVisit);
                self.siteVisit = siteVisit;
                self.showSplash = false;
                SharedService.setVar('showSplash', false);
                $location.url("/proteinToPathway");
                self.url = $location.url();
                // //console.log("url");

            })
            .error(function (data, status) {

                // //console.log(data);
                // //console.log(status);
                self.showSplash = false;
                SharedService.setVar('showSplash', false);
                self.siteVisit = {"all": "", "peptide": "", "gene": "", "ptm": ""}
                $location.url("/proteinToPathway");
                self.url = $location.url();

            });
        self.firstVisit = false;
        SharedService.setVar('firstVisit', false);
        //$window.sessionStorage.setItem("peptidesForPeptideToProtein", self.textArea);
        // //console.log("self.showSplash2");
        // //console.log(self.showSplash);
    };

    $scope.changeSplashAndGoToPeptide = function () {

        $http.get("api/increment/" + 0)
            .success(function (siteVisit) {
                // //console.log("siteVisit");
                // //console.log(self.siteVisit);
                self.siteVisit = siteVisit;
                self.showSplash = false;
                SharedService.setVar('showSplash', false);
                $location.url("/peptideToProtein");
                self.url = $location.url();
                // //console.log("url");

            })
            .error(function (data, status) {

                // //console.log(data);
                // //console.log(status);
                self.showSplash = false;
                SharedService.setVar('showSplash', false);
                self.siteVisit = {"all": "", "peptide": "", "gene": "", "ptm": ""}
                $location.url("/peptideToProtein");
                self.url = $location.url();

            });
        self.firstVisit = false;
        SharedService.setVar('firstVisit', false);
        //$window.sessionStorage.setItem("peptidesForPeptideToProtein", self.textArea);
        // //console.log("self.showSplash2");
        // //console.log(self.showSplash);
    };
    // //console.log("self.showSplash3");
    // //console.log(self.showSplash);
    // track changes in parsed modifications and refresh psi-mod mapping
    updateModOntology = function(modificationAfterUpdate){
        //return new Promise((resolve) => {

        // //console.log(modificationAfterUpdate);
        self.ontologyMappings = [];
        self.ontologyMappingsUnique = [];
        // distinct = [];
        // firstPrositeResponseFiltered = [];
        // self.plnFormatOne = [];
        // self.plnFormatTwo = [];
        //self.plnFirstHit = [];
        var elMass;
        var elShorthand;
        var originalMAss;


        modificationAfterUpdate.forEach(function (e) {
            if (e != null) {
                e.forEach(function (el) {
                    (function (el) {
                        //if (self.formatInput) {
                        // //console.log('el');
                        // //console.log(el);

                        if(el.toUpperCase().contains('MOD')) {
                            $http.get("api/proteinptm/" + el.substr(1, el.length))
                                .success(function (data) {


                                    // if (el.toUpperCase().contains('UNIMOD')) {
                                    //     var originalMAss = data.averageDeltaMass;
                                    //     $http.get("api/proteinptmbymass/" + originalMAss+"/delta/0.01")
                                    //         .success(function (data) {
                                    //             ////console.log(data);
                                    //
                                    //             var sorted_data = data.sort(function(a, b){
                                    //                 return Math.abs(a.averageDeltaMass-originalMAss) - Math.abs(b.averageDeltaMass-originalMAss);
                                    //             });
                                    //             ////console.log(sorted_data);
                                    //             var closest_sorted = sorted_data[0];
                                    //             ////console.log(closest_sorted);
                                    //             var result = {};
                                    //             result.mass = originalMAss;
                                    //             result.input = el;
                                    //             result.identifier = closest_sorted.accession;
                                    //             result.diffavg = closest_sorted.averageDeltaMass;
                                    //
                                    //             result.description = closest_sorted.description;
                                    //             result.formula = closest_sorted.formula;
                                    //             var similarToPTM = [];
                                    //             sorted_data.forEach(function(element) {
                                    //                 var similarToPTMAll = "{"+ element.accession+"},{"+element.averageDeltaMass +"},{"+ element.formula+"},{"+element.description +"}";
                                    //                 ////console.log(element);
                                    //                 var similarToPTMItem = {};
                                    //                 // similarToPTMItem["identifier"] = element.accession;
                                    //                 similarToPTMItem["descriptionAll"] = similarToPTMAll;
                                    //
                                    //                 similarToPTM.push(similarToPTMItem);
                                    //             });
                                    //             // for (var i = 0; i < sorted_data.length; i++) {
                                    //             //     similarToPTMItem = "{"+ sorted_data.[i].accession+","+sorted_data[i].averageDeltaMass +","+ sorted_data[i].formula+","+sorted_data[i].description +"}";
                                    //             //
                                    //             //     similarToPTM.push(similarToPTMItem);
                                    //             //     //Do something
                                    //             // }
                                    //
                                    //             result.similar = similarToPTM;
                                    //             ////console.log(result);
                                    //
                                    //             if (self.ontologyMappingsUnique.indexOf(el) === -1) {
                                    //                 self.ontologyMappingsUnique.push(el);
                                    //                 self.ontologyMappings.push(result);
                                    //                 ////console.log(result);
                                    //
                                    //             }
                                    //
                                    //             //self.ontologyMappings.push(result);
                                    //
                                    //         })
                                    //         .error(function (data, status) {
                                    //             // //console.log(data);
                                    //             // //console.log(status);
                                    //             var result = {};
                                    //             result.identifier = "";
                                    //             result.mass = "";
                                    //             result.input = el;
                                    //             result.formula = "";
                                    //             result.diffavg = "";
                                    //             result.description = "Error!";
                                    //             result.similar = [];
                                    //
                                    //
                                    //
                                    //
                                    //
                                    //
                                    //             // var result = {};
                                    //             // result.identifier = "";
                                    //             //
                                    //             // result.modification = elMass;
                                    //             // if (self.modificationMapReverse[elMass.match(self.patt3)]) {
                                    //             //     elShorthand = "[" + self.modificationMapReverse[elMass.match(self.patt3)] + elMass.match(self.patt1) + "]";
                                    //             // }
                                    //             // else {
                                    //             //     elShorthand = ""
                                    //             // }
                                    //             // result.shorthand = elShorthand;
                                    //             // result.diffavg = "";
                                    //             // result.description = "Error!";
                                    //             // result.similar = "";
                                    //             //self.ontologyMappings.push(result);
                                    //             if (self.ontologyMappingsUnique.indexOf(el) === -1) {
                                    //                 self.ontologyMappingsUnique.push(el);
                                    //                 self.ontologyMappings.push(result);
                                    //             }
                                    //
                                    //         });
                                    //
                                    // }
                                    // else {
                                        var result = {};
                                        result.input = el;
                                        if (data.length === 0) {
                                            result.identifier = "";
                                            // result.original = data.string;
                                            // result.modification = elMass;
                                            // result.shorthand = shorthandInput;
                                            result.diffavg = "";
                                            result.mass = "";
                                            result.similar = [];
                                            result.formula = "";
                                            result.description = "";

                                        }

                                        result.identifier = data.accession;
                                        result.diffavg = data.averageDeltaMass;
                                        result.mass = data.averageDeltaMass;
                                        result.description = data.description;
                                        result.formula = data.formula;


                                        var similarToPTM = [];

                                        var similarToPTMAll = "{" + data.accession + "},{" + data.averageDeltaMass + "},{" + data.formula + "},{" + data.description + "}";
                                        ////console.log(element);
                                        var similarToPTMItem = {};
                                        // similarToPTMItem["identifier"] = element.accession;
                                        similarToPTMItem["descriptionAll"] = similarToPTMAll;

                                        similarToPTM.push(similarToPTMItem);

                                        // for (var i = 0; i < sorted_data.length; i++) {
                                        //     similarToPTMItem = "{"+ sorted_data.[i].accession+","+sorted_data[i].averageDeltaMass +","+ sorted_data[i].formula+","+sorted_data[i].description +"}";
                                        //
                                        //     similarToPTM.push(similarToPTMItem);
                                        //     //Do something
                                        // }

                                        result.similar = similarToPTM;


                                        if (self.ontologyMappingsUnique.indexOf(el) === -1) {
                                            self.ontologyMappingsUnique.push(el);
                                            self.ontologyMappings.push(result);
                                        }

                                        //self.ontologyMappings.push(result);
                                    //}

                                })
                                .error(function (data, status) {
                                    // //console.log(data);
                                    // //console.log(status);
                                    var result = {};
                                    result.identifier = "";
                                    result.input = el;
                                    result.mass = "";
                                    result.formula = "";
                                    result.diffavg = "";
                                    result.description = "Error!";
                                    result.similar = [];
                                    //self.ontologyMappings.push(result);
                                    if (self.ontologyMappingsUnique.indexOf(el) === -1) {
                                        self.ontologyMappingsUnique.push(el);
                                        self.ontologyMappings.push(result);
                                    }

                                });



                        }
                        else {
                            if (!el.contains('+')) {

                                elMass = el.match(self.patt1) + "[+" + self.modificationMap[el.match(self.patt2)] + "]";
                                // //console.log(el.match(self.patt2));
                                // //console.log(self.modificationMap[el.match(self.patt2)]);
                                originalMAss = self.modificationMap[el.match(self.patt2)];
                                var shorthandInput = el;
                                var originalModFromInput = el;
                                var modificationType = "";
                                var modificationAmino = "";
                                modificationType = self.modificationNameMap[el.match(self.patt2)];
                                modificationAmino = self.modificationAminoMap[el.match(self.patt1)];
                                console.log("---------");
                                console.log("unimod or psimod");
                                console.log(el.match(self.patt2));
                                console.log(modificationType);
                                console.log(el.match(self.patt1));
                                console.log(modificationAmino);

                                console.log(shorthandInput);
                                console.log(originalModFromInput);
                                console.log(originalMAss);
                                console.log(elMass);
                                (function (modificationType, modificationAmino, originalModFromInput) {
                                    $http.get("api/proteinptmbydescription/" + modificationType)
                                        .success(function (res_data) {
                                            console.log("api/proteinptmbydescription/" + modificationType);
                                            console.log("res_data");
                                            console.log(res_data);
                                            var data = [];
                                            for(var i = 0; i < res_data.length; i++) {
                                                var obj = res_data[i];
                                                if (obj["description"].includes(modificationAmino) ||
                                                    obj["name"].includes(modificationAmino) ||
                                                    obj["shortName"].includes(modificationAmino)
                                                ){
                                                    data.push(obj);
                                                }

                                            }
                                            console.log("data:");
                                            console.log(data);
                                            //var data = res_data;

                                            var sorted_data = data.sort(function (a, b) {
                                                return Math.abs(b.averageDeltaMass - originalMAss) - Math.abs(a.averageDeltaMass - originalMAss);
                                            });
                                            ////console.log(sorted_data);
                                            var closest_sorted = sorted_data[0];
                                            ////console.log(closest_sorted);
                                            var result = {};
                                            result.mass = originalMAss;
                                            result.input = el;
                                            result.identifier = closest_sorted.accession;
                                            result.diffavg = closest_sorted.averageDeltaMass;

                                            result.description = closest_sorted.description;
                                            result.formula = closest_sorted.formula;
                                            var similarToPTM = [];
                                            sorted_data.forEach(function (element) {
                                                var similarToPTMAll = "{" + element.accession + "},{" + element.averageDeltaMass + "},{" + element.formula + "},{" + element.description + "}";
                                                ////console.log(element);
                                                var similarToPTMItem = {};
                                                // similarToPTMItem["identifier"] = element.accession;
                                                similarToPTMItem["descriptionAll"] = similarToPTMAll;

                                                similarToPTM.push(similarToPTMItem);
                                            });
                                            // for (var i = 0; i < sorted_data.length; i++) {
                                            //     similarToPTMItem = "{"+ sorted_data.[i].accession+","+sorted_data[i].averageDeltaMass +","+ sorted_data[i].formula+","+sorted_data[i].description +"}";
                                            //
                                            //     similarToPTM.push(similarToPTMItem);
                                            //     //Do something
                                            // }

                                            result.similar = similarToPTM;
                                            ////console.log(result);

                                            if (self.ontologyMappingsUnique.indexOf(el) === -1) {
                                                self.ontologyMappingsUnique.push(el);
                                                self.ontologyMappings.push(result);
                                                //console.log(result);

                                            }

                                            //self.ontologyMappings.push(result);

                                        })
                                        .error(function (data, status) {
                                            // //console.log(data);
                                            // //console.log(status);
                                            var result = {};
                                            result.identifier = "";
                                            result.input = el;
                                            result.formula = "";
                                            result.diffavg = "";
                                            result.description = "Error!";
                                            result.similar = [];


                                            // var result = {};
                                            // result.identifier = "";
                                            //
                                            // result.modification = elMass;
                                            // if (self.modificationMapReverse[elMass.match(self.patt3)]) {
                                            //     elShorthand = "[" + self.modificationMapReverse[elMass.match(self.patt3)] + elMass.match(self.patt1) + "]";
                                            // }
                                            // else {
                                            //     elShorthand = ""
                                            // }
                                            // result.shorthand = elShorthand;
                                            // result.diffavg = "";
                                            // result.description = "Error!";
                                            // result.similar = "";
                                            //self.ontologyMappings.push(result);
                                            if (self.ontologyMappingsUnique.indexOf(el) === -1) {
                                                self.ontologyMappingsUnique.push(el);
                                                self.ontologyMappings.push(result);
                                            }

                                        });
                                }(modificationType, modificationAmino, originalModFromInput));
                            } else {

                                elMass = el;
                                var originalModFromInput = el;

                                var shorthandInput = '';
                                var originalMAss = el.replace(/[a-zA-Z+\[\]']/g, '');
                                console.log("---------");
                                console.log("+++++++");
                                console.log(shorthandInput);
                                console.log(originalModFromInput);
                                console.log(originalMAss);
                                console.log(elMass);
                                console.log(originalMAss);
                                (function (originalMAss, shorthandInput, originalModFromInput) {
                                    $http.get("api/proteinptmbymass/" + originalMAss + "/delta/0.001")
                                        .success(function (data) {
                                            console.log("api/proteinptmbymass/"+ originalMAss + "/delta/0.001");
                                            console.log("data:");
                                            console.log(data);

                                            var sorted_data = data.sort(function (a, b) {
                                                return Math.abs(b.averageDeltaMass - originalMAss) - Math.abs(a.averageDeltaMass - originalMAss);
                                            });
                                            ////console.log(sorted_data);
                                            var closest_sorted = sorted_data[0];
                                            console.log(closest_sorted);
                                            var result = {};
                                            result.mass = originalMAss;
                                            result.input = el;
                                            result.identifier = closest_sorted.accession;
                                            result.diffavg = closest_sorted.averageDeltaMass;

                                            result.description = closest_sorted.description;
                                            result.formula = closest_sorted.formula;
                                            var similarToPTM = [];
                                            sorted_data.forEach(function (element) {
                                                var similarToPTMAll = "{" + element.accession + "},{" + element.averageDeltaMass + "},{" + element.formula + "},{" + element.description + "}";
                                                ////console.log(element);
                                                var similarToPTMItem = {};
                                                // similarToPTMItem["identifier"] = element.accession;
                                                similarToPTMItem["descriptionAll"] = similarToPTMAll;

                                                similarToPTM.push(similarToPTMItem);
                                            });
                                            // for (var i = 0; i < sorted_data.length; i++) {
                                            //     similarToPTMItem = "{"+ sorted_data.[i].accession+","+sorted_data[i].averageDeltaMass +","+ sorted_data[i].formula+","+sorted_data[i].description +"}";
                                            //
                                            //     similarToPTM.push(similarToPTMItem);
                                            //     //Do something
                                            // }

                                            result.similar = similarToPTM;
                                            ////console.log(result);

                                            if (self.ontologyMappingsUnique.indexOf(el) === -1) {
                                                self.ontologyMappingsUnique.push(el);
                                                self.ontologyMappings.push(result);
                                                // //console.log(result);

                                            }

                                            //self.ontologyMappings.push(result);

                                        })
                                        .error(function (data, status) {
                                            // //console.log(data);
                                            // //console.log(status);
                                            var result = {};
                                            result.identifier = "";
                                            result.input = el;
                                            result.formula = "";
                                            result.diffavg = "";
                                            result.description = "Error!";
                                            result.similar = [];


                                            // var result = {};
                                            // result.identifier = "";
                                            //
                                            // result.modification = elMass;
                                            // if (self.modificationMapReverse[elMass.match(self.patt3)]) {
                                            //     elShorthand = "[" + self.modificationMapReverse[elMass.match(self.patt3)] + elMass.match(self.patt1) + "]";
                                            // }
                                            // else {
                                            //     elShorthand = ""
                                            // }
                                            // result.shorthand = elShorthand;
                                            // result.diffavg = "";
                                            // result.description = "Error!";
                                            // result.similar = "";
                                            //self.ontologyMappings.push(result);
                                            if (self.ontologyMappingsUnique.indexOf(el) === -1) {
                                                self.ontologyMappingsUnique.push(el);
                                                self.ontologyMappings.push(result);
                                            }

                                        });
                                }(originalMAss, shorthandInput, originalModFromInput));

                            }


                        }
                    }(el));
                })
            }
            // //console.log(self.ontologyMappings);
        });

    //     resolve();
    // });
    }

    $scope.$watch(function () {
        return self.parsedModifications
    }, function (nV, oV) {
        updateModOntology(self.parsedModifications);


    })


    self.onSubmit = function () {
        self.showOutputex1orex2 = "ex1Id";
        SharedService.setVar("showOutputex1orex2",self.showOutputex1orex2);
        self.progressPercent = 0;
        d3.selectAll("svg > *").remove();
        self.showPLN = false;
        self.showOverAllParallelSVG = false;
        // //console.log("test logging");
        // //console.log("psi-mod");
        // //console.log(self.ontologyMappings);
        self.showPhosphoGeneNetwork = false;
        SharedService.setVar('showPhosphoGeneNetwork', self.showPhosphoGeneNetwork);
        self.showOutputPathway = false;
        SharedService.setVar('showOutputPathway', self.showOutputPathway);
        self.showInstruction = false;
        self.waiting = true;
        self.showOutput = false;
        self.showUpload = false;
        self.sequence_acList = [];
        self.geneIdList = [];
        self.geneIdListPhosphorylation = [];
        self.geneIdListShorthandCombined = [];
        self.geneIdListMassCombined = [];
        self.geneIdListAcetylations = [];
        self.geneIdListMethylation = [];
        self.sequence_acListComplete = [];
        self.numResponsesFromProsite = 0;
        self.numResponsesFromUniprot = 0;
        self.responseRaw = [];
        self.responseRawLocal = [];
        self.prResponseList = [];
        self.prResponseJson = {};
        self.uniprotJsonObjectAll = {};
        self.uniprotResponseRaw = [];
        self.uniprotResponseRawJson = [];
        var prositeHttpResponse = [];
        self.uniprotQueryList = [];
        self.motifLength = self.parsedMotifs.length;
        self.uniprotFound = " ";
        self.uniprotFoundNum = 0;
        self.prositeFound = " ";
        self.prositeFoundNum = 0;
        self.uniprotLength = 0;
        self.showOverAllParallelSVG = false;

        self.subCellularTableData = [];
        self.subCellularValues = [];
        self.subCellularLabels = [];

        self.reactomeTableData = [];
        self.reactomeValues = [];
        self.reactomeLabels = [];

        self.goTableData = [];
        self.goLabels = [];
        self.goValues = [];

        self.go_dic = {};
        self.reactome_dic = {};
        self.subcellular_location_dic = {};
        //Capturing response from the prosite api
        var urlProsite = 'api/prosite2/';
        var urlPir = 'api/pir/';
        var urlPeptide = 'api/peptide/organism/';
        var urlUniprot = 'api/uniprot/organism/';
        var useProsite = false;
        // //console.log(" in onsubmit --------------------------------------------------------");
        // //console.log(self.parsedMotifs);
        // //console.log(self.parsedPeptides);
        d3.select("svg").remove();

        //d3.selectAll("svg > *").remove();

        $http.get("api/increment/" + 1)
            .success(function (siteVisit) {

                self.siteVisit = siteVisit;

            })
            .error(function (data, status) {

                self.siteVisit = {"all": "", "peptide": "", "gene": "", "ptm": ""}

            });

        var prositeResponseIterator = 0;
        self.uniprotResponseIteratorTotal = 0;
        self.uniprotResponseIterator = 0;
        if (!useProsite) {
            //Not using prosite for the peptide search
            (function (localMotifs, localPeptides) {
                // //console.log("localMotifs");
                // //console.log(localMotifs);
                // //console.log("localPeptides");
                // //console.log(localPeptides);
                // //console.log("organismForm");
                // //console.log(self.organismForm);
                // //console.log("proteinForm");
                // //console.log(self.proteinForm);
                self.showOutput = true;
                $http({
                    method: 'GET',
                    url: urlPeptide + self.organismForm + self.proteinForm + "/peptides/" + localMotifs,
                    //withCredentials : true,
                    //headers: URLobj.headers,
                    timeout: 1000 * 60 * 2
                }).success(
                    function (dataForAll) {


                        //var str = "{ hello: 'world', places: ['Africa', 'America', 'Asia', 'Australia'] }"
                        //data = JSON.stringify(eval('(' + dataStr.toString() + ')'));
                        //var data = JSON.stringify(eval("(" + data2 + ")"));


                        //console.log("api/peptide success!");

                        //Assume that 20 percent is done!
                        self.showOutput = true;
                        self.progressPercent = 20;

                        // //console.log(dataForAll);
                        // //console.log(self.proteinDb);
                        self.uniprotResponseIteratorTotalForPercentage = 0;
                        self.uniprotResponseIteratorTotal = 0;

                        //Handling the Trembl and Swissprot

                        if (self.proteinDb === 'sp') {
                            var dataForAllModified = {};
                            for (var key in dataForAll) {
                                if (dataForAll.hasOwnProperty(key)) {
                                    ////console.log(key + " -> " + dataForAll[key]);
                                    var n_matchModified = 0;
                                    var matchsetModified = [];
                                    dataForAll[key].matchset.map(function (e2) {
                                        if (e2.sequence_db == 'sp') {
                                            matchsetModified.push(e2);
                                            n_matchModified = n_matchModified + 1;
                                        }
                                    })

                                    var valueModified = {};
                                    valueModified['n_match'] = n_matchModified;
                                    valueModified['matchset'] = matchsetModified;
                                    dataForAllModified[key] = valueModified;
                                }
                            }
                            dataForAll = dataForAllModified;
                        }

                        if (self.proteinDb == 'tr') {
                            var dataForAllModified = {};
                            for (var key in dataForAll) {
                                if (dataForAll.hasOwnProperty(key)) {
                                    ////console.log(key + " -> " + dataForAll[key]);
                                    var n_matchModified = 0;
                                    var matchsetModified = [];
                                    dataForAll[key].matchset.map(function (e2) {
                                        if (e2.sequence_db == 'tr') {
                                            matchsetModified.push(e2);
                                            n_matchModified = n_matchModified + 1;
                                        }
                                    })

                                    var valueModified = {};
                                    valueModified['n_match'] = n_matchModified;
                                    valueModified['matchset'] = matchsetModified;
                                    dataForAllModified[key] = valueModified;
                                }
                            }
                            dataForAll = dataForAllModified;
                        }
                        // //console.log("dataForAllModified");
                        // //console.log(dataForAllModified);
                        // self.uniprotResponseIterator = 0;
                        for (var localPeptideIterator = 0; localPeptideIterator < localMotifs.length; localPeptideIterator++) {

                            var localMotif = localMotifs[localPeptideIterator];
                            // //console.log(localPeptideIterator);
                            // //console.log(localMotif);
                            // //console.log(dataForAll[localMotif]);
                            self.uniprotResponseIteratorTotalForPercentage += dataForAll[localMotif].n_match;
                            //self.uniprotResponseIteratorTotal += dataForAll[localMotif].n_match;
                        }
                        // //console.log("self.uniprotResponseIteratorTotalForPercentage");
                        // //console.log(self.uniprotResponseIteratorTotalForPercentage);
                        for (localPeptideIterator = 0; localPeptideIterator < localMotifs.length; localPeptideIterator++) {

                            self.responseRawLocal = [];
                            var localMotif = self.parsedMotifs[localPeptideIterator];
                            var localPeptide = self.parsedPeptides[localPeptideIterator];
                            ////console.log(localMotif);
                            var data = dataForAll[localMotif];
                            ////console.log(data);

                            var matchset = data.matchset;
                            ////console.log(matchset);

                            var nMatch = data.n_match;
                            self.uniprotResponseIteratorTotal += nMatch;
                            if (nMatch >= 0) {
                                self.prositeFoundNum = self.prositeFoundNum + 1;
                                self.prositeFound = localPeptide;
                                // self.progressPercent = 1.0 * self.prositeFoundNum / self.motifLength * 95.0;
                                // self.getPercentage = function () {
                                //     //console.log(self.prositeFoundNum);
                                //     //console.log(self.motifLength);
                                //     return (Math.round(self.prositeFoundNum / self.motifLength * 95.0));
                            }
                            //
                            //     //document.getElementById("progress").style.width = self.progressPercent + "px";
                            //     self.prositeFound = localPeptide;
                            //
                            // }

                            matchset.map(function (e) {
                                e.motif = localMotif;
                                e.peptide = localPeptide;
                                return e;
                            });
                            self.numResponsesFromProsite++;
                            var flagFound = 1;
                            if (nMatch === 0) {
                                flagFound = 0;

                                self.responseRawLocal = self.responseRawLocal.concat([
                                    {
                                        "motif": localMotif,
                                        "peptide": localPeptide,
                                        "sequence_ac": "",
                                        "sequence_id": "",
                                        "sequence_db": "Not found in canonical uniprot data base!",
                                        "start": "",
                                        "stop": "",
                                        "signature_ac": ""
                                    }]);
                            }
                            else {
                                self.responseRawLocal = self.responseRawLocal.concat(matchset);
                            }

                            self.responseRaw = self.responseRaw.concat(self.responseRawLocal);

                            self.prResponseJson = {
                                "motif": localMotif,
                                "peptide": localPeptide,
                                "length": self.responseRawLocal.length,
                                "response": self.responseRawLocal
                            }
                            self.prResponseList = self.prResponseList.concat(self.prResponseJson);

                            prositeResponseIterator = 0;
                            if (flagFound === 0) {


                                if (self.numResponsesFromProsite >= self.parsedMotifs.length && self.uniprotResponseIterator >= self.uniprotResponseIteratorTotal) {

                                    self.showOutput = true;
                                    self.waiting = false;
                                    // //console.log("Before updating pln! ");
                                    //
                                    // //console.log("--------------");
                                    // //console.log("uniprotResponseIterator");
                                    // //console.log(self.uniprotResponseIterator);
                                    // //console.log("uniprotResponseIteratorTotal");
                                    // //console.log(self.uniprotResponseIteratorTotal);
                                    //
                                    // //console.log("numResponsesFromProsite");
                                    // //console.log(self.numResponsesFromProsite);
                                    // //console.log("parsedMotifs.length");
                                    // //console.log(self.parsedMotifs.length);

                                    self.updatePln(self.peptideNormalizeFlag, self.parsedMotifs, self.textArea, self.responseRaw, self.proteinMap, self.parsedMotifs, self.parsedPeptides, self.peptideAbundance, self.sequence_acListComplete);

                                }
                            }
                            // var nMatchIterator = 0;
                            if (flagFound === 1) {

                                while (prositeResponseIterator < self.responseRawLocal.length) {


                                    var uniprotQuery = self.responseRawLocal[prositeResponseIterator].sequence_ac;

                                    if (!self.uniprotJsonObjectAll.hasOwnProperty(uniprotQuery)) {
                                        self.uniprotJsonObjectAll[uniprotQuery] = [];
                                        self.uniprotLength = self.uniprotLength + 1;
                                    }
                                    var startMotif = self.responseRawLocal[prositeResponseIterator].start;
                                    var stopMotif = self.responseRawLocal[prositeResponseIterator].stop;
                                    var motifMotif = self.responseRawLocal[prositeResponseIterator].motif;
                                    var motifPeptide = self.responseRawLocal[prositeResponseIterator].peptide;


                                    // if (self.sequence_acList.indexOf(uniprotQuery) === -1) {
                                    //     self.sequence_acList.push(uniprotQuery);
                                    //     ////console.log("sequence_acList: " + self.sequence_acList);
                                    //     var sequence_acListMember = {
                                    //         "id": self.sequence_acList.length,
                                    //         "name": uniprotQuery,
                                    //         "length": 1,
                                    //         "members": emptyList
                                    //     };
                                    //     self.sequence_acListComplete = self.sequence_acListComplete.concat(sequence_acListMember);

                                    //     protPlace = self.sequence_acList.length - 1;
                                    //     self.uniprotLength = self.sequence_acList.length;
                                    //     //console.log("sequence_acListComplete");
                                    //     //console.log(self.sequence_acListComplete);
                                    // }
                                    // else {
                                    //     for (var prot = 0; prot < self.sequence_acListComplete.length; prot++) {
                                    //         if (uniprotQuery === self.sequence_acListComplete[prot].name) {
                                    //             protPlace = prot;
                                    //             ////console.log("Adding a member to" + uniprotQuery);
                                    //             self.sequence_acListComplete[prot].length = self.sequence_acListComplete[prot].length + 1;
                                    //             prot = self.sequence_acListComplete.length;
                                    //         }
                                    //     }
                                    // }

                                    // //console.log("self.sequence_acListComplete");
                                    // //console.log(self.sequence_acListComplete);

                                    var uniprotQueryMember = {
                                        "uniprotQuery": uniprotQuery,
                                        "startMotif": startMotif,
                                        "stopMotif": stopMotif,
                                        "motifMotif": motifMotif,
                                        "motifPeptide": motifPeptide
                                        //"protPlace" : protPlace
                                    };


                                    self.uniprotJsonObjectAll[uniprotQuery].push(uniprotQueryMember);


                                    //self.uniprotQueryList.push(uniprotQueryMember);
                                    //nMatchIterator++;
                                    prositeResponseIterator++;


                                }


                            }


                            // //console.log("self.uniprotJsonObjectAll");
                            // //console.log(self.uniprotJsonObjectAll);

                        }//End of loop over peptides


                        (function (uniprotJsonObjectAll) {

                            var protPlaceVariable = 0;
                            self.uniprotResponseIterator = 0;
                            // //console.log("*************************");
                            // //console.log("*************************");
                            // //console.log("*************************");
                            // //console.log("uniprotJsonObjectAll");
                            // //console.log(uniprotJsonObjectAll);
                            // //console.log("self.uniprotResponseIteratorTotal");
                            // //console.log(self.uniprotResponseIteratorTotal);


                            for (var key in uniprotJsonObjectAll) {
                                if (uniprotJsonObjectAll.hasOwnProperty(key)) {

                                    // //console.log(key + " -> " + uniprotJsonObjectAll[key]);
                                    var emptyList = [];
                                    var valueOfUniprotJsonObjecItem = uniprotJsonObjectAll[key];
                                    uniprotQuery = key;

                                    var sequence_acListMember = {

                                        "name": uniprotQuery,
                                        "length": valueOfUniprotJsonObjecItem.length,
                                        "members": emptyList
                                    };
                                    self.sequence_acListComplete = self.sequence_acListComplete.concat(sequence_acListMember);


                                    (function (uniprotIdForInsideQuery, valueOfUniprotJsonObjecItemForInsideQuery, protPlaceVar) {

                                        // $http.get(urlUniprot + self.organismForm + "/uniprot/" + uniprotIdForInsideQuery)
                                        $http.get("api/uniprotdb/organism/" + self.organismForm + "/accession/" + uniprotIdForInsideQuery)

                                            .success(function (data) {

                                                var uniprotJsonObject = data;
                                                if ("reactome" in uniprotJsonObject)
                                                {
                                                    var uniprotReactome = uniprotJsonObject["reactome"];
                                                    for(var i = 0; i < uniprotReactome.length; i++) {
                                                        var reactId = uniprotReactome[i]["id"];
                                                        var reactValue = uniprotReactome[i]["value"];
                                                        if (!(reactId in self.reactome_dic))
                                                        {
                                                            self.reactome_dic[reactId] = {"value":reactValue,"num":1, proteins:[uniprotIdForInsideQuery]};
                                                        }
                                                        else{
                                                            self.reactome_dic[reactId]["num"] += 1;
                                                            if(self.reactome_dic[reactId]["proteins"].indexOf(uniprotIdForInsideQuery) === -1){
                                                                self.reactome_dic[reactId]["proteins"].push(uniprotIdForInsideQuery);
                                                            }
                                                        }

                                                        ////console.log(obj.id);
                                                    }
                                                }

                                                if ("go" in uniprotJsonObject)
                                                {
                                                    var uniprotGo = uniprotJsonObject["go"];
                                                    for(var i = 0; i < uniprotGo.length; i++) {
                                                        var goId = uniprotGo[i]["id"];
                                                        var goValue = uniprotGo[i]["value"];
                                                        if (!(goId in self.go_dic))
                                                        {
                                                            self.go_dic[goId] = {"value":goValue,"num":1, proteins:[uniprotIdForInsideQuery]};
                                                        }
                                                        else{
                                                            self.go_dic[goId]["num"] += 1;
                                                            if(self.go_dic[goId]["proteins"].indexOf(uniprotIdForInsideQuery) === -1){
                                                                self.go_dic[goId]["proteins"].push(uniprotIdForInsideQuery);
                                                            }
                                                        }

                                                        ////console.log(obj.id);
                                                    }
                                                }

                                                if ("subcellular_location" in uniprotJsonObject)
                                                {
                                                    var uniprotSubCellular = uniprotJsonObject["subcellular_location"];
                                                    for(var i = 0; i < uniprotSubCellular.length; i++) {
                                                        var subCellularId = uniprotSubCellular[i];

                                                        if (!(subCellularId in self.subcellular_location_dic))
                                                        {
                                                            self.subcellular_location_dic[subCellularId] = {"num":1, proteins:[uniprotIdForInsideQuery]};
                                                        }
                                                        else{
                                                            self.subcellular_location_dic[subCellularId]["num"] += 1;
                                                            if(self.subcellular_location_dic[subCellularId]["proteins"].indexOf(uniprotIdForInsideQuery) === -1){
                                                                self.subcellular_location_dic[subCellularId]["proteins"].push(uniprotIdForInsideQuery);
                                                            }
                                                        }

                                                        ////console.log(obj.id);
                                                    }
                                                }
                                                //
                                                // var uniprotGo = uniprotJsonObject["go"];
                                                // var uniprotSubcellular_location = uniprotJsonObject["subcellular_location"];
                                                //
                                                // var uniprotReactomeParsed = uniprotJsonObject["reactome"];
                                                // var uniprotGoParsed = uniprotJsonObject["go"];
                                                // var uniprotSubcellular_locationParsed = uniprotJsonObject["subcellular_location"];
                                                // self.go_dic = {};
                                                // self.reactome_dic = {};
                                                // self.subcellular_location_dic = {};



                                                // self.goTableData =[{"id":"gc1","value":"cc1","percent":14},
                                                //     {"id":"gc2","value":"cc2","percent":14},
                                                //     {"id":"gc4","value":"cc4","percent":14},
                                                //     {"id":"gc5","value":"cc5","percent":14},
                                                //     {"id":"gc6","value":"cc6","percent":14},
                                                //     {"id":"gc3","value":"cc3","percent":14}];
                                                // self.goLabels = ['gEuropean Union', 'gRussian Federation', 'gBrazil', 'gIndia', 'gRest of World' ];
                                                // self.goValues = [43, 6, 5, 4.333, 41.666];
                                                // uniprotJsonObject["go"]
                                                // uniprotJsonObject["reactome"]
                                                // uniprotJsonObject["subcellular_location"]
                                                self.uniprotJsonObjectAll[uniprotIdForInsideQuery] = uniprotJsonObject;

                                                self.uniprotFound = uniprotIdForInsideQuery;
                                                if (self.uniprotFoundNum < self.uniprotLength) {
                                                    self.uniprotFoundNum = self.uniprotFoundNum + 1;
                                                }
                                                ;
                                                self.showOutput = true;
                                                // //console.log(uniprotIdForInsideQuery);
                                                // //console.log(data);


                                                // //console.log("Uniprot Response");
                                                // //console.log(uniprotJsonObject);
                                                //Defining uniprot to gene map

                                                var valueOfGeneId = uniprotJsonObject.primary_gene_name;
                                                // //console.log(valueOfGeneId);
                                                // //console.log(uniprotJsonObject.primary_gene_name);
                                                // //console.log(uniprotJsonObject["primary_gene_name"]);
                                                // //console.log("-------------");
                                                //Some times TREMBL proteins don't match any genes!!!!!


                                                if (valueOfGeneId){
                                                    if (valueOfGeneId.length == 0) {
                                                        valueOfGeneId = ['NA'];
                                                    }
                                                }
                                                else{
                                                    valueOfGeneId = ['NA'];
                                                }
                                                // //console.log("valueOfGeneId");
                                                // //console.log(valueOfGeneId);
                                                self.proteinMap[uniprotIdForInsideQuery] = valueOfGeneId;


                                                //var geneId = uniprotJsonObject.primary_gene_name;
                                                for (var geneIdIter = 0; geneIdIter < valueOfGeneId.length; geneIdIter++) {
                                                    if (self.geneIdList.indexOf(valueOfGeneId[geneIdIter]) === -1 && valueOfGeneId[geneIdIter] != 'NA') {
                                                        self.geneIdList.push(valueOfGeneId[geneIdIter]);
                                                        self.genes = self.geneIdList;
                                                        // //console.log("self.genes ");
                                                        // //console.log(self.genes );
                                                    }

                                                }


                                                // self.uniprotResponseIterator += 1;
                                                // //console.log(self.uniprotResponseIterator);
                                                // //console.log(self.uniprotResponseIteratorTotalForPercentage);
                                                for (var valueIter = 0; valueIter < valueOfUniprotJsonObjecItemForInsideQuery.length; valueIter++) {
                                                    var uniprotJsonObjectTmp = {};
                                                    var valueItem = valueOfUniprotJsonObjecItemForInsideQuery[valueIter];
                                                    // //console.log("uniprotIdForInsideQuery");
                                                    // //console.log(uniprotIdForInsideQuery);
                                                    // //console.log("valueItem");
                                                    // //console.log(valueItem);

                                                    var uniprotQueryItem = valueItem.uniprotQuery;
                                                    var startMotifItem = valueItem.startMotif;
                                                    var stopMotifItem = valueItem.stopMotif;
                                                    var motifMotifItem = valueItem.motifMotif;
                                                    var motifPeptideItem = valueItem.motifPeptide;


                                                    //Each uniprot query adds one portion from 20 percent to 99 percent
                                                    self.progressPercent += 79 / self.uniprotResponseIteratorTotalForPercentage;
                                                    // //console.log(self.progressPercent);


                                                    // //console.log(self.responseRaw[prositeResponseIterator].stop);
                                                    uniprotJsonObjectTmp["start"] = startMotifItem;
                                                    uniprotJsonObjectTmp["stop"] = stopMotifItem;
                                                    uniprotJsonObjectTmp["motif"] = motifMotifItem;
                                                    uniprotJsonObjectTmp["peptide"] = motifPeptideItem;
                                                    uniprotJsonObjectTmp["sequence_ac"] = uniprotQueryItem;
                                                    uniprotJsonObjectTmp["length"] = uniprotJsonObject.length;
                                                    uniprotJsonObjectTmp["sequence"] = uniprotJsonObject.sequence;
                                                    uniprotJsonObjectTmp["primary_gene_name"] = uniprotJsonObject.primary_gene_name;

                                                    //returnVar.concat(uniprotJsonObject);
                                                    // //console.log("uniprotJsonObject");
                                                    // //console.log(uniprotJsonObject);

                                                    // data.matchset.map(function (e) {
                                                    //     e.motif = localMotif;
                                                    //     return e;
                                                    // });
                                                    //+++++++++++++++++++++++++++++++++++++++++++++++++++
                                                    //var matchset = data.matchset;
                                                    //self.uniprotResponseRaw = self.uniprotResponseRaw.concat(uniprotJsonObject.toString());
                                                    // //console.log("self.sequence_acListCompleteBefore");
                                                    // //console.log(self.sequence_acListComplete);
                                                    // //console.log(protPlaceVar);
                                                    ////console.log(self.sequence_acListComplete[protPlaceVar].members);
                                                    //self.uniprotJsonObjectAll[uniprotQuery].push(uniprotQueryMember);

                                                    self.sequence_acListComplete[protPlaceVar].members = self.sequence_acListComplete[protPlaceVar].members.concat(uniprotJsonObjectTmp);

                                                    //self.sequence_acListComplete[protPlaceVar].members.push(uniprotJsonObject);
                                                    // //console.log("self.sequence_acListComplete[protPlaceVar].members");
                                                    // //console.log(self.sequence_acListComplete[protPlaceVar].members);
                                                    // //console.log("---------------------------------");
                                                    // //console.log("protPlace: " + protPlace);
                                                    ////console.log("sequence_acListComplete.name: " + self.sequence_acListComplete[protPlace].name);
                                                    // //console.log("sequence_acListComplete2.length: " + self.sequence_acListComplete[protPlace].length);
                                                    // //console.log("sequence_acListComplete3.members: " + self.sequence_acListComplete[protPlace].members);
                                                    // for(var foo = 0; foo < self.sequence_acListComplete[protPlace].members.length; foo++)
                                                    // {
                                                    //     //console.log("foo   "+ foo);
                                                    //     //console.log(self.sequence_acListComplete[protPlace].members[foo].sequence_ac);
                                                    //     //console.log(self.sequence_acListComplete[protPlace].members[foo].motif);
                                                    //
                                                    // }

                                                    //self.uniprotResponseRaw = self.uniprotResponseRaw.concat(uniprotJsonObject);


                                                    //self.uniprotResponseRaw = self.uniprotResponseRaw.concat(JSON.stringify(data));

                                                    ////console.log("ResponseRaw: " + self.responseRaw);

                                                    // //console.log("--------------");
                                                    // //console.log("uniprotResponseIterator");
                                                    // //console.log(self.uniprotResponseIterator);
                                                    // //console.log("uniprotResponseIteratorTotal");
                                                    // //console.log(self.uniprotResponseIteratorTotal);
                                                    //
                                                    // //console.log("numResponsesFromProsite");
                                                    // //console.log(self.numResponsesFromProsite);
                                                    // //console.log("parsedMotifs.length");
                                                    // //console.log(self.parsedMotifs.length);


                                                    // //console.log(self.uniprotResponseIterator);
                                                    // //console.log(self.responseRawLocal.length);
                                                    // //console.log(self.numResponsesFromProsite);
                                                    // //console.log(self.parsedMotifs.length);
                                                    self.uniprotResponseIterator++;
                                                    // //console.log("self.uniprotResponseIterator");
                                                    // //console.log(self.uniprotResponseIterator);
                                                    // //console.log(self.sequence_acListComplete);
                                                    // //console.log("++++++++++++++++++++++++++++");
                                                    if (self.numResponsesFromProsite >= self.parsedMotifs.length && self.uniprotResponseIterator >= self.uniprotResponseIteratorTotal) {

                                                        self.showOutput = true;
                                                        self.waiting = false;
                                                        //console.log("Before updating pln! ");

                                                        // //console.log("--------------");
                                                        // //console.log("uniprotResponseIterator");
                                                        // //console.log(self.uniprotResponseIterator);
                                                        // //console.log("uniprotResponseIteratorTotal");
                                                        // //console.log(self.uniprotResponseIteratorTotal);
                                                        //
                                                        // //console.log("numResponsesFromProsite");
                                                        // //console.log(self.numResponsesFromProsite);
                                                        // //console.log("parsedMotifs.length");
                                                        // //console.log(self.parsedMotifs.length);
                                                        // //console.log("self.sequence_acListComplete");
                                                        // //console.log(self.sequence_acListComplete);
                                                        self.updatePln(self.peptideNormalizeFlag, self.parsedMotifs, self.textArea, self.responseRaw, self.proteinMap, self.parsedMotifs, self.parsedPeptides, self.peptideAbundance, self.sequence_acListComplete);

                                                    }
                                                }

                                                //prositeResponseIterator++;
                                            })
                                            .error(function (data, status) {
                                                //self.noResponse = true;
                                                // //console.log(data);
                                                // //console.log(status);
                                                ////console.log("uniprot error");
                                                //Each uniprot query adds one portion from 20 percent to 99 percent
                                                self.uniprotResponseIterator += 1;
                                                // //console.log(self.uniprotResponseIterator);
                                                // //console.log(self.uniprotResponseIteratorTotalForPercentage);
                                                self.progressPercent += 79 / self.uniprotResponseIteratorTotalForPercentage;


                                                // //console.log(self.uniprotResponseIterator);
                                                // //console.log(self.responseRawLocal.length);
                                                //
                                                //
                                                // //console.log(self.uniprotResponseIterator);
                                                // //console.log(self.responseRawLocal.length);
                                                // //console.log(self.numResponsesFromProsite);
                                                // //console.log(self.parsedMotifs.length);
                                                //protPlaceVar = protPlaceVar + 1;
                                                if (self.numResponsesFromProsite >= self.parsedMotifs.length && self.uniprotResponseIterator >= self.uniprotResponseIteratorTotal) {

                                                    self.showOutput = true;
                                                    //console.log("Before updating pln! ");

                                                    // //console.log("--------------");
                                                    // //console.log("uniprotResponseIterator");
                                                    // //console.log(self.uniprotResponseIterator);
                                                    // //console.log("uniprotResponseIteratorTotal");
                                                    // //console.log(self.uniprotResponseIteratorTotal);
                                                    //
                                                    // //console.log("numResponsesFromProsite");
                                                    // //console.log(self.numResponsesFromProsite);
                                                    // //console.log("parsedMotifs.length");
                                                    // //console.log(self.parsedMotifs.length);
                                                    self.showOutput = true;
                                                    self.waiting = false;
                                                    // //console.log("Before updating pln! number of numResponsesFromProsite");
                                                    // //console.log(self.numResponsesFromProsite);

                                                    self.updatePln(self.peptideNormalizeFlag, self.parsedMotifs, self.textArea, self.responseRaw, self.proteinMap, self.parsedMotifs, self.parsedPeptides, self.peptideAbundance, self.sequence_acListComplete);

                                                }

                                                //prositeResponseIterator++;
                                            });
                                    })(uniprotQuery, valueOfUniprotJsonObjecItem, protPlaceVariable)
                                    protPlaceVariable = protPlaceVariable + 1;
                                }

                            }//End of loop for keys

                        })(self.uniprotJsonObjectAll);


                        // //console.log("prositeResponseIterator");
                        // //console.log(prositeResponseIterator);

                        //++++++++++++++++++++++++++++++++++++++
                    })
                //Error in api/peptide
                    .error(function (data, status) {
                        self.noResponse = true;
                        self.prositeFoundNum = self.prositeFoundNum + 1;
                        self.prositeFound = localMotif;
                        self.showOutput = true;
                        // //console.log("api/peptide error");
                        // //console.log(localMotif);
                        // //console.log(data);
                        // //console.log(status);
                        self.responseRawLocal = [];
                        //self.prResponseList = [];
                        self.responseRaw = [];
                        self.responseRawLocal = self.responseRawLocal.concat({
                            "motif": localMotif,
                            "peptide": localPeptide,
                            "sequence_ac": "",
                            "sequence_id": "",
                            "sequence_db": " Prosite Response Error! ",
                            "start": "",
                            "stop": "",
                            "signature_ac": ""
                        });

                        self.responseRaw = self.responseRaw.concat(self.responseRawLocal);

                        self.prResponseJson = {
                            "motif": localMotif,
                            "peptide": localPeptide,
                            "length": self.responseRawLocal.length,
                            "response": self.responseRaw
                        };
                        self.prResponseList = self.prResponseList.concat(self.prResponseJson);
                        //for ()
                        //self.prResponseList
                        // //console.log("Response Local");
                        // //console.log(self.responseRawLocal);
                        //
                        // //console.log("Response Raw");
                        // //console.log(self.responseRaw);
                        //
                        // //console.log("total response");
                        // //console.log(self.prResponseJson);


                        // //console.log("--------------");
                        // //console.log("uniprotResponseIterator");
                        // //console.log(self.uniprotResponseIterator);
                        // //console.log("uniprotResponseIteratorTotal");
                        // //console.log(self.uniprotResponseIteratorTotal);
                        // //console.log("here1, before checking for updating pln");
                        // //console.log("numResponsesFromProsite");
                        // //console.log(self.numResponsesFromProsite);
                        // //console.log("parsedMotifs.length");
                        // //console.log(self.parsedMotifs.length);
                        // //console.log("here2, before checking for updating pln");
                        //
                        // //console.log(self.numResponsesFromProsite >= self.parsedMotifs.length);
                        // //console.log(self.uniprotResponseIterator >= self.responseRawLocal.length);
                        // //console.log(self.uniprotResponseIterator );
                        // //console.log(self.responseRawLocal.length);
                        // //console.log(self.responseRawLocal);
                        ////console.log("here3, before checking for updating pln");

                        // //console.log(self.uniprotResponseIterator);
                        // //console.log(self.uniprotResponseIteratorTotal);
                        if (self.numResponsesFromProsite >= self.parsedMotifs.length && self.uniprotResponseIterator >= self.uniprotResponseIteratorTotal) {

                            self.showOutput = true;
                            //console.log("Before updating pln! ");

                            // //console.log("--------------");
                            // //console.log("uniprotResponseIterator");
                            // //console.log(self.uniprotResponseIterator);
                            // //console.log("uniprotResponseIteratorTotal");
                            // //console.log(self.uniprotResponseIteratorTotal);
                            //
                            // //console.log("numResponsesFromProsite");
                            // //console.log(self.numResponsesFromProsite);
                            // //console.log("parsedMotifs.length");
                            // //console.log(self.parsedMotifs.length);
                            self.showOutput = true;
                            self.waiting = false;
                            // //console.log("Before updating pln in the error section! ");
                            // //console.log("Before updating pln! number of numResponsesFromProsite");
                            // //console.log(self.numResponsesFromProsite);

                            self.updatePln(self.peptideNormalizeFlag, self.parsedMotifs, self.textArea, self.responseRaw, self.proteinMap, self.parsedMotifs, self.parsedPeptides, self.peptideAbundance, self.sequence_acListComplete);

                        }


                    })

            })(self.parsedMotifs, self.parsedPeptides);
        } else {
            //Using prosite for the peptide search
            for (var j = 0; j < self.parsedMotifs.length; j++) {

                var localMotif = self.parsedMotifs[j];
                var localPeptide = self.parsedPeptides[j];
                ////console.log(localMotif);
                ////console.log(localPeptide);

                (function (localMotif, localPeptide) {
                    $http.get(url + localMotif + "," + self.organismForm)
                        .success(function (data) {
                            self.responseRawLocal = [];
                            // //console.log("prosite success!");
                            // //console.log(localMotif);
                            // //console.log(data);


                            var matchset = data.matchset;
                            ////console.log(matchset);
                            var nMatch = data.n_match;

                            self.uniprotResponseIteratorTotal += nMatch;
                            if (nMatch >= 0) {
                                self.prositeFoundNum = self.prositeFoundNum + 1;
                                self.prositeFound = localPeptide;
                                self.showOutput = true;
                            }
                            // if (nMatch == 0) {
                            //     self.prositeFoundNum = self.prositeFoundNum + 1;
                            //     self.prositeFound = localPeptide;
                            //     self.showOutput = true;
                            // }
                            data.matchset.map(function (e) {
                                e.motif = localMotif;
                                e.peptide = localPeptide;
                                return e;
                            });
                            self.numResponsesFromProsite++;
                            var flagFound = 1;
                            if (nMatch === 0) {
                                flagFound = 0;

                                self.responseRawLocal = self.responseRawLocal.concat([
                                    {
                                        "motif": localMotif,
                                        "peptide": localPeptide,
                                        "sequence_ac": "",
                                        "sequence_id": "",
                                        "sequence_db": "Not found in canonical uniprot data base!",
                                        "start": "",
                                        "stop": "",
                                        "signature_ac": ""
                                    }]);
                            }
                            else {
                                self.responseRawLocal = self.responseRawLocal.concat(matchset);
                            }

                            self.responseRaw = self.responseRaw.concat(self.responseRawLocal);

                            self.prResponseJson = {
                                "motif": localMotif,
                                "peptide": localPeptide,
                                "length": self.responseRawLocal.length,
                                "response": self.responseRawLocal
                            }
                            self.prResponseList = self.prResponseList.concat(self.prResponseJson);
                            //for ()
                            //self.prResponseList
                            // //console.log("Response Local");
                            // //console.log(self.responseRawLocal);
                            //
                            // //console.log("Response Raw");
                            // //console.log(self.responseRaw);
                            //
                            // //console.log("total response");
                            // //console.log(self.prResponseJson);


                            //Uniprot query

                            var url2 = 'api/uniprot/';
                            prositeResponseIterator = 0;
                            if (flagFound === 0) {
                                // //console.log("--------------");
                                // //console.log("uniprotResponseIterator");
                                // //console.log(self.uniprotResponseIterator);
                                // //console.log("uniprotResponseIteratorTotal");
                                // //console.log(self.uniprotResponseIteratorTotal);
                                //
                                // //console.log("numResponsesFromProsite");
                                // //console.log(self.numResponsesFromProsite);
                                // //console.log("parsedMotifs.length");
                                // //console.log(self.parsedMotifs.length);


                                // //console.log(self.uniprotResponseIterator);
                                // //console.log(self.responseRawLocal.length);
                                // //console.log(self.numResponsesFromProsite);
                                // //console.log(self.parsedMotifs.length);

                                if (self.numResponsesFromProsite >= self.parsedMotifs.length && self.uniprotResponseIterator >= self.uniprotResponseIteratorTotal) {

                                    self.showOutput = true;
                                    // //console.log("Before updating pln! number of numResponsesFromProsite");
                                    // //console.log(self.numResponsesFromProsite);
                                    // //console.log("--------------");
                                    // //console.log("uniprotResponseIterator");
                                    // //console.log(self.uniprotResponseIterator);
                                    // //console.log("uniprotResponseIteratorTotal");
                                    // //console.log(self.uniprotResponseIteratorTotal);
                                    //
                                    // //console.log("numResponsesFromProsite");
                                    // //console.log(self.numResponsesFromProsite);
                                    // //console.log("parsedMotifs.length");
                                    // //console.log(self.parsedMotifs.length);

                                    self.updatePln(self.peptideNormalizeFlag, self.parsedMotifs, self.textArea, self.responseRaw, self.proteinMap, self.parsedMotifs, self.parsedPeptides, self.peptideAbundance, self.sequence_acListComplete);
                                }
                            }
                            if (flagFound === 1) {

                                while (prositeResponseIterator < self.responseRawLocal.length) {


                                    var uniprotQuery = self.responseRawLocal[prositeResponseIterator].sequence_ac;


                                    var startMotif = self.responseRawLocal[prositeResponseIterator].start;
                                    var stopMotif = self.responseRawLocal[prositeResponseIterator].stop;
                                    var motifMotif = self.responseRawLocal[prositeResponseIterator].motif;
                                    var motifPeptide = self.responseRawLocal[prositeResponseIterator].peptide;


                                    if (self.sequence_acList.indexOf(uniprotQuery) === -1) {
                                        self.sequence_acList.push(uniprotQuery);
                                        ////console.log("sequence_acList: " + self.sequence_acList);
                                        var sequence_acListMember = {
                                            "id": self.sequence_acList.length,
                                            "name": uniprotQuery,
                                            "length": 1,
                                            "members": emptyList
                                        };
                                        self.sequence_acListComplete = self.sequence_acListComplete.concat(sequence_acListMember);
                                        protPlace = self.sequence_acList.length - 1;
                                        self.uniprotLength = self.sequence_acList.length;
                                        // //console.log("sequence_acListComplete");
                                        // //console.log(self.sequence_acListComplete);
                                    }
                                    else {
                                        for (var prot = 0; prot < self.sequence_acListComplete.length; prot++) {
                                            if (uniprotQuery === self.sequence_acListComplete[prot].name) {
                                                protPlace = prot;
                                                ////console.log("Adding a member to" + uniprotQuery);
                                                self.sequence_acListComplete[prot].length = self.sequence_acListComplete[prot].length + 1;
                                                prot = self.sequence_acListComplete.length;
                                            }
                                        }
                                    }

                                    // //console.log(startMotif);
                                    // //console.log(stopMotif);
                                    (function (uniprotQuery, startMotif, stopMotif, motifMotif, motifPeptide, protPlace) {

                                        $http.get(url2 + uniprotQuery + "," + self.organismForm)
                                            .success(function (data) {


                                                self.uniprotFound = uniprotQuery;
                                                if (self.uniprotFoundNum < self.uniprotLength) {
                                                    self.uniprotFoundNum = self.uniprotFoundNum + 1;
                                                }
                                                ;
                                                self.showOutput = true;

                                                var uniprotJsonObject = data;

                                                ////console.log("Uniprot Response");
                                                ////console.log(uniprotJsonObject);
                                                //Defining uniprot to gene map
                                                var key = self.uniprotFound;
                                                var value = uniprotJsonObject.primary_gene_name;
                                                ////console.log("key");
                                                ////console.log(key);
                                                ////console.log("value");
                                                ////console.log(value);
                                                self.proteinMap[key] = value;


                                                ////console.log("proteinMap");
                                                ////console.log(self.proteinMap);


                                                var geneId = uniprotJsonObject.primary_gene_name;
                                                for (var geneIdIter = 0; geneIdIter < geneId.length; geneIdIter++) {
                                                    if (self.geneIdList.indexOf(geneId[geneIdIter]) === -1) {
                                                        self.geneIdList.push(geneId[geneIdIter]);
                                                        self.geneIdListLength = self.geneIdList.length;
                                                        // //console.log("geneIdList");
                                                        // //console.log(self.geneIdList);
                                                    }

                                                }


                                                //var uniprotJsonObject = data;
                                                // //console.log(JSON.stringify(data));
                                                // var start = self.responseRaw[prositeResponseIterator].startMotif;
                                                // var stop = self.responseRaw[prositeResponseIterator].stopMotif;
                                                // //console.log(start);
                                                // //console.log(stop);

                                                // //console.log(self.responseRaw[prositeResponseIterator].stop);
                                                uniprotJsonObject["start"] = startMotif;
                                                uniprotJsonObject["stop"] = stopMotif;
                                                uniprotJsonObject["motif"] = motifMotif;
                                                uniprotJsonObject["peptide"] = motifPeptide;
                                                uniprotJsonObject["sequence_ac"] = uniprotQuery;
                                                // //console.log(uniprotJsonObject);

                                                // data.matchset.map(function (e) {
                                                //     e.motif = localMotif;
                                                //     return e;
                                                // });
                                                //+++++++++++++++++++++++++++++++++++++++++++++++++++
                                                //var matchset = data.matchset;
                                                //self.uniprotResponseRaw = self.uniprotResponseRaw.concat(uniprotJsonObject.toString());

                                                self.sequence_acListComplete[protPlace].members = self.sequence_acListComplete[protPlace].members.concat(uniprotJsonObject);

                                                // //console.log("protPlace: " + protPlace);
                                                // //console.log("sequence_acListComplete.name: " + self.sequence_acListComplete[protPlace].name);
                                                // //console.log("sequence_acListComplete2.length: " + self.sequence_acListComplete[protPlace].length);
                                                // //console.log("sequence_acListComplete3.members: " + self.sequence_acListComplete[protPlace].members);
                                                // for(var foo = 0; foo < self.sequence_acListComplete[protPlace].members.length; foo++)
                                                // {
                                                //     //console.log("foo   "+ foo);
                                                //     //console.log(self.sequence_acListComplete[protPlace].members[foo].sequence_ac);
                                                //     //console.log(self.sequence_acListComplete[protPlace].members[foo].motif);
                                                //
                                                // }

                                                self.uniprotResponseRaw = self.uniprotResponseRaw.concat(uniprotJsonObject);
                                                //self.uniprotResponseRaw = self.uniprotResponseRaw.concat(JSON.stringify(data));

                                                ////console.log("ResponseRaw: " + self.responseRaw);
                                                self.uniprotResponseIterator++;
                                                // //console.log("--------------");
                                                // //console.log("uniprotResponseIterator");
                                                // //console.log(self.uniprotResponseIterator);
                                                // //console.log("uniprotResponseIteratorTotal");
                                                // //console.log(self.uniprotResponseIteratorTotal);
                                                //
                                                // //console.log("numResponsesFromProsite");
                                                // //console.log(self.numResponsesFromProsite);
                                                // //console.log("parsedMotifs.length");
                                                // //console.log(self.parsedMotifs.length);


                                                // //console.log(self.uniprotResponseIterator);
                                                // //console.log(self.responseRawLocal.length);
                                                // //console.log(self.numResponsesFromProsite);
                                                // //console.log(self.parsedMotifs.length);

                                                if (self.numResponsesFromProsite >= self.parsedMotifs.length && self.uniprotResponseIterator >= self.uniprotResponseIteratorTotal) {

                                                    self.showOutput = true;
                                                    // //console.log("Before updating pln! number of numResponsesFromProsite");
                                                    // //console.log(self.numResponsesFromProsite);
                                                    // //console.log("--------------");
                                                    // //console.log("uniprotResponseIterator");
                                                    // //console.log(self.uniprotResponseIterator);
                                                    // //console.log("uniprotResponseIteratorTotal");
                                                    // //console.log(self.uniprotResponseIteratorTotal);
                                                    //
                                                    // //console.log("numResponsesFromProsite");
                                                    // //console.log(self.numResponsesFromProsite);
                                                    // //console.log("parsedMotifs.length");
                                                    // //console.log(self.parsedMotifs.length);
                                                    self.updatePln(self.peptideNormalizeFlag, self.parsedMotifs, self.textArea, self.responseRaw, self.proteinMap, self.parsedMotifs, self.parsedPeptides, self.peptideAbundance, self.sequence_acListComplete);


                                                }
                                                //prositeResponseIterator++;
                                            })
                                            .error(function (data, status) {
                                                //self.noResponse = true;
                                                // //console.log(data);
                                                // //console.log(status);
                                                self.uniprotResponseIterator++;
                                                // //console.log(self.uniprotResponseIterator);
                                                // //console.log(self.responseRawLocal.length);
                                                //
                                                //
                                                // //console.log(self.uniprotResponseIterator);
                                                // //console.log(self.responseRawLocal.length);
                                                // //console.log(self.numResponsesFromProsite);
                                                // //console.log(self.parsedMotifs.length);

                                                if (self.numResponsesFromProsite >= self.parsedMotifs.length && self.uniprotResponseIterator >= self.responseRawLocal.length) {
                                                    ////console.log(self.uniprotResponseIterator);
                                                    ////console.log(self.responseRawLocal.length);
                                                    // self.waiting = false;
                                                    // self.showOutput = true;
                                                    // //console.log("before updating pln");
                                                    // //console.log("Num of responses from prosite");
                                                    // //console.log(self.numResponsesFromProsite);
                                                    self.showOutput = true;
                                                    // //console.log("Before updating pln! number of numResponsesFromProsite");
                                                    // //console.log(self.numResponsesFromProsite);
                                                    self.updatePln(self.peptideNormalizeFlag, self.parsedMotifs, self.textArea, self.responseRaw, self.proteinMap, self.parsedMotifs, self.parsedPeptides, self.peptideAbundance, self.sequence_acListComplete);
                                                }
                                                //prositeResponseIterator++;
                                            });


                                    })(uniprotQuery, startMotif, stopMotif, motifMotif, motifPeptide, protPlace);


                                    prositeResponseIterator++;


                                }


                            }

                            // //console.log("prositeResponseIterator");
                            // //console.log(prositeResponseIterator);

                            //++++++++++++++++++++++++++++++++++++++
                        })
                        .error(function (data, status) {
                            self.noResponse = true;
                            self.prositeFoundNum = self.prositeFoundNum + 1;
                            self.prositeFound = localMotif;
                            self.showOutput = true;
                            // //console.log("prosite error");
                            // //console.log(localMotif);
                            // //console.log(data);
                            // //console.log(status);
                            self.responseRawLocal = [];
                            //self.prResponseList = [];
                            self.responseRaw = [];
                            self.responseRawLocal = self.responseRawLocal.concat({
                                "motif": localMotif,
                                "peptide": localPeptide,
                                "sequence_ac": "",
                                "sequence_id": "",
                                "sequence_db": " Prosite Response Error! ",
                                "start": "",
                                "stop": "",
                                "signature_ac": ""
                            });

                            self.responseRaw = self.responseRaw.concat(self.responseRawLocal);

                            self.prResponseJson = {
                                "motif": localMotif,
                                "peptide": localPeptide,
                                "length": self.responseRawLocal.length,
                                "response": self.responseRaw
                            };
                            self.prResponseList = self.prResponseList.concat(self.prResponseJson);
                            //for ()
                            //self.prResponseList
                            // //console.log("Response Local");
                            // //console.log(self.responseRawLocal);
                            //
                            // //console.log("Response Raw");
                            // //console.log(self.responseRaw);
                            //
                            // //console.log("total response");
                            // //console.log(self.prResponseJson);


                            self.numResponsesFromProsite++;
                            // //console.log("--------------");
                            // //console.log("uniprotResponseIterator");
                            // //console.log(self.uniprotResponseIterator);
                            // //console.log("uniprotResponseIteratorTotal");
                            // //console.log(self.uniprotResponseIteratorTotal);
                            //
                            // //console.log("numResponsesFromProsite");
                            // //console.log(self.numResponsesFromProsite);
                            // //console.log("parsedMotifs.length");
                            // //console.log(self.parsedMotifs.length);
                            if (self.numResponsesFromProsite >= self.parsedMotifs.length && self.uniprotResponseIterator >= self.responseRawLocal.length) {
                                // //console.log("before updating pln");
                                // //console.log("Num of responses from prosite");
                                // //console.log(self.numResponsesFromProsite);
                                self.showOutput = true;
                                // //console.log("Before updating pln in the error section! ");
                                // //console.log("Before updating pln! number of numResponsesFromProsite");
                                // //console.log(self.numResponsesFromProsite);
                                self.updatePln(self.peptideNormalizeFlag, self.parsedMotifs, self.textArea, self.responseRaw, self.proteinMap, self.parsedMotifs, self.parsedPeptides, self.peptideAbundance, self.sequence_acListComplete);
                            }


                        })

                })(localMotif, localPeptide);
            }
        }

    }
    // var svg5 = d3.selectAll("#parallel").append("svg");

    //var svg5 = d3.selectAll("#parallel").append("svg");



    $scope.makeParallelGrid = function (peptideToModificationList) {
        // d3.selectAll("svg > *").remove();
        // svg5.selectAll("*").remove();
        //
        // svg5.remove();
//This is for making csv from json
        //d3.selectAll("svg > *").remove();
        if(self.showOverAllParallelSVG)
        {
            self.showOverAllParallelSVG = false;
        }else {

            d3.select("#parallelForPeptideToProtein").select("svg").remove();
            // if (typeof svg6 === 'undefined') {
            //     var svg6 = d3.selectAll("#chart6").append("svg");
            // }
            // d3.select("svg").remove();
            self.showOverAllParallelSVG = true;

            var parallelJson = [];
            var parallelUniquePep = [];
            var parallelUniquePtm = [];
            var parallelUniqueProtein = [];
            var parallelUniqueGene = [];
            var parallelNrows = 0;
            ////console.log(peptideToModificationList);
            peptideToModificationList.map(function (e) {
                // //console.log(e);
                var parallelPep = e.motif;
                if (parallelUniquePep.indexOf(parallelPep) === -1) {
                    parallelUniquePep.push(parallelPep);
                }

                e.response.map(function (e2) {
                    var parallelProt = e2.sequence_ac;
                    var parallelPtm = e2.ptmProteinsMixAll[0];
                    if (parallelUniqueProtein.indexOf(parallelProt) === -1) {
                        parallelUniqueProtein.push(parallelProt);
                    }
                    if (parallelUniquePtm.indexOf(parallelPtm) === -1) {
                        parallelUniquePtm.push(parallelPtm);
                    }
                    ////console.log(e2);
                    for (parallelIter = 0; parallelIter < e2.geneArray.length; parallelIter++) {
                        // //console.log(parallelPep);
                        // //console.log(parallelProt);
                        // //console.log(e2.geneArray[parallelIter]);
                        // //console.log(e2.ptmProteinsMassAll[parallelIter]);
                        var parallelGene = e2.geneArray[parallelIter];
                        if (parallelUniqueGene.indexOf(parallelGene) === -1) {
                            parallelUniqueGene.push(parallelGene);
                        }
                        parallelJsonItem = {};
                        parallelJsonItem.Peptide = parallelPep;
                        parallelJsonItem.Protein = parallelProt;
                        parallelJsonItem.Gene = parallelGene;
                        parallelJsonItem.ptmProtein = parallelPtm;

                        parallelJson.push(parallelJsonItem);
                        //parallelNrows += 1;
                    }


                })


            })


            parallelNrows = Math.max(parallelUniqueGene.length, parallelUniqueProtein.length, parallelUniquePep.length, parallelUniquePtm.length)

            // var margin = {top: 30, right: 100, bottom: 10, left: 100},
            //     width = 960 - margin.left - margin.right,
            //     height = Math.max(parallelNrows * 12, 400);


            // quantitative color scale
            var blue_to_brown = d3.scale.linear()
                .domain([9, 50])
                .range(["steelblue", "brown"])
                .interpolate(d3.interpolateLab);

            // var color = function(d) { return blue_to_brown(d['Peptide']); };
            var color = function (d) {
                return blue_to_brown(9);
            };
            ////console.log(color);
            // var parcoords = d3.parcoords()("#parallel")
            //     .color(color)
            //     .alpha(0.4);

            var parcoords2 = d3.parcoords()("#parallelForPeptideToProtein")
            // .width(width + margin.left + margin.right)
            // .height(height + margin.top + margin.bottom)
            //.attr("transform", "translate(" + margin.left + "," + margin.top + ")")
            //.color(color)
            //.alpha(0.4)
                .height(Math.max(parallelNrows * 12, 400))
                .width(1200);
            self.parallelHeight = parcoords2.height() + 20;
            self.parallelWidth = parcoords2.width() + 20;

            // document.getElementById('parallel').style.width = self.parallelWidth;
            // document.getElementById('parallel').style.height = self.parallelHeight + 30;
            document.getElementById('parallelForPeptideToProtein').setAttribute("style", "width:" + self.parallelWidth + "px");
            document.getElementById('parallelForPeptideToProtein').setAttribute("style", "height:" + self.parallelHeight + "px");
            //parcoords.height() = 900;

            //***************
            //***************


            // var svg5 = d3.select("#parallel").append("svg")
            //     .attr("width", width + margin.left + margin.right)
            //     .attr("height", height + margin.top + margin.bottom)
            //     .append("g")
            //     .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            self.dataForParallelPeptideToProtein = parallelJson;
            //***************
            //***************

            // d3.csv('./js/cars2.csv', function(data) {
            ////console.log(self.dataForParallelPeptideToProtein);
            //parcoords.height() = Math.max(parallelNrows * 12, 400);
            //     parcoords.margin().top = 10;
            //     parcoords.margin().bottom = 10;
            //     parcoords.height(Math.max(parallelNrows * 12, 400));
            //     parcoords.height(960);
            var range = parcoords2.height() - parcoords2.margin().top - parcoords2.margin().bottom;

            // //console.log(parcoords2.height());
            // //console.log(parcoords2.margin().top);
            // //console.log(parcoords2.margin().bottom);
            // //console.log(range);
            // var min = d3.min(self.dataForParallelPeptideToProtein, function (d) {
            //     return parseInt(d['name']);
            // });
            // var max = d3.max(self.dataForParallelPeptideToProtein, function (d) {
            //     return parseInt(d['ptmProtein']);
            // });

            var min = 0;
            var max = 1000;
            var log = d3.scale.log().domain([min, max]).range([range, 1]);
            //name,economy (mpg),cylinders,displacement (cc)
            var dimensionsForParCoordsPepToProt = {
                'Peptide': {
                    title: "Peptide",
                    type: 'string',
                    innerTickSize: 5,
                    outerTickSize: 5
                    //yscale: ordinal,
                    // tickFormat: function(d){
                    //     return log.tickFormat(4,d3.format(",d"))(d);
                    // }
                },
                'Protein': {
                    title: "Protein",
                    type: 'string',
                    orient: 'right',
                    innerTickSize: 5,
                    outerTickSize: 5
                }
                ,
                'Gene': {
                    title: "Gene",
                    type: 'string',
                    innerTickSize: 5,
                    outerTickSize: 5
                },
                'ptmProtein': {
                    title: "ptmProtein",
                    orient: 'right',
                    type: 'string',
                    tickPadding: 0,
                    innerTickSize: 5
                }
            };


            parcoords2
                .data(self.dataForParallelPeptideToProtein)
                .composite("darker")
                .dimensions(dimensionsForParCoordsPepToProt)
                // .hideAxis(['name'])
                .render()
                .shadows()
                .reorderable()
                // .interactive()
                .brushMode("1D-axes");  // enable brushing
            // });

            var sltBrushMode = d3.select('#sltBrushMode')

            sltBrushMode.selectAll('option')
                .data(parcoords2.brushModes())
                .enter()
                .append('option')
                .text(function (d) {
                    // //console.log(d);
                    return d;
                });

            sltBrushMode.on('change', function () {
                parcoords2.brushMode(this.value);
                switch (this.value) {
                    case 'None':
                        d3.select("#pStrums").style("visibility", "hidden");
                        d3.select("#lblPredicate").style("visibility", "hidden");
                        d3.select("#sltPredicate").style("visibility", "hidden");
                        d3.select("#btnReset").style("visibility", "hidden");
                        break;
                    case '2D-strums':
                        d3.select("#pStrums").style("visibility", "visible");
                        break;
                    default:
                        d3.select("#pStrums").style("visibility", "hidden");
                        d3.select("#lblPredicate").style("visibility", "visible");
                        d3.select("#sltPredicate").style("visibility", "visible");
                        d3.select("#btnReset").style("visibility", "visible");
                        break;
                }
            });

            sltBrushMode.property('value', '1D-axes');

            d3.select('#btnReset').on('click', function () {
                parcoords2.brushReset();
            })
            d3.select('#sltPredicate').on('change', function () {
                parcoords2.brushPredicate(this.value);
            });


            //**********************
            //**********************
            //**********************
            //**********************
            //**********************
            // var x = d3.scale.ordinal().rangePoints([0, width], 1),
            //     y = {},
            //     dragging = {};
            //
            // var line = d3.svg.line(),
            //     axis = d3.svg.axis().orient("left"),
            //     background,
            //     foreground;
            //
            // d3.select("svg").remove();
            //
            // var svg5 = d3.select("#parallel").append("svg")
            //     .attr("width", width + margin.left + margin.right)
            //     .attr("height", height + margin.top + margin.bottom)
            //     .append("g")
            //     .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
            //
            // data = self.parallelJson;
            // x.domain(dimensions = d3.keys(data[0]).filter(function(d) {
            //
            //     y[d] = d3.scale.ordinal()
            //         .domain(data.map(function(p) { return p[d]; }))
            //         .rangePoints([height, 0]);
            //
            //     return true;
            // }));
            //
            // //console.log(dimensions);
            //
            // // Add grey background lines for context.
            // background = svg5.append("g")
            //     .attr("class", "background")
            //     .selectAll("path")
            //     .data(data)
            //     .enter().append("path")
            //     .attr("d", path);
            //
            // // Add blue foreground lines for focus.
            // foreground = svg5.append("g")
            //     .attr("class", "foreground")
            //     .selectAll("path")
            //     .data(data)
            //     .enter().append("path")
            //     .attr("d", path);
            //
            // // Add a group element for each dimension.
            // var g = svg5.selectAll(".dimension")
            //     .data(dimensions)
            //     .enter().append("g")
            //     .attr("class", "dimension")
            //     .attr("transform", function(d) {
            //         //console.log(x(d));
            //         return "translate(" + x(d) + ")"; })
            //     .call(d3.behavior.drag()
            //         .origin(function(d) { return {x: x(d)}; })
            //         .on("dragstart", function(d) {
            //             dragging[d] = x(d);
            //             background.attr("visibility", "hidden");
            //         })
            //         .on("drag", function(d) {
            //             dragging[d] = Math.min(width, Math.max(0, d3.event.x));
            //             foreground.attr("d", path);
            //             dimensions.sort(function(a, b) { return position(a) - position(b); });
            //             x.domain(dimensions);
            //             g.attr("transform", function(d) { return "translate(" + position(d) + ")"; })
            //         })
            //         .on("dragend", function(d) {
            //             delete dragging[d];
            //             transition(d3.select(this)).attr("transform", "translate(" + x(d) + ")");
            //             transition(foreground).attr("d", path);
            //             background
            //                 .attr("d", path)
            //                 .transition()
            //                 .delay(500)
            //                 .duration(0)
            //                 .attr("visibility", null);
            //         }));
            //
            // // Add an axis and title.
            // g.append("g")
            //     .attr("class", "axis")
            //     //.orient("left")
            //     .each(function(d) {
            //
            //         d3.select(this).call(axis.scale(y[d])); })
            //     .append("text")
            //     .style("text-anchor", "middle")
            //     .attr("y", -9)
            //     .text(function(d) {
            //         //console.log(d);
            //         return d; });
            //
            // // Add and store a brush for each axis.
            // g.append("g")
            //     .attr("class", "brush")
            //     .each(function(d) {
            //         d3.select(this).call(y[d].brush = d3.svg.brush().y(y[d]).on("brushstart", brushstart).on("brush", brush));
            //     })
            //     .selectAll("rect")
            //     .attr("x", -8)
            //     .attr("width", 16);
            //
            // var projection = svg5.selectAll(".foreground path")
            //     .on("mouseover", mouseover)
            //     .on("mouseout", mouseout);
            //
            // function mouseover(d) {
            //     //svg.classed("active", false);
            //     projection.classed("inactive", function(p) { return p !== d; });
            //     projection.classed("active", function(p) { return p === d; });
            //     //projection.filter(function(p) { return p === d; }).each(moveToFront);
            // }
            //
            // function mouseout(d) {
            //
            //     //projection.classed("inactive", function(p) { return p !== d; });
            //     projection.classed("active");
            // }
            //
            // function position(d) {
            //     var v = dragging[d];
            //     return v == null ? x(d) : v;
            // }
            //
            // function transition(g) {
            //     return g.transition().duration(500);
            // }
            //
            // // Returns the path for a given data point.
            // function path(d) {
            //     return line(dimensions.map(function(p) {
            //     //console.log([position(p), y[p](d[p])]);
            //         return [position(p), y[p](d[p])]; }));
            // }
            //
            // function brushstart() {
            //     d3.event.sourceEvent.stopPropagation();
            // }
            //
            // // Handles a brush event, toggling the display of foreground lines.
            // function brush() {
            //     var actives = dimensions.filter(function(p) { return !y[p].brush.empty(); }),
            //         extents = actives.map(function(p) { return y[p].brush.extent(); });
            //     foreground.style("display", function(d) {
            //         return actives.every(function(p, i) {
            //
            //             return extents[i][0] <= y[p](d[p]) && y[p](d[p]) <= extents[i][1];
            //             //This one is for numeric
            //             //return extents[i][0] <= d[p] && d[p] <= extents[i][1];
            //         }) ? null : "none";
            //     });
            // }

            //**********************
            //**********************
            //**********************
            //**********************
            //**********************
        }

    };




    // d3.select("#download-svgGE").on("click", function() {
    //     d3.select(this)
    //         .attr("href", 'data:application/octet-stream;base64,' + btoa(d3.select("#line").html()))
    //         .attr("download", "viz.svg")
    // })
    d3.select("#download-svgParallel").on("click", function ()  {
        var name = 'pinet_parallel_peptide_mapping.svg';
        var svgEl = d3.select("#parallelForPeptideToProtein").select("svg").node();
        svgEl.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        var svgData = svgEl.outerHTML;
        var preface = '<?xml version="1.0" standalone="no"?>\r\n';
        var svgBlob = new Blob([preface, svgData], {type:"image/svg+xml;charset=utf-8"});
        var svgUrl = URL.createObjectURL(svgBlob);
        var downloadLink = document.createElement("a");
        downloadLink.href = svgUrl;
        downloadLink.download = name;
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
    })

    // d3.select("#download-svgGE").on("click", function () {
    //     console.log("#download-svgGE")
    //     d3.select(this)
    //         .attr("href", 'data:application/octet-stream;base64,' + btoa(d3.select("#chartGE")))
    //         .attr("download", "pathway_network.svg")
    // })

    d3.select('#download-pngParallel').on('click', function () {
        var svgString = getSVGString(d3.select("#parallelForPeptideToProtein").select("svg").node());

        // self.parallelHeight = parcoords2.height() + 20;
        // self.parallelWidth
        svgString2Image(svgString, 4 * self.parallelWidth, 4 * (self.parallelHeight + 50), 'png', save); // passes Blob and filesize String to the callback

        function save(dataBlob, filesize) {
            saveAs(dataBlob, 'pinet_parallel_peptide_mapping.png'); // FileSaver.js function
        }
    });
    d3.select('#saveButton').on('click', function () {
        var svgString = getSVGString(svg4.node());

        svgString2Image(svgString, 4 * self.parallelWidth, 4 * (self.parallelHeight + 50), 'png', save); // passes Blob and filesize String to the callback

        function save(dataBlob, filesize) {
            saveAs(dataBlob, 'pinet_parallel_peptide_mapping.png'); // FileSaver.js function
        }
    });

// Below are the functions that handle actual exporting:
// getSVGString ( svgNode ) and svgString2Image( svgString, width, height, format, callback )
    function getSVGString(svgNode) {
        svgNode.setAttribute('xlink', 'http://www.w3.org/1999/xlink');
        var cssStyleText = getCSSStyles(svgNode);
        appendCSS(cssStyleText, svgNode);

        var serializer = new XMLSerializer();
        var svgString = serializer.serializeToString(svgNode);
        svgString = svgString.replace(/(\w+)?:?xlink=/g, 'xmlns:xlink='); // Fix root xlink without namespace
        svgString = svgString.replace(/NS\d+:href/g, 'xlink:href'); // Safari NS namespace fix

        return svgString;

        function getCSSStyles(parentElement) {
            var selectorTextArr = [];

            // Add Parent element Id and Classes to the list
            selectorTextArr.push('#' + parentElement.id);
            for (var c = 0; c < parentElement.classList.length; c++)
                if (!contains('.' + parentElement.classList[c], selectorTextArr))
                    selectorTextArr.push('.' + parentElement.classList[c]);

            // Add Children element Ids and Classes to the list
            var nodes = parentElement.getElementsByTagName("*");
            for (var i = 0; i < nodes.length; i++) {
                var id = nodes[i].id;
                if (!contains('#' + id, selectorTextArr))
                    selectorTextArr.push('#' + id);

                var classes = nodes[i].classList;
                for (var c = 0; c < classes.length; c++)
                    if (!contains('.' + classes[c], selectorTextArr))
                        selectorTextArr.push('.' + classes[c]);
            }

            // Extract CSS Rules
            var extractedCSSText = "";
            for (var i = 0; i < document.styleSheets.length; i++) {
                var s = document.styleSheets[i];

                try {
                    if (!s.cssRules) continue;
                } catch (e) {
                    if (e.name !== 'SecurityError') throw e; // for Firefox
                    continue;
                }

                var cssRules = s.cssRules;
                for (var r = 0; r < cssRules.length; r++) {
                    if (contains(cssRules[r].selectorText, selectorTextArr))
                        extractedCSSText += cssRules[r].cssText;
                }
            }


            return extractedCSSText;

            function contains(str, arr) {
                return arr.indexOf(str) === -1 ? false : true;
            }

        }

        function appendCSS(cssText, element) {
            var styleElement = document.createElement("style");
            styleElement.setAttribute("type", "text/css");
            styleElement.innerHTML = cssText;
            var refNode = element.hasChildNodes() ? element.children[0] : null;
            element.insertBefore(styleElement, refNode);
        }
    }


    function svgString2Image(svgString, width, height, format, callback) {
        var format = format ? format : 'png';

        var imgsrc = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgString))); // Convert SVG string to data URL

        var canvas = document.createElement("canvas");
        var context = canvas.getContext("2d");

        canvas.width = width;
        canvas.height = height;

        var image = new Image();
        image.onload = function () {
            context.clearRect(0, 0, width, height);
            context.drawImage(image, 0, 0, width, height);

            canvas.toBlob(function (blob) {
                var filesize = Math.round(blob.length / 1024) + ' KB';
                if (callback) callback(blob, filesize);
            });


        };

        image.src = imgsrc;
    }


    self.updatePln = function (normalizeFlag, parsedMotifsInput, textAreaInput, responseRawInput, proteinMapInput, parsedMotifs, parsedPeptides , peptideAbund, sequence_acListComplete) {
        self.progressText = "Preparing the Results and Tables.";
        self.plnFormatOne = [];
        self.plnFormatTwo = [];
        self.ptmProteins = [];
        self.phosphoGenes = [];
        //peptideFlag is used to see which peptides are found
        self.peptideFlag = [];
        self.peptideToAbundance = {};
        self.ptmProteinToAbundance = {};
        self.ptmProteinToPeptideToAbundance = {};
        self.proteinToAbundance = {};
        self.geneToAbundance = {};
        self.peptideToNumberOfProteins = {};
        self.peptideFlag.push(["peptide", "flag"]);


        var motifs = parsedMotifsInput;
        var proteinMap = proteinMapInput;
        self.peptideToModificationList = [];
        self.peptideToModificationListOrig = [];

        var peptides = parsedPeptides;

        //
        //
        // var subCellularData = [{
        //     values: [19, 26, 55],
        //     labels: ['Residential', 'Non-Residential', 'Utility'],
        //     type: 'pie'
        // }];
        //
        // var subCellularLayout = {
        //     height: 400,
        //     width: 450
        // };
        //
        //
        // Plotly.newPlot('myDiv', subCellularData, subCellularLayout);
        // var subCellularTableData =[{"Name":"c1","Type":"cc1","SM_LINCS_ID":"ccc1"},
        //     {"Name":"c2","Type":"cc2","SM_LINCS_ID":"ccc2"},
        //     {"Name":"c4","Type":"cc4","SM_LINCS_ID":"ccc4"},
        //     {"Name":"c5","Type":"cc5","SM_LINCS_ID":"ccc5"},
        //     {"Name":"c6","Type":"cc6","SM_LINCS_ID":"ccc6"},
        //     {"Name":"c3","Type":"cc3","SM_LINCS_ID":"ccc3"}];
        // var subCellularLabels = ['US', 'China', 'European Union', 'Russian Federation', 'Brazil', 'India', 'Rest of World' ];
        // var subCellularValues = [16, 15, 12, 6, 5, 4, 42];
        //
        // self.tableSubCellular = new NgTableParams({
        //     count: 5
        // }, {
        //     total: subCellularTableData,  dataset: subCellularTableData,counts: [5, 10, 25]});
        //
        // var subCellularData = [{
        //     values: subCellularValues,
        //     labels: subCellularLabels,
        //     domain: {column: 0},
        //     name: 'GHG Emissions',
        //     hoverinfo: 'label+percent+name',
        //     hole: .4,
        //     type: 'pie'
        // }
        // ];
        //
        // var subCellularLayout = {
        //     title: 'SubCellular Location Percentage',
        //     height: 400,
        //     width: 450,
        //     grid: {rows: 1, columns: 1},
        //     showlegend: false,
        //     annotations: [
        //         {
        //             font: {
        //                 size: 14
        //             },
        //             showarrow: false,
        //             text: '',
        //             x: 0.5,
        //             y: 0.5
        //         }
        //     ]
        // };
        //
        // Plotly.newPlot('subcellularDiv', subCellularData, subCellularLayout);
        // var pie = new d3pie("mypie", { });

        // var pie = new d3pie('myPie', {
        //     header: {
        //         title: {
        //             text: "Tooltips: example #1",
        //             fontSize: 20
        //         }
        //     },
        //     labels: {
        //         inner: {
        //             format: "none"
        //         }
        //     },
        //     data: {
        //         content: [
        //             { label: "JavaScript", value: 1, caption: "New and shiny despite its age." },
        //             { label: "Ruby", value: 2, caption: "Foreign and strange" },
        //             { label: "Java", value: 3, caption: "Old and verbose (buuuuurn!)" }
        //         ]
        //     },
        //     tooltips: {
        //         enabled: true,
        //         type: "caption"
        //     }
        // });


        // //console.log("********************************");
        // //console.log("In update pln");
        // //console.log("normalizeFlag ");
        // //console.log(normalizeFlag);
        // //console.log("parsedMotifsInput ");
        // //console.log(parsedMotifsInput);
        // //console.log("textAreaInput ");
        // //console.log(textAreaInput);
        // //console.log("responseRawInput ");
        // //console.log(responseRawInput);
        // //console.log("proteinMapInput ");
        // //console.log(proteinMapInput);
        // //console.log("parsedMotifs ");
        // //console.log(parsedMotifs);
        // //console.log("parsedPeptides ");
        // //console.log(parsedPeptides);
        // //console.log("peptideAbund ");
        // //console.log(peptideAbund);
        // //console.log("sequence_acListComplete ");
        // //console.log(sequence_acListComplete);
        // //console.log("********************************");
        // //console.log("motifs " + motifs);
        // //console.log("peptides " + peptides);
        // //console.log("responseRawInput ");
        // //console.log(responseRawInput);
        // //console.log("proteinMap ");
        //
        // //console.log(proteinMap);
        // //console.log("normalizeFlag");
        // //console.log(normalizeFlag);
//Standard normalization of data
        var peptideMean = 0.0;
        var peptideSd = 0.0;
        var peptideMeanIter = 0.0;
        //console.log("peptideToAbundance before");
        //console.log(peptideAbund);
        //console.log(self.peptideAbundance);
        for (var i = 0; i < peptideAbund.length; i++) {
            if (!isNaN(peptideAbund[i])) {
                peptideAbund[i] = parseFloat(peptideAbund[i]);

            }
        }
        //Normalize the abundance
        if (normalizeFlag === true) {
            //console.log("----Normalizing data---");
            for (var i = 0; i < peptideAbund.length; i++) {
                if (!isNaN(peptideAbund[i])) {
                    //console.log(peptideAbund[i]);
                    peptideMean = peptideMean + peptideAbund[i];
                    peptideMeanIter = peptideMeanIter + 1.0;
                }
            }
            //console.log("peptideMean");
            //console.log(peptideMean);
            //console.log(peptideMeanIter);
            peptideMean = peptideMean / peptideMeanIter;
            //console.log(peptideMean);
            for (var i = 0; i < peptideAbund.length; i++) {
                if (!isNaN(peptideAbund[i])) {
                    peptideSd = peptideSd + (peptideAbund[i] - peptideMean) * (peptideAbund[i] - peptideMean);

                }
            }
            if (peptideMeanIter >= 2) {
                peptideSd = peptideSd / (peptideMeanIter - 1.0);
            }
            // //console.log("peptideSd");
            // //console.log(peptideSd);
            peptideSd = Math.sqrt(peptideSd);
            // //console.log("peptideSd");
            // //console.log(peptideSd);
            for (var i = 0; i < peptideAbund.length; i++) {
                if (!isNaN(peptideAbund[i])) {

                    peptideAbund[i] = (peptideAbund[i] - peptideMean) / peptideSd;

                }
            }
        }
        //console.log("peptideToAbundance after");
        //console.log(peptideAbund);
        for (var i = 0; i < parsedPeptides.length; i++) {
            self.peptideToAbundance[parsedPeptides[i]] = peptideAbund[i];
            self.peptideAbundance[i] = peptideAbund[i];

        }
        SharedService.setVar('peptideAbundance', self.peptideAbundance);
        //console.log("peptideToAbundance");
        //console.log(self.peptideToAbundance);


        //console.log("sequence_acListComplete");
        //console.log(sequence_acListComplete);

        // first compute how many proteins are connected to each peptide
        for (var i = 0; i < parsedPeptides.length; i++) {
            self.peptideToNumberOfProteins[parsedPeptides[i]] = 0;
        }
        for (var i = 0; i < sequence_acListComplete.length; i++) {
            e = sequence_acListComplete[i];

            var sequence_acListCompleteProt = e.name;
            var sequence_acListCompleteMember = e.members;
            var sequence_acListCompleteAverage = 0.0;
            var peptideNAFlag = false;
            sequence_acListCompleteMember.map(function (e2) {
                var sequence_acListCompletePeptide = e2.peptide;
                self.peptideToNumberOfProteins[sequence_acListCompletePeptide] = self.peptideToNumberOfProteins[sequence_acListCompletePeptide] + 1;
            })
        }
        //console.log("self.peptideToNumberOfProteins");
        //console.log(self.peptideToNumberOfProteins);
        for (var i = 0; i < sequence_acListComplete.length; i++) {
            e = sequence_acListComplete[i];

            var sequence_acListCompleteProt = e.name;
            var sequence_acListCompleteMember = e.members;
            self.proteinToAbundance[sequence_acListCompleteProt] = 0.0;
            var peptideNAFlag = false;
            sequence_acListCompleteMember.map(function (e2) {
                var sequence_acListCompletePeptide = e2.peptide;
                if (!isNaN(self.peptideToAbundance[sequence_acListCompletePeptide])) {
                    self.proteinToAbundance[sequence_acListCompleteProt] = self.proteinToAbundance[sequence_acListCompleteProt] + self.peptideToAbundance[sequence_acListCompletePeptide] / self.peptideToNumberOfProteins[sequence_acListCompletePeptide];
                }
                // else{
                //     peptideNAFlag = true;
                // }
            })
            // if(peptideNAFlag){
            //     self.proteinToAbundance[sequence_acListCompleteProt] = 'NA';
            // }
            // else {
            //     self.proteinToAbundance[sequence_acListCompleteProt] = sequence_acListCompleteAverage / e.length;
            // }

            var proteinMapSequence_ac = proteinMap[sequence_acListCompleteProt];
            // //console.log(proteinMap);
            // //console.log(proteinMapSequence_ac);
            proteinMapSequence_ac.map(function (e3) {
                self.geneToAbundance[e3] = self.proteinToAbundance[sequence_acListCompleteProt];
            })

        }
        ;
        //console.log("proteinToAbundance");
        //console.log(self.proteinToAbundance);
        //console.log("geneToAbundance");
        //console.log(self.geneToAbundance);


        for (var i = 0; i < peptides.length; i++) {
            var motif = motifs[i];
            var peptide = peptides[i];
            ////console.log("in loop motif " + motif);
            var firstPrositeResponse = responseRawInput
                .filter(function (e) {

                    return e.motif == motif;

                });

            distinct = [];
            firstPrositeResponseFiltered = [];

            for (var fpr = 0; fpr < firstPrositeResponse.length; fpr++) {
                if (distinct.indexOf(firstPrositeResponse[fpr].sequence_ac) === -1) {
                    distinct.push(firstPrositeResponse[fpr].sequence_ac);
                    firstPrositeResponseFiltered.push(firstPrositeResponse[fpr]);
                }
            }

            //firstPrositeResponse = firstPrositeResponse[0];
            var uniprotArray = [];
            var hugoArray = [];
            var ptmArray = [];

            // //console.log("motif: ");
            // //console.log(motif);
            // //console.log("firstPrositeResponse: ");
            // //console.log(firstPrositeResponse);
            // //console.log("firstPrositeResponseFiltered: ");
            // //console.log(firstPrositeResponseFiltered);
            if (firstPrositeResponseFiltered.length != 0) {
                if (firstPrositeResponseFiltered[0].sequence_db == "Not found in canonical uniprot data base!") {
                    self.peptideFlag.push([peptide, 0])
                }
                else if (firstPrositeResponseFiltered[0].sequence_db == " Prosite Response Error! ") {
                    self.peptideFlag.push([peptide, -1])
                }
                else {
                    self.peptideFlag.push([peptide, 1])
                }
            }
            else {
                self.peptideFlag.push([peptide, -2])
            }


            firstPrositeResponseFiltered.map(function (e) {
                uniprotArray.push(e.sequence_ac);
                var sequence_acMapped = e.sequence_ac;
                var hugoString = '';
                ////console.log("proteinMap[sequence_acMapped]");
                if (sequence_acMapped in proteinMap) {
                    for (var proteinMapGeneIter = 0; proteinMapGeneIter < proteinMap[e.sequence_ac].length - 1; proteinMapGeneIter++) {
                        hugoString = hugoString + String(proteinMap[e.sequence_ac][proteinMapGeneIter]) + '&';
                        //hugoArray.push(proteinMap[e.sequence_ac][proteinMapGeneIter]);
                    }
                    ;
                    var lenProteinMap = proteinMap[e.sequence_ac].length;

                    hugoString = hugoString + String(proteinMap[e.sequence_ac][lenProteinMap - 1]);
                    hugoArray.push(hugoString);
                }
                ptmArray.push(e.start);
            });

            var uniprot = uniprotArray;
            var hugo = hugoArray;


            var ptm = [];
            ////console.log(ptmArray);


            ptmArray.map(function (start, ptmArrayIndex) {

                var ptmLocal = [];

                // for a given peptide iterate through modifications, calculate its offset and return to ptmLocal
                ////console.log(self.ontologyMappings);
                self.ontologyMappings
                    .filter(function (el) {
                        // //console.log(peptide);
                        // //console.log(el);
                        // //console.log(el.input);
                        // ////console.log(el.originalModFromInput);
                        //
                        // //console.log(peptide.indexOf(el.input));
                        // //console.log(peptide.indexOf(el.input) > -1);
                        return (peptide.indexOf(el.input) > -1);
                    })
                    .map(function (e) {
                        var offsets = [];
                        var offset = peptide.indexOf(e.input);


                        while (offset !== -1) {
                            offsets.push(offset);
                            //count++;
                            offset = peptide.indexOf(e.input, offset + 1);
                        }
                        // //console.log(peptide);
                        // //console.log(e.input);
                        // ////console.log(offset);
                        // //console.log(offsets);

                        for (var offsetIter = 0; offsetIter < offsets.length; offsetIter++) {
                            var ptmIndex = 0;
                            // Iterate over numeric indexes from 0 to 5, as everyone expects.
                            offset = offsets[offsetIter];
                            // //console.log("offset");
                            // //console.log(offset);
                            var beforeOffset = peptide.substring(0, offset);
                            // //console.log("beforeOffset");
                            // //console.log(beforeOffset);
                            // //console.log(beforeOffset.length);
                            // //console.log("beforeOffset.replace(/ *\([^)]*\) */g, )");
                            // //console.log(beforeOffset.replace(/ *\([^)]*\) */g, ""));
                            // //console.log(beforeOffset.replace(/ *\([^)]*\) */g, "").length);
                            // //console.log("beforeOffset.replace(self.modificationPattern, )");
                            // //console.log(beforeOffset.replace(self.modificationPattern, ''));
                            // //console.log(beforeOffset.replace(self.modificationPattern, '').length);


                            // var decreaseOffset2 = beforeOffset.length - beforeOffset.replace(/ *\([^)]*\) */g, "").length;
                            // //console.log(decreaseOffset2);
                            var decreaseOffset = beforeOffset.length - beforeOffset.replace(/ *\([^)]*\) */g, "").replace(self.modificationPattern, '').length;


                            ////console.log(e.shorthand.match(self.patt2));
                            ////console.log(e);
                            // if (self.patt2.test(e.shorthand)) {
                            //     //console.log("passed the shorthand!!!!!");
                            //     ptmIndex = 1;
                            //     var ptmShorthandModification = e.shorthand.match(self.patt2);
                            //     var ptmShorthandSite = e.shorthand.match(self.patt1);
                            // }
                            // else {
                            //     var ptmShorthandModification = '';
                            //     var ptmShorthandSite = '';
                            // }
                            // ;
                            //var ptmMassModification = e.modification.match(self.patt4);
                            // var ptmMassSite = e.modification.match(self.patt1);

                            // //console.log("start");
                            // //console.log(start);
                            // //console.log("offset");
                            // //console.log(offset);
                            // //console.log("decreaseOffset");
                            // //console.log(decreaseOffset);
                            ptmLocal.push({
                                "identifier": e.identifier,
                                //"ptmMassSite": ptmMassSite,
                                "originalType": ptmIndex, //0 for mass, 1 for mass difference
                                // "ptmMassModification": ptmMassModification,
                                // "ptmShorthandSite": ptmShorthandSite,
                                // "ptmShorthandModification": ptmShorthandModification,
                                // "shorthand": e.shorthand,
                                "ptmModification": e.input,
                                "location": offset - decreaseOffset + start
                            });
                            // //console.log("++++++++  ptmLocal  +++++++");
                            // //console.log(ptmLocal);
                            // //console.log("--------  ptmLocal  -------");
                        }


                    });

                ptm.push(ptmLocal);
            });
            // //console.log("peptide");
            // //console.log(peptides[i]);
            // ////console.log(start);
            // //console.log("ptm");
            // //console.log(ptm);
            //var pr_ac = [];
            var geneResponse = {};
            var geneResponseArray = [];
            var geneArray = [];
            var ptmProteinsMassArray = [];
            var ptmProteinsShorthandArray = [];
            var ptmProteinsMassAllArray = [];
            var ptmProteinsShorthandAllArray = [];

            for (var pepToModIter = 0; pepToModIter < firstPrositeResponseFiltered.length; pepToModIter++) {

                // var geneResponse = {};
                // var geneResponseArray = [];
                geneArray = [];
                ptmProteinsMassArray = [];
                ptmProteinsShorthandArray = [];
                ptmProteinsMassAllArray = [];
                ptmProteinsMixAllArray = [];
                ptmProteinsShorthandAllArray = [];


                var prRes = firstPrositeResponseFiltered[pepToModIter];
                // //console.log("prRes");
                // //console.log(prRes);
                var ptmRes = ptm[pepToModIter];
                //pr_ac.push(prRes.sequence_ac);
                // //console.log("ptmRes");
                // //console.log(ptmRes);
                ////console.log(ptmRes);
                // //console.log(prRes.sequence_ac);
                // //console.log(proteinMap[prRes.sequence_ac]);
                ////console.log(proteinMap[prRes.sequence_ac]);
                if (prRes.sequence_ac != "") {
                    // //console.log("prRes.sequence_ac");
                    // //console.log(prRes.sequence_ac);

                    proteinMap[prRes.sequence_ac].map(function (e2) {
                        geneArray.push(e2);
                    });

                    for (var geneIter = 0; geneIter < proteinMap[prRes.sequence_ac].length; geneIter++) {

                        var genePr = proteinMap[prRes.sequence_ac][geneIter];
                        // //console.log("genePr");
                        // //console.log(genePr);
                        var ptmProteinMassAll = prRes.sequence_ac.toString();
                        var ptmProteinShorthandAll = prRes.sequence_ac.toString();
                        var ptmProteinMixAll = prRes.sequence_ac.toString();
                        for (var ptmIter = 0; ptmIter < ptmRes.length; ptmIter++) {
                            var ptmItem = ptmRes[ptmIter];
                            //console.log("ptmItem");
                            //console.log(ptmItem);
                            var ptmProteinMass = prRes.sequence_ac.toString() + '[' + ptmItem.ptmMassModification + '@' + ptmItem.location + ']';
                            ptmProteinsMassArray.push(ptmProteinMass);
                            ptmProteinMassAll = ptmProteinMassAll + '[' + ptmItem.ptmMassModification + '@' + ptmItem.location + ']';
                            // if (ptmItem.originalType == 1) {
                            //     //Shorthand
                            //     ptmProteinMixAll = ptmProteinMixAll + '[' + ptmItem.ptmShorthandModification + ptmItem.ptmShorthandSite + '@' + ptmItem.location + ']';
                            //
                            // }else{
                            //     //mass
                            //     ptmProteinMixAll = ptmProteinMixAll + '[' + ptmItem.ptmMassSite + ptmItem.ptmMassModification + '@' + ptmItem.location + ']';
                            //
                            // }
                            ptmProteinMixAll = ptmProteinMixAll + '{' + ptmItem.ptmModification + '@' + ptmItem.location + '}';

                            // //console.log("ptmProteinMixAll");
                            // //console.log(ptmProteinMixAll);
                            // if (ptmItem.ptmShorthandModification != '') {
                            //     var ptmProteinShorthand = prRes.sequence_ac.toString() + '[' + ptmItem.ptmShorthandModification + ptmItem.ptmShorthandSite + '@' + ptmItem.location + ']';
                            //     ptmProteinsShorthandArray.push(ptmProteinShorthand);
                            //     ptmProteinShorthandAll = ptmProteinShorthandAll + '[' + ptmItem.ptmShorthandModification + ptmItem.ptmShorthandSite + '@' + ptmItem.location + ']';
                            //     // if (self.geneIdList.indexOf(geneId[geneIdIter]) === -1) {
                            //     //     self.geneIdList.push(geneId[geneIdIter]);
                            //     //     // //console.log("geneIdList");
                            //     //     // //console.log(self.geneIdList);
                            //     // }
                            //
                            //     // if (ptmItem.ptmShorthandModification[0] === "ph" && self.geneIdListPhosphorylation.indexOf(ptmProteinShorthand) === -1) {
                            //     //     ////console.log("here");
                            //     //     self.geneIdListPhosphorylation.push(ptmProteinShorthand);
                            //     //     // //console.log(self.geneIdListPhosphorylation);
                            //     //
                            //     // }
                            //     //
                            //     // if (ptmItem.ptmShorthandModification[0] === "ac" && self.geneIdListAcetylations.indexOf(ptmProteinShorthand) === -1) {
                            //     //     ////console.log("here");
                            //     //     self.geneIdListAcetylations.push(ptmProteinShorthand);
                            //     //     // //console.log(self.geneIdListAcetylations);
                            //     //
                            //     // }
                            //     //
                            //     // if (ptmItem.ptmShorthandModification[0] === "me" && self.geneIdListMethylation.indexOf(ptmProteinShorthand) === -1) {
                            //     //     ////console.log("here");
                            //     //     self.geneIdListMethylation.push(ptmProteinShorthand);
                            //     //     // //console.log(self.geneIdListMethylation);
                            //     //
                            //     // }
                            // }
                        }
                        // //console.log("ptmProteinMassAll");
                        // //console.log(ptmProteinMassAll);
                        // //console.log("ptmProteinShorthandAll");
                        // //console.log(ptmProteinShorthandAll);
                        if (ptmProteinsMixAllArray.indexOf(ptmProteinMixAll) === -1) {
                            ////console.log("here");
                            ptmProteinsMixAllArray.push(ptmProteinMixAll);
                            // //console.log(self.geneIdListShorthandCombined);
                        }
                        // if (ptmProteinsMassAllArray.indexOf(ptmProteinMassAll) === -1) {
                        //     ////console.log("here");
                        //     ptmProteinsMassAllArray.push(ptmProteinMassAll);
                        //     // //console.log(self.geneIdListShorthandCombined);
                        // }
                        // if (ptmProteinsShorthandAllArray.indexOf(ptmProteinShorthandAll) === -1) {
                        //     ////console.log("here");
                        //     ptmProteinsShorthandAllArray.push(ptmProteinShorthandAll);
                        //     // //console.log(self.geneIdListShorthandCombined);
                        // }
                        // ptmProteinsMassAllArray.push(ptmProteinMassAll);
                        // ptmProteinsShorthandAllArray.push(ptmProteinShorthandAll);
                        // if (self.geneIdListShorthandCombined.indexOf(ptmProteinShorthandAll) === -1) {
                        //     ////console.log("here");
                        //     self.geneIdListShorthandCombined.push(ptmProteinShorthandAll);
                        //     // //console.log(self.geneIdListShorthandCombined);
                        // }
                        //
                        // if (self.geneIdListMassCombined.indexOf(ptmProteinMassAll) === -1) {
                        //     ////console.log("here");
                        //     self.geneIdListMassCombined.push(ptmProteinMassAll);
                        //     // //console.log(self.geneIdListMassCombined);
                        // }

                    }
                }
                ////console.log(ptmProteinsMassArray);
                ////console.log(ptmProteinsShorthandArray);
                geneResponse = {
                    "sequence_ac": prRes.sequence_ac,
                    "geneArray": geneArray,
                    "ptmProteinsMass": ptmProteinsMassArray,
                    "ptmProteinsShorthand": ptmProteinsShorthandArray,
                    "ptmProteinsMassAll": ptmProteinsMassAllArray,
                    "ptmProteinsMixAll": ptmProteinsMixAllArray,
                    "ptmProteinsShorthandAll": ptmProteinsShorthandAllArray

                };
                geneResponseArray.push(geneResponse);
            }

            self.geneResponseJson = {
                "motif": peptide,
                "length": firstPrositeResponseFiltered.length,
                "response": geneResponseArray
            };
            self.peptideToModificationList = self.peptideToModificationList.concat(self.geneResponseJson);
            ////console.log(self.peptideToModificationList);

            self.plnFormatOne.push({
                "PLN": {"ver": "ProteoForm"},
                "REF": {"uniprot": uniprot},
                "SYM": {"hugo": hugo},
                "DES": {},
                "VAR": {},
                "PTM": ptm
            });

            self.plnFormatTwo.push({
                "PLN": {"ver": "InChl-like"},
                "REF": {"uniprot": uniprot},
                "SYM": {"hugo": hugo},
                "DES": {},
                "VAR": {},
                "PTM": ptm
            });

            self.plnFormatThree.push({
                "PLN": {"ver": "all_hits"},
                "REF": {"uniprot": uniprot},
                "SYM": {"hugo": hugo},
                "DES": {},
                "VAR": {},
                "PTM": ptm
            });


            //This function is used to save the peptideFalg data
            SharedService.setVar('plnFormatOne', self.plnFormatOne);
            SharedService.setVar('plnFormatTwo', self.plnFormatTwo);
            SharedService.setVar('plnFormatThree', self.plnFormatThree);

        };

        self.peptideToModificationListOrig = self.peptideToModificationList;
        // //console.log(self.plnFormatOne);
        // //console.log(self.plnFormatTwo);
        // SharedService.setVar('plnFormatOne', self.plnFormatOne);
        // SharedService.setVar('plnFormatTwo', self.plnFormatTwo);
        self.parallelJson = [];
        var parallelUniquePep = [];
        var parallelUniquePtm = [];
        var parallelUniqueProtein = [];
        var parallelUniqueGene = [];
        var parallelNrows = 0;
        //Generate json file for parallel view
        ////console.log("Generate json file for parallel view");
        // console.log("self.peptideToModificationList");
        // console.log(self.peptideToModificationList);
        self.peptideToModificationList.map(function (e) {
            ////console.log(e);
            var parallelPep = e.motif;
            if (parallelUniquePep.indexOf(parallelPep) === -1) {
                parallelUniquePep.push(parallelPep);
            }

            e.response.map(function (e2) {
                ////console.log(e2);
                var parallelProt = e2.sequence_ac;
                // //console.log("<<<<<<<<>>>>>>>>>");
                // //console.log(parallelProt);
                // //console.log(e2.ptmProteinsMassAll);
                // //console.log(e2.ptmProteinsMixAll);
                //var parallelPtm = e2.ptmProteinsMassAll[0];
                var parallelPtm = e2.ptmProteinsMixAll[0];
                ////console.log(parallelPtm);
                if (parallelUniqueProtein.indexOf(parallelProt) === -1) {
                    parallelUniqueProtein.push(parallelProt);
                }
                if (parallelUniquePtm.indexOf(parallelPtm) === -1) {
                    parallelUniquePtm.push(parallelPtm);
                }
                ////console.log(e2);
                for (parallelIter = 0; parallelIter < e2.geneArray.length; parallelIter++) {
                    // //console.log(parallelPep);
                    // //console.log(parallelProt);
                    // //console.log(e2.geneArray[parallelIter]);
                    // //console.log(e2.ptmProteinsMassAll[parallelIter]);
                    var parallelGene = e2.geneArray[parallelIter];
                    if (parallelUniqueGene.indexOf(parallelGene) === -1) {
                        parallelUniqueGene.push(parallelGene);
                    }
                    var parallelJsonItem = {};
                    var ptmProteinToPeptideToAbundanceJsonItem = {};

                    parallelJsonItem.Peptide = parallelPep;
                    parallelJsonItem.Protein = parallelProt;
                    parallelJsonItem.Gene = parallelGene;
                    parallelJsonItem.ptmProtein = parallelPtm;
                    ////console.log(parallelPep);
                    self.parallelJson.push(parallelJsonItem);
                    //Generate ptmProteinToAbundance
                    ////console.log("ptmProteinToAbundance");
                    if (!(parallelPtm in self.ptmProteinToAbundance)){
                        self.ptmProteinToAbundance[parallelPtm] = self.peptideToAbundance[parallelPep] / self.peptideToNumberOfProteins[parallelPep];
                    }
                    else{
                        self.ptmProteinToAbundance[parallelPtm] += self.peptideToAbundance[parallelPep] / self.peptideToNumberOfProteins[parallelPep];

                    }
                    //self.ptmProteinToAbundance[parallelPtm] = self.peptideToAbundance[parallelPep] / self.peptideToNumberOfProteins[parallelPep];
                    ptmProteinToPeptideToAbundanceJsonItem.Peptide = parallelPep;
                    ptmProteinToPeptideToAbundanceJsonItem.abundance = self.ptmProteinToAbundance[parallelPtm];
                    self.ptmProteinToPeptideToAbundance[parallelPtm] = ptmProteinToPeptideToAbundanceJsonItem;
                    //parallelNrows += 1;
                }


            })


        })
        // console.log("self.geneToAbundance");
        // console.log(self.geneToAbundance);
        // console.log("self.ptmProteinToAbundance");
        // console.log(self.ptmProteinToAbundance);
        // console.log("self.ptmProteinToAbundance");
        // console.log(self.ptmProteinToAbundance);
        // console.log("self.parallelJson");
        // console.log(self.parallelJson);
        // console.log("self.ptmProteinToPeptideToAbundance");
        // console.log(self.ptmProteinToPeptideToAbundance);
        // self.go_dic = {};
        // self.reactome_dic = {};
        // self.subcellular_location_dic = {};
        self.subCellularTableData = [];
        self.subCellularLabels = [];
        self.subCellularValues = [];

        self.reactomeTableData = [];
        self.reactomeLabels = [];
        self.reactomeValues = [];

        self.goTableData = [];
        self.goLabels = [];
        self.goValues = [];
        var reactome_dic_total = 0;
        var subcellular_location_dic_total = 0;
        var go_dic_total = 0;


        for (var key in self.subcellular_location_dic) {
            if (self.subcellular_location_dic.hasOwnProperty(key)) {
                subcellular_location_dic_total += self.subcellular_location_dic[key]["num"];
            }
        }

        for (var key in self.go_dic) {
            if (self.go_dic.hasOwnProperty(key)) {
                go_dic_total += self.go_dic[key]["num"];
            }
        }
        for (var key in self.reactome_dic) {
            if (self.reactome_dic.hasOwnProperty(key)) {
                reactome_dic_total += self.reactome_dic[key]["num"];
            }
        }
        //======================================
        for (var key in self.subcellular_location_dic) {
            if (self.subcellular_location_dic.hasOwnProperty(key)) {
                self.subcellular_location_dic[key]["num"] = 100.0 * self.subcellular_location_dic[key]["num"] / subcellular_location_dic_total;
                self.subCellularTableData.push({
                    "name": key,
                    "percent": self.subcellular_location_dic[key]["num"],
                    "proteins": self.subcellular_location_dic[key]["proteins"]
                });
                self.subCellularLabels.push(key);
                self.subCellularValues.push(self.subcellular_location_dic[key]["num"]);
            }
        }

        for (var key in self.go_dic) {
            if (self.go_dic.hasOwnProperty(key)) {
                self.go_dic[key]["num"] = 100.0 * self.go_dic[key]["num"] / go_dic_total;
                self.goTableData.push({
                    "id": key,
                    "value": self.go_dic[key]["value"],
                    "percent": self.go_dic[key]["num"],
                    "proteins": self.go_dic[key]["proteins"]
                });
                self.goLabels.push(self.go_dic[key]["value"]);
                self.goValues.push(self.go_dic[key]["num"]);
            }
        }
        for (var key in self.reactome_dic) {
            if (self.reactome_dic.hasOwnProperty(key)) {
                self.reactome_dic[key]["num"] = 100.0 * self.reactome_dic[key]["num"] / reactome_dic_total;
                self.reactomeTableData.push({
                    "id": key,
                    "value": self.reactome_dic[key]["value"],
                    "percent": self.reactome_dic[key]["num"],
                    "proteins": self.reactome_dic[key]["proteins"]
                });
                self.reactomeLabels.push(self.reactome_dic[key]["value"]);
                self.reactomeValues.push(self.reactome_dic[key]["num"]);
            }
        }
        //console.log("reactomeValues");
        //console.log(self.reactomeLabels);
        //console.log(self.reactomeValues);
        //console.log(self.reactomeTableData);
        //console.log("goeValues");
        //console.log(self.goLabels);
        //console.log(self.goValues);
        //console.log(self.goTableData);
        //console.log("subcell");
        //console.log(self.subCellularLabels);
        //console.log(self.subCellularValues);
        //console.log(self.subCellularTableData);
        // self.subCellularTableData =[{"name":"c1","percent":11},
        //     {"name":"c2","percent":11},
        //     {"name":"c4","percent":11},
        //     {"name":"c5","percent":11},
        //     {"name":"c6","percent":11},
        //     {"name":"c3","percent":11}];
        // self.subCellularLabels = ['US', 'China', 'European Union', 'Russian Federation', 'Brazil', 'India', 'Rest of World' ];
        // self.subCellularValues = [16, 15, 12, 6, 5, 4.333, 41.666];
        //
        // self.reactomeTableData =[{"id":"rc1","value":"cc1","percent":12},
        //     {"id":"rc2","value":"cc2","percent":12},
        //     {"id":"rc4","value":"cc4","percent":12},
        //     {"id":"rc5","value":"cc5","percent":12},
        //     {"id":"rc6","value":"cc6","percent":12},
        //     {"id":"rc3","value":"cc3","percent":12}];
        // self.reactomeLabels = ['rChina', 'rrEuropean Union', 'rRussian Federation', 'rBrazil', 'rIndia', 'rRest of World' ];
        // self.reactomeValues = [31, 12, 6, 5, 4.333, 41.666];
        //
        // self.goTableData =[{"id":"gc1","value":"cc1","percent":14},
        //     {"id":"gc2","value":"cc2","percent":14},
        //     {"id":"gc4","value":"cc4","percent":14},
        //     {"id":"gc5","value":"cc5","percent":14},
        //     {"id":"gc6","value":"cc6","percent":14},
        //     {"id":"gc3","value":"cc3","percent":14}];
        // self.goLabels = ['gEuropean Union', 'gRussian Federation', 'gBrazil', 'gIndia', 'gRest of World' ];
        // self.goValues = [43, 6, 5, 4.333, 41.666];
        // ===============================================================
        // ===============================================================
        // ===============================================================
        self.tableSubCellular = new NgTableParams({
            count: 5
        }, {
            total: self.subCellularTableData.length, dataset: self.subCellularTableData, counts: [5, 10, 25]
        });

        var subCellularData = [{
            values: self.subCellularValues,
            labels: self.subCellularLabels,
            domain: {column: 0},
            textposition: 'inside',
            name: '',
            hoverinfo: 'label+percent+name',
            hole: .4,
            type: 'pie'
        }
        ];

        var subCellularLayout = {
            title: '',
            height: 400,
            width: 400,
            grid: {rows: 1, columns: 1},
            showlegend: false,
            annotations: [
                {
                    font: {
                        size: 14
                    },
                    showarrow: false,
                    text: '',
                    x: 0.5,
                    y: 0.5
                }
            ]
        };

        Plotly.newPlot('subcellularDiv', subCellularData, subCellularLayout);
        // ===============================================================
        // ===============================================================
        // ===============================================================
        self.tableReactome = new NgTableParams({
            count: 5
        }, {
            total: self.reactomeTableData.length, dataset: self.reactomeTableData, counts: [5, 10, 25]
        });

        var reactomeData = [{
            values: self.reactomeValues,
            labels: self.reactomeLabels,
            domain: {column: 0},
            textposition: 'inside',
            name: '',
            hoverinfo: 'label+percent+name',
            hole: .4,
            type: 'pie'
        }
        ];

        var reactomeLayout = {
            title: '',
            height: 400,
            width: 400,
            grid: {rows: 1, columns: 1},
            showlegend: false,
            annotations: [
                {
                    font: {
                        size: 14
                    },
                    showarrow: false,
                    text: '',
                    x: 0.5,
                    y: 0.5
                }
            ]
        };

        Plotly.newPlot('reactomeDiv', reactomeData, reactomeLayout);
        // ===============================================================
        // ===============================================================
        // ===============================================================
        self.tableGO = new NgTableParams({
            count: 5
        }, {
            total: self.goTableData.length, dataset: self.goTableData, counts: [5, 10, 25]
        });

        var goData = [{
            values: self.goValues,
            labels: self.goLabels,
            textposition: 'inside',
            domain: {column: 0},
            name: '',
            hoverinfo: 'label+percent+name',
            hole: .4,
            type: 'pie'
        }
        ];

        var goLayout = {
            title: '',
            height: 400,
            width: 400,
            grid: {rows: 1, columns: 1},
            showlegend: false,
            annotations: [
                {
                    font: {
                        size: 14
                    },
                    showarrow: false,
                    text: '',
                    x: 0.5,
                    y: 0.5
                }
            ]
        };

        Plotly.newPlot('goDiv', goData, goLayout);

        if (self.showOutputex1orex2 === 'ex2Id') {

            refineSelectedList(self.sliderFoldChangeValue, self.sliderSignificanceValue);
            callVolcanoPlot(self.sliderFoldChangeValue, self.sliderSignificanceValue);
        }

        // ===============================================================
        // ===============================================================
        // ===============================================================
        //console.log("peptideToNumberOfProteins");
        //console.log(self.peptideToNumberOfProteins);

        //console.log("peptideToAbundance");
        //console.log(self.peptideToAbundance);
        //console.log("ptmProteinToAbundance");
        //console.log(self.ptmProteinToAbundance);
        //console.log("parallelJson");
        //console.log(self.parallelJson);
        //console.log("ptmProteinToPeptideToAbundance");
        //console.log(self.ptmProteinToPeptideToAbundance);
        //self.parallelJson
        // //console.log("self.peptideToModificationList");
        // //console.log(self.peptideToModificationList);

        // self.ptmProteinToAbundance.map(function (e) {
        //     ////console.log(e);
        //     var parallelPep = e.motif;
        //     if (parallelUniquePep.indexOf(parallelPep) === -1) {
        //         parallelUniquePep.push(parallelPep);
        //     }
        //
        //     e.response.map(function (e2) {

        self.geneIdListLength = self.geneIdList.length;
        ////console.log(self.geneIdListLength);



        //self.makeParallelGrid(self.peptideToModificationList);
        // //console.log(self.geneIdListShorthandCombined);
        // //console.log(self.geneIdListMassCombined);
        self.inputPtmProteins = self.geneIdListMassCombined;
        self.progressPercent = 100;
        self.secondPageQuery = false;
        // //console.log("!self.secondPageQuery");
        // //console.log(!self.secondPageQuery);
        self.waiting = false;

        SharedService.setVar("genesForProtein2Pathways", self.genes);
        //$window.sessionStorage.setItem("genesForProtein2Pathways", self.genes);

        SharedService.setVar("organismForm", self.organismForm);
        SharedService.setVar("proteinForm", self.proteinForm);
        SharedService.setVar("proteinDb", self.proteinDb);

        SharedService.setVar("tableGO", self.tableGO);
        SharedService.setVar("tableSubCellular", self.tableSubCellular);
        SharedService.setVar("tableReactome", self.tableReactome);

        SharedService.setVar("subCellularTableData", self.subCellularTableData);
        SharedService.setVar("subCellularValues", self.subCellularValues);
        SharedService.setVar("subCellularLabels", self.subCellularLabels);

        SharedService.setVar("reactomeTableData", self.reactomeTableData);
        SharedService.setVar("reactomeValues", self.reactomeValues);
        SharedService.setVar("reactomeLabels", self.reactomeLabels);

        SharedService.setVar("goTableData", self.goTableData);
        SharedService.setVar("goLabels", self.goLabels);
        SharedService.setVar("goValues", self.goValues);



        //$window.sessionStorage.setItem("organism", self.organismForm);

        SharedService.setVar("uniprotJsonObjectAllForProtein2Pathways", self.uniprotJsonObjectAll);
        //$window.sessionStorage.setItem("uniprotJsonObjectAllForProtein2Pathways",self.uniprotJsonObjectAll);

        //SharedService.setVar("massPtmProteinsForProtein2Pathways", self.geneIdListMassCombined);
        //$window.sessionStorage.setItem("massPtmProteinsForProtein2Pathways", self.geneIdListMassCombined);

        SharedService.setVar("shorthandPtmProteinsForProtein2Pathways", self.geneIdListShorthandCombined);
        //$window.sessionStorage.setItem("shorthandPtmProteinsForProtein2Pathways", self.geneIdListShorthandCombined);

        SharedService.setVar("waiting", self.waiting);
        //$window.sessionStorage.setItem("waitingForPeptideToProtein", self.waiting);
        self.showOutputPathway = false;
        self.showOutputPtm = false;
        SharedService.setVar("showOutputPathway", self.showOutputPathway);
        SharedService.setVar("showOutputPtm", self.showOutputPtm);
        SharedService.setVar("showOutput", self.showOutput);

        SharedService.setVar("prositeFoundNum", self.prositeFoundNum);
        SharedService.setVar("motifLength", self.motifLength);
        SharedService.setVar("uniprotFoundNum", self.uniprotFoundNum);
        SharedService.setVar("uniprotLength", self.uniprotLength);
        SharedService.setVar("geneIdListLength", self.geneIdListLength);

        SharedService.setVar('peptideToModificationList', self.peptideToModificationList);
        SharedService.setVar('peptideToModificationListOrig', self.peptideToModificationListOrig);
        SharedService.setVar('showOverAllParallelSVG', self.showOverAllParallelSVG);
        SharedService.setVar('showPLN', self.showPLN);

        SharedService.setVar('prResponseList', self.prResponseList);
        SharedService.setVar('sequence_acListComplete', self.sequence_acListComplete);
        //SharedService.setVar('peptideToModificationList', self.peptideToModificationList);
        //SharedService.setVar('inputMassPtmProteins',self.inputMassPtmProteins);

        self.proteinIdListMassCombinedWithAbundance = [];
        self.genesWithAbundance = [];
        for (var keyIter in self.ptmProteinToAbundance) {
            if (keyIter != "NA" && keyIter != "undefined") {
                if (self.ptmProteinToAbundance.hasOwnProperty(keyIter)) {
                    var valueIter = self.ptmProteinToAbundance[keyIter];
                    if (!isNaN(valueIter)) {
                        self.proteinIdListMassCombinedWithAbundance.push(keyIter + " " + valueIter)
                    }
                    else {
                        self.proteinIdListMassCombinedWithAbundance.push(keyIter)
                    }
                }
            }
        }

        for (var keyIter in self.geneToAbundance) {
            //console.log(keyIter);
            if (keyIter != "NA" && keyIter != "undefined") {
                // console.log(keyIter);
                // if ( keyIter != "undefined") {
                //     console.log(keyIter);
                //     if (!isNaN(keyIter) ) {
                        //console.log(keyIter);
                        if (self.geneToAbundance.hasOwnProperty(keyIter)) {
                            var valueIter = self.geneToAbundance[keyIter];
                            if (!isNaN(valueIter)) {
                                self.genesWithAbundance.push(keyIter + " " + valueIter)
                            }
                            else {
                                self.genesWithAbundance.push(keyIter)
                            }
                        }
                //     }
                // }
            }
        }


        SharedService.setVar("peptideToAbundance", self.peptideToAbundance);
        SharedService.setVar("peptideToNumberOfProteins", self.peptideToNumberOfProteins);
        SharedService.setVar("inputMassPtmProteins", self.proteinIdListMassCombinedWithAbundance);

        SharedService.setVar("inputShorthandPtmProteins", self.geneIdListShorthandCombined);
        SharedService.setVar('genes',self.genesWithAbundance);

        //SharedService.setVar("organismFormProteinToPathway", self.organismForm);
        //organismFormProteinToPathway
        //$window.sessionStorage.setItem("showOutputForPeptideToProtein", self.showOutput);


    }
    // getElementById('parallel').style.width = self.parallelWidth;
    // getElementById('parallel').style.height = self.parallelHeight;
    // var timeoutPromise;
    // var delayInMs = 2000;
    //Pathway Analysis Text +++++++++++++++++++++++++++++++++++++++

    self.genePlaces = [];
    self.inputGeneInfo = [];

    Array.prototype.clean = function (deleteValue) {
        for (var i = 0; i < this.length; i++) {
            if (this[i] == deleteValue) {
                this.splice(i, 1);
                i--;
            }
        }
        return this;
    };


    self.changeToP100 = function () {
        self.genes = "DYRK1A 0.461099\n\
        RPS6KA3 1.24165\n\
        HN1 0.39179\n\
        ZC3HC1 -0.81353\n\
        NCOR2 -0.061737\n\
        OCIAD1 -0.09643\n\
        PDPK1 0.097759\n\
        ABI1 0.588017\n\
        WDR20 -0.15000\n\
        MAP4 -2.95647\n\
        FAM129B 0.019645\n\
        TMSB4X 0.88214\n\
        TMSB4X 0.9800\n\
        AP1GBP1 -1.149179\n\
        ZC3H14 0.93623\n\
        LARP5 0.5108248\n\
        MAP3K7 0.105289\n\
        BRD4 0.7733867\n\
        KIF4A -3.384948\n\
        C22orf9 -2.96875\n\
        FOSL2 0.408887\n\
        JUND 0.2169463\n\
        RPL12 -0.98894\n\
        NUP214 -0.59864\n\
        TMPO -2.223487\n\
        BAT2 -0.011437\n\
        FASN 0.768389\n\
        FASN 0.518356\n\
        FAM76B -0.20854\n\
        AHNAK -0.15571\n\
        PAK2 1.08313\n\
        RPS6KA1 -1.064138\n\
        RPS6KA1 -3.20086\n\
        NUFIP2 0.428257\n\
        RBBP6 0.079337\n\
        CASC3 0.53475\n\
        KIAA1704 0.75655\n\
        CCNYL1 0.193549\n\
        RNF169 -0.041419\n\
        ZNF740 0.81348\n\
        DDX54 0.913738\n\
        ATRIP -0.05033\n\
        DPF2 0.82016\n\
        SMARCC1 -0.07167\n\
        KHSRP 0.593808\n\
        SH3KBP1 -1.831307\n\
        C13orf8 -0.235423\n\
        PPP1R10 0.52387\n\
        TPX2 -1.28708\n\
        RSF1 0.558409\n\
        WAC 0.498148\n\
        UBE2O -1.19459\n\
        WDR26 0.29473\n\
        ANLN 0.296644\n\
        NANS 0.51163\n\
        TERF2IP 0.184049\n\
        LRWD1 0.630525\n\
        LIMA1 0.316775\n\
        LIMA1 0.649939\n\
        GPATCH8 0.769031\n\
        MAP3K2 0.2409052\n\
        THRAP3 -0.33558\n\
        BAT2D1 1.081598\n\
        BAT2D1 0.54329\n\
        CDC2 0.57929\n\
        TMPO 1.024626\n\
        PLEC1 -1.3094\n\
        SRRT 0.417544\n\
        SRRM2 0.17558\n\
        RBM17 0.51067\n\
        PFKP 0.632339\n\
        SRRM1 1.47925\n\
        ULK1 -1.06842\n\
        BRAF 0.286164\n\
        FOSL2 0.47064\n\
        EIF4A3 -0.82673\n\
        C17orf85 0.6774\n\
        ATAD2 -0.324736\n\
        ATXN2L 0.69807\n\
        VPRBP 0.13999\n\
        MARK2 -0.578569\n\
        EIF4A3 -1.601547\n\
        UHRF1BP1L -0.6075\n\
        IQGAP3 -1.13349\n\
        ZNF672 0.410076\n\
        NFATC2IP 0.40125\n\
        CLTA -0.1596\n\
        HAT1 0.271686\n\
        DHX16 0.44265\n\
        RPS6 -0.4977\n\
        RBM14 -0.79107\n\
        ALS2 0.329239\n\
        NOC2L 0.131214\n\
        SLC38A1 0.2219\n\
        NOLC1 -0.3440\n\
        PLEC1 -0.309069";

        SharedService.setVar('genes',self.genes);
    }
    self.changeToP100Genes = function () {
        self.genes = "DYRK1A 0.461099\n\
RPS6KA3 1.24165\n\
HN1 0.39179\n\
ZC3HC1 -0.81353\n\
NCOR2 -0.061737\n\
OCIAD1 -0.09643\n\
PDPK1 0.097759\n\
ABI1 0.588017\n\
WDR20 -0.15000\n\
MAP4 -2.95647\n\
FAM129B 0.019645\n\
TMSB4X 0.88214\n\
TMSB4X 0.9800\n\
AP1GBP1 -1.149179\n\
ZC3H14 0.93623\n\
LARP5 0.5108248\n\
MAP3K7 0.105289\n\
BRD4 0.7733867\n\
KIF4A -3.384948\n\
C22orf9 -2.96875\n\
FOSL2 0.408887\n\
JUND 0.2169463\n\
RPL12 -0.98894\n\
NUP214 -0.59864\n\
TMPO -2.223487\n\
BAT2 -0.011437\n\
FASN 0.768389\n\
FASN 0.518356\n\
FAM76B -0.20854\n\
AHNAK -0.15571\n\
PAK2 1.08313\n\
RPS6KA1 -1.064138\n\
RPS6KA1 -3.20086\n\
NUFIP2 0.428257\n\
RBBP6 0.079337\n\
CASC3 0.53475\n\
KIAA1704 0.75655\n\
CCNYL1 0.193549\n\
RNF169 -0.041419\n\
ZNF740 0.81348\n\
DDX54 0.913738\n\
ATRIP -0.05033\n\
DPF2 0.82016\n\
SMARCC1 -0.07167\n\
KHSRP 0.593808\n\
SH3KBP1 -1.831307\n\
C13orf8 -0.235423\n\
PPP1R10 0.52387\n\
TPX2 -1.28708\n\
RSF1 0.558409\n\
WAC 0.498148\n\
UBE2O -1.19459\n\
WDR26 0.29473\n\
ANLN 0.296644\n\
NANS 0.51163\n\
TERF2IP 0.184049\n\
LRWD1 0.630525\n\
LIMA1 0.316775\n\
LIMA1 0.649939\n\
GPATCH8 0.769031\n\
MAP3K2 0.2409052\n\
THRAP3 -0.33558\n\
BAT2D1 1.081598\n\
BAT2D1 0.54329\n\
CDC2 0.57929\n\
TMPO 1.024626\n\
PLEC1 -1.3094\n\
SRRT 0.417544\n\
SRRM2 0.17558\n\
RBM17 0.51067\n\
PFKP 0.632339\n\
SRRM1 1.47925\n\
ULK1 -1.06842\n\
BRAF 0.286164\n\
FOSL2 0.47064\n\
EIF4A3 -0.82673\n\
C17orf85 0.6774\n\
ATAD2 -0.324736\n\
ATXN2L 0.69807\n\
VPRBP 0.13999\n\
MARK2 -0.578569\n\
EIF4A3 -1.601547\n\
UHRF1BP1L -0.6075\n\
IQGAP3 -1.13349\n\
ZNF672 0.410076\n\
NFATC2IP 0.40125\n\
CLTA -0.1596\n\
HAT1 0.271686\n\
DHX16 0.44265\n\
RPS6 -0.4977\n\
RBM14 -0.79107\n\
ALS2 0.329239\n\
NOC2L 0.131214\n\
SLC38A1 0.2219\n\
NOLC1 -0.3440\n\
PLEC1 -0.309069";

        SharedService.setVar('genes',self.genes);
    }
    self.changeToP100PTMs = function () {
        self.inputMassPtmProteins = "Q13627{[pY]@321} 0.4611\n\
P51812{[pS]@369} 1.24165\n\
Q9UK76{[pS]@87} 0.3918\n\
Q86WB0{[pS]@321} -0.8135\n\
Q9Y618{[pS]@956} -0.0617\n\
Q9NX40{[pS]@108} -0.09643\n\
O15530{[pS]@241} 0.09776\n\
Q8IZP0{[pS]@183} 0.5880\n\
Q8TBZ3{[pS]@434} -0.15000\n\
P27816{[pS]@1073} -2.95647\n\
Q96TA1{[pS]@691} 0.01964\n\
P62328{[S+122]@2}{[M+16]@7} 0.8821\n\
P62328{[S+122]@2} 0.9800\n\
Q9UMZ2{[pS]@1075} -1.14918\n\
Q6PJT7{[pS]@515} 0.93623\n\
Q92615{[pS]@601} 0.51082\n\
O43318{[pS]@439} 0.105289\n\
O60885{[pS]@1117} 0.77338\n\
O95239{[pS]@801} -3.38494\n\
Q6ICG6{[pS]@362} -2.96875\n\
P15408{[pS]@200} 0.40888\n\
P17535{[pS]@100} 0.216946\n\
P30050{[pS]@38} -0.988941\n\
P35658{[pS]@1023} -0.59863\n\
P42167{[pS]@306} -2.22348\n\
P48634{[pS]@1219} -0.011437\n\
P49327{[pS]@207}{[M+16]@205}{[C+57]@212} 0.768389\n\
P49327{[pS]@207}{[C+57]@212} 0.51835\n\
Q5HYJ3{[pS]@193} -0.20854\n\
Q09666{[pS]@3426} -0.15571\n\
Q13177{[S+122]@2} 1.083130\n\
Q15418{[pS]@221}{[M+16]@229}{[C+57]@223} -1.0641\n\
Q15418{[pS]@221}{[C+57]@223} -3.2008\n\
Q7Z417{[pS]@652} 0.428257\n\
Q7Z6E9{[pS]@1179} 0.079337\n\
O15234{[pS]@265} 0.53475\n\
Q8IXQ4{[pS]@105} 0.75655\n\
Q8N7R7{[pS]@344} 0.1935\n\
Q8NCN4{[pS]@403} -0.041419\n\
Q8NDX6{[pS]@44} 0.81348\n\
Q8TDD1{[pS]@75}{[C+57]@73} 0.91374\n\
Q8WXE1{[pS]@224} -0.05033\n\
Q92785{[pS]@142} 0.82016\n\
Q92922{[pS]@310} -0.07167\n\
Q92945{[pS]@480} 0.593808\n\
Q96B97{[pS]@230} -1.8313\n\
Q96JM3{[pS]@405} -0.23542\n\
Q96QC0{[pS]@313} 0.523876\n\
Q9ULW0{[pS]@738} -1.287086\n\
Q96T23{[pS]@473} 0.558409\n\
Q9BTA9{[pS]@64} 0.4981\n\
Q9C0C9{[pS]@515} -1.19459\n\
Q9H7D7{[pS]@121} 0.29472\n\
Q9NQW6{[pS]@295} 0.29664\n\
Q9NR45{[pS]@275}{[C+57]@283}{[C+57]@287} 0.51163\n\
Q9NYB0{[pS]@203} 0.184049\n\
Q9UFC0{[pS]@212} 0.63052\n\
Q9UHB6{[pS]@362} 0.31677\n\
Q9UHB6{[pS]@490} 0.64994\n\
Q9UKJ3{[pS]@1035} 0.769032\n\
Q9Y2U5{[pS]@163} 0.2409052\n\
Q9Y2W1{[pS]@253} -0.33558\n\
Q9Y520{[pT]@2673} 1.081598\n\
Q9Y520{[pS]@1544} 0.54329\n\
P06493{[pT]@161} 0.57929\n\
P42167{[pT]@160} 1.0246259\n\
Q15149{[pT]@4030} -1.30946\n\
Q9BXP5{[pT]@544} 0.4175439\n\
Q9UQ35{[pT]@1492} 0.17558\n\
Q96I25{[pS]@222} 0.510677\n\
Q01813{[pS]@386} 0.63234\n\
Q8IYB3{[pS]@402} 1.479257\n\
O75385{[pS]@556} -1.06842\n\
P15056{[pS]@446} 0.286164\n\
P15408{[pS]@200}{[M+16]@209} 0.4706487\n\
P38919{[pS]@12}{[M+16]@7}{[A+42.010]@2} -0.826734\n\
Q53F19{[pS]@500} 0.6774\n\
Q6PL18{[pS]@327} -0.3247365\n\
Q8WWM7{[pS]@339} 0.69807\n\
Q9Y4B6{[pS]@1000} 0.13999\n\
Q7KZI7{[pT]@596} -0.578569\n\
P38919{[pS]@12}{[A+42.010]@2} -1.601547\n\
A0JNW5{[pS]@935} -0.60759\n\
Q86VI3{[pS]@1424} -1.133499\n\
Q499Z4{[pS]@189} 0.4100764\n\
Q8NCF5{[pS]@204} 0.4012565\n\
P09496{[pS]@105} -0.159615\n\
O14929{[pS]@361} 0.2716867\n\
O60231{[pS]@103} 0.442654\n\
P62753{[pS]@235} -0.497748\n\
Q96PK6{[pS]@618} -0.791066\n\
Q96Q42{[pS]@483} 0.3292391\n\
Q9Y3T9{[pS]@56} 0.131213\n\
Q9H2H9{[pS]@52} 0.22196\n\
Q14978{[pT]@610} -0.34400\n\
Q15149{M+16@4031}{[pT]@4030} -0.30907";

        // "Q9Y463[Y+79.966@273],Q13627[Y+79.966@321],P51812[pS@369],Q9UK76[pS@87],Q86WB0[pS@321],Q9Y618[pS@956],A0JNW5[pS@935],Q9NX40[pS@108],Q6A1A2[pS@214],O15530[pS@241],Q8IZP0[pS@183],Q8TBZ3[pS@434],P27816[pS@1073],Q96I25[pS@222],Q86VI3[pS@1424],Q96TA1[pS@691],P62328[S+122@2],P62328[S+122@2][M+16@7],P09496[pS@105],Q9UMZ2[pS@1075],Q6PJT7[pS@515],Q01813[pS@386],Q92615[pS@601],O14929[pS@361],O43318[pS@439],Q8IYB3[pS@402],O60885[pS@1117],O75385[pS@556],O95239[pS@801],Q6ICG6[pS@362],O60231[pS@103],P15056[pS@446],P15408[pS@200],P15408[pS@200][M+16@209],P05412[pS@73],P17535[pS@100],P30050[pS@38],P35658[pS@1023],P38919[pS@12][A+42@2],P38919[pS@12][M+16@7][A+42@2],P42167[pS@306],P48634[pS@1219],P49327[pS@207][C+57@212],P49327[pS@207][M+16@205][C+57@212],Q5HYJ3[pS@193],P62753[pS@235],Q09666[pS@3426],Q13177[S+122@2],P51812[pS@227][C+57@229],Q15418[pS@221][C+57@223],Q9UK32[pS@232][C+57@234],P51812[pS@227][M+16@235][C+57@229],Q15418[pS@221][M+16@229][C+57@223],Q9UK32[pS@232][M+16@240][C+57@234],Q499Z4[pS@189],Q53F19[pS@500],Q6PL18[pS@327],Q7Z417[pS@652],Q7Z6E9[pS@1179],O15234[pS@265],Q8IXQ4[pS@105],Q8N7R7[pS@344],Q8NCF5[pS@204],Q8NCN4[pS@403],Q8NDX6[pS@44],Q8TDD1[pS@75][C+57@73],Q8WWM7[pS@339],Q8WXE1[pS@224],Q92785[pS@142],Q92922[pS@310],Q92945[pS@480],Q96B97[pS@230],Q96JM3[pS@405],Q96PK6[pS@618],Q96Q42[pS@483],Q96QC0[pS@313],Q9ULW0[pS@738],Q96T23[pS@473],Q9BTA9[pS@64],Q92560[pS@460],Q9C0C9[pS@515],Q9H7D7[pS@121],Q9NQW6[pS@295],Q9NR45[pS@275][C+57@283],Q9NYB0[pS@203],Q9UFC0[pS@212],Q9UHB6[pS@362],Q9UHB6[pS@490],Q9UKJ3[pS@1035],Q9BXP5[pT@544],Q9Y2U5[pS@163],Q9Y2W1[pS@253],Q9Y3T9[pS@56],Q9Y4B6[pS@1000],Q9Y520[pT@2673],Q7KZI7[pT@596],Q9H2H9[pS@52],Q9Y520[pS@1544],P06493[pT@161],P42167[pT@160],P42166[pT@160],Q14978[pT@610],Q15149[pT@4030],Q15149[M+16@4031][pT@4030],Q9UQ35[pT@1492]";

        SharedService.setVar('inputMassPtmProteins',self.inputMassPtmProteins);
    }
    self.changeToP100Peptides = function () {


        self.textArea = "IYQY[+79.966]IQSR 0.461099\n\
TPKDS[+79.966]PGIPPSANAHQLFR 1.24165\n\
RNS[+79.966]SEASSGDFLDLK 0.39179\n\
LPLVPES[+79.966]PRR -0.8135318\n\
ANAS[+79.966]PQKPLDLK -0.06173748\n\
LENS[+79.966]PLGEALR -0.0964323\n\
ANS[+79.966]FVGTAQYVSPELLTEK 0.097759\n\
TNPPTQKPPS[+79.966]PPMSGR 0.5880172\n\
SNS[+79.966]LPHSAVSNAGSK -0.15000027\n\
VGS[+79.966]LDNVGHLPAGGAVK -2.9564762\n\
AAPEAS[+79.966]SPPASPLQHLLPGK 0.019645\n\
S[+122]DKPDM[+16]AEIEKFDK 0.88214\n\
S[+122]DKPDMAEIEKFDK 0.98000\n\
SLS[+79.966]LGDKEISR -1.149179\n\
DLVQPDKPAS[+79.966]PK 0.9362365\n\
SPS[+79.966]PAHLPDDPKVAEK 0.51082483\n\
S[+79.966]IQDLTVTGTEPGQVSSR 0.105289\n\
IHS[+79.966]PIIR 0.7733867\n\
TFS[+79.966]LTEVR -3.384948\n\
SLVGS[+79.966]WLK -2.968755\n\
S[+79.966]PPAPGLQPMR 0.40888\n\
LAS[+79.966]PELER 0.2169463\n\
IGPLGLS[+79.966]PK -0.98894\n\
TPS[+79.966]IQPSLLPHAAPFAK -0.598636\n\
HAS[+79.966]PILPITEFSDIPR -2.223487\n\
LIPGPLS[+79.966]PVAR -0.0114377\n\
LGM[+16]LS[+79.966]PEGTC[+57]K 0.768389\n\
LGMLS[+79.966]PEGTC[+57]K 0.518356\n\
ISNLS[+79.966]PEEEQGLWK -0.208545\n\
VSMPDVELNLKS[+79.966]PK -0.1557127\n\
S[+122]DNGELEDKPPAPPVR 1.08313\n\
KAYS[+79.966]FC[+57]GTVEYM[+16]APEVVNR -1.064139\n\
KAYS[+79.966]FC[+57]GTVEYMAPEVVNR -3.20086\n\
NDS[+79.966]WGSFDLR 0.428257\n\
LEVTEIVKPS[+79.966]PK 0.079337\n\
YGS[+79.966]PPQRDPNWNGER 0.534751\n\
QDDS[+79.966]PPRPIIGPALPPGFIK 0.75655\n\
SFS[+79.966]ADNFIGIQR 0.193549\n\
VLS[+79.966]PLIIK -0.0414197\n\
AGS[+79.966]PDVLR 0.813482\n\
LGPGRPLPTFPTSEC[+57]TS[+79.966]DVEPDTR 0.9137382\n\
LAAPSVSHVS[+79.966]PR -0.050331\n\
VDDDS[+79.966]LGEFPVTNSR 0.82016\n\
NEEPVRS[+79.966]PERR -0.07167\n\
LFIIRGS[+79.966]PQQIDHAK 0.593808\n\
S[+79.966]IEVENDFLPVEK -1.831307\n\
TAPTLS[+79.966]PEHWK -0.235422\n\
VLS[+79.966]PTAAKPSPFEGK 0.523876\n\
SSDQPLTVPVS[+79.966]PK -1.2870867\n\
FYETKEESYS[+79.966]PSKDR 0.558409\n\
SDS[+79.966]PENKYSDSTGHSK 0.498148\n\
S[+79.966]IPLSIK -1.19459\n\
RLS[+79.966]QSDEDVIR 0.294727\n\
ATS[+79.966]PVKSTTSITDAK 0.2966439\n\
ALGS[+79.966]PTKQLLPC[+57]EMAC[+57]NEK 0.511634\n\
YLLGDAPVS[+79.966]PSSQK 0.18404919\n\
ANS[+79.966]PEKPPEAGAAHKPR 0.63052\n\
SEVQQPVHPKPLS[+79.966]PDSR 0.31677\n\
ETPHS[+79.966]PGVEDAPIAK 0.649939\n\
SQS[+79.966]PHYFR 0.7690316\n\
DRS[+79.966]SPPPGYIPDELHQVAR 0.240905\n\
SPALKS[+79.966]PLQSVVVR -0.33558\n\
AFGSGIDIKPGT[+79.966]PPIAGR 1.08159\n\
SFS[+79.966]SQRPVDR 0.54329\n\
VYT[+79.966]HEVVTLWYR 0.579294\n\
SST[+79.966]PLPTISSSAENTR 1.024626\n\
QIT[+79.966]MEELVR -1.30946\n\
TQLWASEPGT[+79.966]PPLPTSLPSQNPILK 0.4175439\n\
ALPQT[+79.966]PRPR 0.17558\n\
S[+79.966]PTGPSNSFLANMGGTVAHK 0.51067\n\
S[+79.966]FAGNLNTYKR 0.6323\n\
HRPS[+79.966]PPATPPPK 1.479257\n\
LHS[+79.966]APNLSDLHVVRPK -1.06841\n\
TLGRRDS[+79.966]SDDWEIPDGQITVGQR 0.28616\n\
S[+79.966]PPAPGLQPM[+16]R 0.4706487\n\
A[+42.010]TTATM[+16]ATSGS[+79.966]AR -0.8267\n\
RPHS[+79.966]PEKAFSSNPVVR 0.67740\n\
KPNIFYSGPAS[+79.966]PARPR -0.324736\n\
QGSGRES[+79.966]PSLASR 0.69807\n\
HLPS[+79.966]PPTLDSIITEYLR 0.13999\n\
ST[+79.966]FHAGQLR -0.5785\n\
A[+42.010]TTATMATSGS[+79.966]AR -1.60154\n\
SMS[+79.966]VDLSHIPLKDPLLFK -0.60759\n\
S[+79.966]LTAHSLLPLAEK -1.1335\n\
IHVSRS[+79.966]PTRPR 0.410076\n\
TEFLDLDNSPLSPPS[+79.966]PR 0.401256\n\
LQS[+79.966]EPESIR -0.159615\n\
RLIS[+79.966]PYKK 0.271686\n\
LLEDS[+79.966]EESSEETVSR 0.44265\n\
RRLS[+79.966]SLR -0.497748\n\
RLS[+79.966]ESQLSFRR -0.79106\n\
RLS[+79.966]LPGLLSQVSPR 0.329239\n\
SPDKPGGS[+79.966]PSASRR 0.131213\n\
S[+79.966]LTNSHLEKK 0.22196\n\
LQTPNT[+79.966]FPKR -0.344000\n\
QIT[+79.966]M[+16]EELVR -0.30907";




        SharedService.setVar('textAreaFormatMD', self.textArea);
    }
    self.changeToGCPPeptides = function () {
        self.textArea = "T[+56]K[+56]QTAR	-0.041875744\n\
T[+56][meK]QTAR	-0.270535418\n\
T[+56][me2K]QTAR	0.087099586\n\
T[+56][me3K]QTAR	0.084202625\n\
T[+56][aK]QTAR	0.00598567\n\
K[+112.1]STGGK[+56]APR	0.058669849\n\
[meK]STGGK[+56]APR	-0.27182245\n\
[me2K]STGGK[+56]APR	-0.188828568\n\
[me3K]STGGK[+56]APR	0.010003377\n\
[aK]STGGK[+56]APR	-0.073966311\n\
K[+112.1]STGG[aK]APR	0.338447595\n\
[meK]STGG[aK]APR	-0.06495435\n\
[me2K]STGG[aK]APR	-0.140408052\n\
[me3K]STGG[aK]APR	-0.028568836\n\
[aK]STGG[aK]APR	-0.021538616\n\
K[+112.1][pS]TGGK[+56]APR	-0.260364406\n\
[meK][pS]TGGK[+56]APR	-0.242720645\n\
[me2K][pS]TGGK[+56]APR	0.080991582\n\
[me3K][pS]TGGK[+56]APR	0.203779469\n\
K[+112.1][pS]TGG[aK]APR	-0.118385096\n\
[meK][pS]TGG[aK]APR	-0.057803463\n\
[me2K][pS]TGG[aK]APR	-0.090454234\n\
[me3K][pS]TGG[aK]APR	0.696029983\n\
[aK][pS]TGG[aK]APR	0.49326908\n\
K[+112.1]QLATK[+56]AAR	-0.064527272\n\
[aK]QLATK[+56]AAR	-0.035241088\n\
K[+112.1]QLAT[aK]AAR	-0.301690347\n\
[aK]QLAT[aK]AAR	0.044519339\n\
[ubK]QLATK[+56]AAR	-0.481387993\n\
K[+112.1]QLAT[ubK]AAR	-0.428209673\n\
K[+112.1]SAPATGGVK[+56]K[+56]PHR	0.056694329\n\
[meK]SAPATGGVK[+56]K[+56]PHR	-0.147474495\n\
[meK]SAPATGGV[meK]K[+56]PHR	0.278627613\n\
[meK]SAPATGGV]me2K]K[+56]PHR	0.071481589\n\
[meK]SAPATGGV[me3K]K[+56]PHR	-0.127764989\n\
[me2K]SAPATGGVK[+56]K[+56]PHR	-0.186326202\n\
[me2K]SAPATGGV[meK]K[+56]PHR	-0.064597033\n\
[me2K]SAPATGGV[me2K]K[+56]PHR	-0.423770191\n\
[me2K]SAPATGGV[me3K]K[+56]PHR	-0.070469171\n\
[me3K]SAPATGGVK[+56]K[+56]PHR	-0.094543918\n\
[me3K]SAPATGGV[meK]K[+56]PHR	-0.333823023\n\
[me3K]SAPATGGV[me2K]K[+56]PHR	-0.358445739\n\
[aK]SAPATGGVK[+56]K[+56]PHR	0.674083892\n\
[aK]SAPATGGV[meK]K[+56]PHR	-0.194309632\n\
[aK]SAPATGGV[me2K]K[+56]PHR	0.339613114\n\
[aK]SAPATGGV[me3K]K[+56]PHR	0.220404071\n\
K[+112.1]SAPSTGGVK[+56]K[+56]PHR	-0.40551929\n\
Y[+56]RPGTVALR	-0.010554282\n\
Y[+56]QK[+56]STELLIR	0.151104493\n\
E[+56]IAQDFK[+56]TDLR	0.172918492\n\
E[+56]IAQDF[meK]TDLR	0.156914416\n\
E[+56]IAQDF[me2K]TDLR	0.183464036\n\
K[+112.1]SAPATGGV[meK]K[+56]PHR	0.124030959\n\
K[+112.1]SAPATGGV[me2K]K[+56]PHR	0.154400258\n\
K[+112.1]SAPATGGV[me3K]K[+56]PHR	0.080582639";

        SharedService.setVar('textAreaFormatMD', self.textArea);
    }














}]);





appModule.controller("ProteinCtrl", ['$scope', '$http', '$location', '$window', '$timeout', '$interval', '$routeParams', '$filter', 'filterFilter', 'SharedService', 'NgTableParams', '$uibModal', function ($scope, $http, $location, $window, $timeout, $interval, $routeParams, $filter, filterFilter, SharedService, NgTableParams, $uibModal) {
    //console.log("--------------- Restarting uniprot 2 pathway! ---------------");
    var self = this;
    self.progressPtmPercent = 0;
    self.modificationPattern = /[^A-Z]/g;
    self.modificationPatternWithLetter = /[A-Z]\[\+[\d\.]+]/g;
    self.modificationPatternSecondFormat = /\[[a-z]+[A-Z]+\]/g;
    //self.modificationPatternForAllPTMs = /[^[\]]+(?=])/g;

   // self.modificationPatternForAllPTMs = /{([()]+)}/g;
    self.modificationPatternForAllPTMs = /{(.+)}/g;
    self.modificationPatternForAllProteins = /(?:^|])([^[\]]+)/g;
    self.rowSplitPattern = /[,;\n]/;
    self.rowSplitPatternGenes = /[,;\n]/;
    self.cleanFormattedModifications = /\[/;
    self.patt1 = /[A-Z]/g;
    self.patt2 = /[a-z]/g;
    self.patt3 = /\d+/g
    self.patt4 = /[+\d\.]+/g;
    self.patt5 = /^[0-9]+([,.][0-9]+)?$/g;
    self.patt6 = /^[\d.]/g;

    self.modificationForGenes = /\b\w*[^\[]\w*\b/g;
    self.modificationForptmProteins = /\b\w*[\[]\w*\b/g;

    self.modificationMap = {'a': 42.03, 'm': 14.02, 'p': 79.97};
    self.modificationMapReverse = {41: 'a', 42: 'a', 43: 'a', 13: 'm', 14: 'm', 15: 'm', 79: 'p', 80: 'p', 81: 'p'};
    self.proteinMap = {};
    self.hugoProteinMap = {};
    self.computeWeightForUpdateSignor = SharedService.getVar('computeWeightForUpdateSignor');
    self.computeWeightForUpdatePtm = SharedService.getVar('computeWeightForUpdatePtm');
    self.computeWeightForUpdateDeepPhos = SharedService.getVar('computeWeightForUpdateDeepPhos');
    //console.log(self.computeWeightForUpdatePtm);
    self.computeWeightForUpdatePhospho = SharedService.getVar('computeWeightForUpdatePhospho');

    SharedService.getSiteVisit().then(function(successResponse){
        self.siteVisit = successResponse;
        //console.log(self.siteVisit);
    });
    self.signorWaiting = SharedService.getVar('signorWaiting');
    self.ptmWaiting = SharedService.getVar('ptmWaiting');
    self.phosphoWaiting = SharedService.getVar('phosphoWaiting');


    self.showSplash = SharedService.getVar('showSplash');
    self.firstVisit = SharedService.getVar('firstVisit');
    self.uniprotFoundNum = SharedService.getVar('uniprotFoundNum');
    //self.textAreaFormatMD = SharedService.getVar('textAreaFormatMD');
    //self.textAreaFormatSN = SharedService.getVar('textAreaFormatSN');
    //self.textArea = SharedService.getVar('textArea');
    // self.waiting = SharedService.getVar('waiting');
    // self.showOutput = SharedService.getVar('showOutput');
    self.genes = SharedService.getVar('genes').toString();
    //console.log('in protein2pathway, genes are:');
    //console.log(self.genes);
    self.organismForm = SharedService.getVar('organismForm');

    self.inputMassPtmProteins = SharedService.getVar('inputMassPtmProteins').toString();
    console.log(self.inputMassPtmProteins);
    self.inputShorthandPtmProteins = SharedService.getVar('inputShorthandPtmProteins').toString();
    //console.log('in protein2pathway, inputMassPtmProteins are:');
    //console.log(self.inputMassPtmProteins);
    //self.inputShorthandPtmProteins = SharedService.getVar('inputShorthandPtmProteins');
    self.uniprotJsonObjectAllForProtein2Pathways = SharedService.getVar('uniprotJsonObjectAllForProtein2Pathways');
    //self.genesForProtein2Pathways =  SharedService.getVar('genesForProtein2Pathways');
    //self.uniprotJsonObjectAllForProtein2Pathways = SharedService.getVar('uniprotJsonObjectAllForProtein2Pathways');
    //self.massPtmProteinsForProtein2Pathways = SharedService.getVar('massPtmProteinsForProtein2Pathways');
    //self.shorthandPtmProteinsForProtein2Pathways = SharedService.getVar('shorthandPtmProteinsForProtein2Pathways');
    self.waitingForPeptideToProtein = SharedService.getVar('waitingForPeptideToProtein');

    self.showOutputPhospho = SharedService.getVar('showOutputPhospho');
    self.showOutputSignor = SharedService.getVar('showOutputSignor');
    self.showOutputPtm = SharedService.getVar('showOutputPtm');

    self.showOutputPathway = SharedService.getVar('showOutputPathway');
    self.peptideToModificationList = SharedService.getVar('peptideToModificationList');

    self.showPhosphoGeneNetworkProcessed = SharedService.getVar('showPhosphoGeneNetworkProcessed');
    self.showPhosphoGeneNetwork = SharedService.getVar('showPhosphoGeneNetwork');

    self.showPhosphoDeepGeneNetworkProcessed = SharedService.getVar('showPhosphoDeepGeneNetworkProcessed');
    self.showPhosphoDeepGeneNetwork = SharedService.getVar('showPhosphoDeepGeneNetwork');

    self.showPtmGeneNetworkProcessed = SharedService.getVar('showPtmGeneNetworkProcessed');
    self.showPtmGeneNetwork = SharedService.getVar('showPtmGeneNetwork');

    self.showSignorGeneNetworkProcessed = SharedService.getVar('showSignorGeneNetworkProcessed');
    self.showSignorGeneNetwork = SharedService.getVar('showSignorGeneNetwork');

    //console.log('showPhosphoGeneNetwork');
    //console.log(self.showPhosphoGeneNetwork);
    self.blosum50Table = SharedService.getVar('blosum50Table');
    self.deepPhosTable = SharedService.getVar('deepPhosTable');
    self.PTM_table = SharedService.getVar('PTM_table');
    self.signor_table = SharedService.getVar('signor_table');

    self.enrichmentNetwork = SharedService.getVar('enrichmentNetwork');
    self.ptmNetwork = SharedService.getVar('ptmNetwork');
    self.signor_Network = SharedService.getVar('signor_Network');
    self.deepPhosNetwork = SharedService.getVar('deepPhosNetwork');

    self.network = SharedService.getVar('network');
    self.phosphoNetwork = SharedService.getVar('phosphoNetwork');
    self.kinaseNetwork = SharedService.getVar('kinaseNetwork');
    $scope.showGeneNetworkProcessed = SharedService.getVar('showGeneNetworkProcessed');
    $scope.showGeneEnrichmentProcessed = SharedService.getVar('showGeneEnrichmentProcessed');
    self.showGeneNetwork = SharedService.getVar('showGeneNetwork');
    $scope.showKinaseNetworkProcessed = SharedService.getVar('showKinaseNetworkProcessed');
    self.ptmToModifierPtmOrGene = SharedService.getVar('ptmToModifierPtmOrGene');
    self.proteinToPathwayPathwayOrGene = SharedService.getVar('proteinToPathwayPathwayOrGene');
    self.showPhosphoGraph = false;
    self.showSignorGraph = false;
    self.showPtmGraph = false;
    self.showKinaseGraph = false;
    self.showPathwayGraph = false;

    self.showEnrichmentGraph = false;

    self.showPhosphoGraphTmp = false;
    self.showPtmGraphTmp = false;
    self.showSignorGraphTmp = false;
    self.showKinaseGraphTmp = false;
    self.showPathwayGraphTmp = false;

    self.showEnrichmentGraphTmp = false;

    self.showGeneSubmit = false;
    self.showPtmSubmit = false;
    self.showSignorSubmit = false;
    $scope.phosphoOptions = SharedService.getVar('phosphoOptions');

    self.ptmResultTab = SharedService.getVar("ptmResultTab");

    //$scope.selectedphosphoPathways = SharedService.getVar('selectedphosphoPathways');

    $scope.selectedphosphoPathways = SharedService.getVar('selectedphosphoPathways');
    self.showGeneEnrichmentChangeProcessed = true;
    // self.showOutputPtm = false;
    // self.showOutputPathway = false;
    //     self.showGeneNetwork = false;
            //var svg = SharedService.getVar('svg');
    //SharedService.setVar('showModal', false);



    self.ex1orex2Protein = SharedService.getVar("ex1orex2Protein");
    //self.showOutputex1orex2 = SharedService.getVar("showOutputex1orex2");

    $('input[name=tabset2p][id=' + self.ex1orex2Protein + ']').prop('checked', true);
    $("input[name='tabset2p']").click(function () {
        self.ex1orex2Protein = this.id;
        console.log(self.ex1orex2Protein);

        SharedService.setVar("ex1orex2Protein", self.ex1orex2Protein);
        $scope.$apply();

    });

    $(document).ready(function () {
        $("#div1").scroll(function () {
            $("#div2").scrollTop($("#div1").scrollTop());
            $("#div2").scrollLeft($("#div1").scrollLeft());
            $("#div1-2").scrollTop($("#div1").scrollTop());
            $("#div1-2").scrollLeft($("#div1").scrollLeft());
        });
        $("#div1-2").scroll(function () {
            $("#div2").scrollTop($("#div1-2").scrollTop());
            $("#div2").scrollLeft($("#div1-2").scrollLeft());
            $("#div1").scrollTop($("#div1-2").scrollTop());
            $("#div1").scrollLeft($("#div1-2").scrollLeft());
        });
        $("#div2").scroll(function () {
            $("#div1").scrollTop($("#div2").scrollTop());
            $("#div1").scrollLeft($("#div2").scrollLeft());
            $("#div1-2").scrollTop($("#div2").scrollTop());
            $("#div1-2").scrollLeft($("#div2").scrollLeft());
        });

    });

    $(document).ready(function () {
        $("#div3").scroll(function () {
            $("#div4").scrollTop($("#div3").scrollTop());
            $("#div4").scrollLeft($("#div3").scrollLeft());
        });
        $("#div4").scroll(function () {
            $("#div3").scrollTop($("#div4").scrollTop());
            $("#div3").scrollLeft($("#div4").scrollLeft());
        });

    });


    $(document).ready(function () {
        $("#div5").scroll(function () {
            $("#div6").scrollTop($("#div5").scrollTop());
            $("#div6").scrollLeft($("#div5").scrollLeft());
        });
        $("#div6").scroll(function () {
            $("#div5").scrollTop($("#div6").scrollTop());
            $("#div5").scrollLeft($("#div6").scrollLeft());
        });

    });


    $(document).ready(function () {
        $("#div7").scroll(function () {
            $("#div8").scrollTop($("#div7").scrollTop());
            $("#div8").scrollLeft($("#div7").scrollLeft());
        });
        $("#div8").scroll(function () {
            $("#div7").scrollTop($("#div8").scrollTop());
            $("#div7").scrollLeft($("#div8").scrollLeft());
        });

    });

    $(document).ready(function () {
        $("#div9").scroll(function () {
            $("#div10").scrollTop($("#div9").scrollTop());
            $("#div10").scrollLeft($("#div9").scrollLeft());
            $("#div10-1").scrollTop($("#div9").scrollTop());
            $("#div10-1").scrollLeft($("#div9").scrollLeft());
        });
        $("#div10").scroll(function () {
            $("#div9").scrollTop($("#div10").scrollTop());
            $("#div9").scrollLeft($("#div10").scrollLeft());
            $("#div10-1").scrollTop($("#div10").scrollTop());
            $("#div10-1").scrollLeft($("#div10").scrollLeft());
        });
        $("#div10-1").scroll(function () {
            $("#div9").scrollTop($("#div10-1").scrollTop());
            $("#div9").scrollLeft($("#div10-1").scrollLeft());
            $("#div10").scrollTop($("#div10-1").scrollTop());
            $("#div10").scrollLeft($("#div10-1").scrollLeft());
        });
    });

    $(document).ready(function () {
        $("#div11").scroll(function () {
            $("#div12").scrollTop($("#div11").scrollTop());
            $("#div12").scrollLeft($("#div11").scrollLeft());
            $("#div12-1").scrollTop($("#div11").scrollTop());
            $("#div12-1").scrollLeft($("#div11").scrollLeft());
        });
        $("#div12").scroll(function () {
            $("#div11").scrollTop($("#div12").scrollTop());
            $("#div11").scrollLeft($("#div12").scrollLeft());
            $("#div12-1").scrollTop($("#div12").scrollTop());
            $("#div12-1").scrollLeft($("#div12").scrollLeft());
        });
        $("#div12-1").scroll(function () {
            $("#div11").scrollTop($("#div12-1").scrollTop());
            $("#div11").scrollLeft($("#div12-1").scrollLeft());
            $("#div12").scrollTop($("#div12-1").scrollTop());
            $("#div12").scrollLeft($("#div12-1").scrollLeft());
        });

    });


    $('input[name=tabs][id=' + self.ptmResultTab + ']').prop('checked',true);
    $("input[name='tabs']").click(function () {
        self.ptmResultTab = this.id;
        SharedService.setVar("ptmResultTab", self.ptmResultTab);

    });

    self.listOfGenesOrptmProteins = [];
    if ($routeParams.tab == 'geneList' || $routeParams.tab == 'ptmProteinList') {
        self.ptmToModifierPtmOrGene = $routeParams.tab;
    }
    self.listOfGenesOrptmProteins = $routeParams.list;
    if ($routeParams.organism == '9606' || $routeParams.organism == '10090' || $routeParams.organism == '10116') {
        self.organismForm = $routeParams.organism;
    }

    if (typeof self.listOfGenesOrptmProteins !== 'undefined' && self.listOfGenesOrptmProteins.length > 0 )
    {
        self.inputMassPtmProteins = self.listOfGenesOrptmProteins;
    }

    //console.log("---------");
    //console.log($routeParams.tab);
    //console.log("---------");
    //console.log("---------");
    //console.log($routeParams.list);
    //console.log("---------");

    //self.organismFormProteinToPathway = SharedService.getVar('organismFormProteinToPathway');

    $('input[name=r3][value=' + self.organismForm + ']').prop('checked',true);

    $('input[name=tabset][id=' + self.ptmToModifierPtmOrGene + ']').prop('checked',true);

    if (!$("input[name='tabset']").is(":checked")) {
        //console.log("checked no");
        $("#ptmProteinList").prop("checked", true);
        SharedService.setVar("tabForProtein2Pathways", 'ptmProteinList');

    }
    if (!$("input[name='r3']").is(":checked")) {
        //console.log("checked no");
        $("#homosapiens").prop("checked", true);
    }

    $("input[name='tabset']").click(function () {
        self.ptmToModifierPtmOrGene = this.id;
        SharedService.setVar("ptmToModifierPtmOrGene", self.ptmToModifierPtmOrGene);
        //$location.url("/ptmToModifier?tab="+self.ptmToModifierPtmOrGene);
        self.url = $location.url();
        //console.log(self.url);
        //$window.sessionStorage.setItem("tabForProtein2Pathways", self.ptmToModifierPtmOrGene);
        //console.log(self.ptmToModifierPtmOrGene);
    });

    $scope.$on('$locationChangeStart' , 'SharedService', function(event, SharedService) {
        // call your method here

        if($location.url().contains('ptmToModifier') || $location.url().contains('peptideToProtein') || $location.url().contains('proteinToPathway') || $location.url().contains('help') || $location.url().contains('upload') || $location.url().contains('modification')) {
            SharedService.setVar('showSplash',false);
            self.showSplash = SharedService.getVar(showSplash);
            //console.log($location.url());
            //console.log($location.url());
            //console.log("self.showSplash");
            //console.log(self.showSplash);
            //console.log($location.url());
            self.firstVisit = false;
            SharedService.setVar('firstVisit', false);
            //$scope.$apply();
        }
        else
        {
            //console.log($location.url());
            if (self.firstVisit == false) {

                SharedService.setVar('showSplash',false);
                self.showSplash = SharedService.getVar(showSplash);
                $location.url("/ptmToModifier?tab="+self.ptmToModifierPtmOrGene);
                self.url = $location.url();
                //console.log($location.url());
            }
            //console.log("self.showSplash");
            //console.log(self.showSplash);
            //console.log("self.firstVisit");
            //console.log(self.firstVisit);
            //$scope.$apply();
        }
    });

    $scope.goToPeptideToProtein = function () {
        $location.url("/peptideToProtein");
        self.url = $location.url();
        //console.log($location.url());
    };

    $scope.goToPtmToModifier = function () {
        $location.url("/ptmToModifier");
        //$location.url("/ptmToModifier?tab="+self.ptmToModifierPtmOrGene);
        self.url = $location.url();
        //console.log(self.url);
    };

    $scope.goToAbout = function () {
        $location.url("/help");
        self.url = $location.url();
    };

    $scope.goToProteinToPathway = function () {
        $location.url("/proteinToPathway");
        self.url = $location.url();
    };

    function convertToCSV(objArray) {
        var array = typeof objArray != 'object' ? JSON.parse(objArray) : objArray;
        var str = '';

        for (var i = 0; i < array.length; i++) {
            var line = '';
            for (var index in array[i]) {
                if (line != '') line += ','

                line += array[i][index];
            }

            str += line + '\r\n';
        }

        return str;
    }

    function exportCSVFile(headers, items, fileTitle) {
        console.log(items);
        if (headers) {
            items.unshift(headers);
        }
        console.log(items);
        // Convert Object to JSON
        var jsonObject = JSON.stringify(items);
        console.log(jsonObject);
        var csv = convertToCSV(jsonObject);

        var exportedFilenmae = fileTitle + '.csv' || 'export.csv';

        var blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        if (navigator.msSaveBlob) { // IE 10+
            navigator.msSaveBlob(blob, exportedFilenmae);
        } else {
            var link = document.createElement("a");
            if (link.download !== undefined) { // feature detection
                // Browsers that support HTML5 download attribute
                var url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", exportedFilenmae);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }
    }

    $scope.exportCsvGeneral = function(data,name){
        var objKeys = Object.keys(data[0]);
        var headers = {};
        for (var i = 0; i < objKeys.length; i++){
            headers[objKeys[i]] = objKeys[i];
        }
        exportCSVFile(headers, data, name);

    }

    $scope.exportPhosphositePlusMappings = function(){




        //d3.csv('./example/graph_illustration.csv', function (data) {

            //console.log(data);
            // var itemsFormatted = [];
        var objKeys = Object.keys(self.blosum50Table[0]);
        console.log(objKeys);

            // var headers = {
            //     Category1: 'Category1'.replace(/,/g, ''), // remove commas to avoid errors
            //     Category2: "Category2",
            //     Relation: "Relation",
            //     Category1Id: "Category1Id",
            //     Category2Id: "Category2Id",
            //     EdgeId: "EdgeId"
            // };

        var headers = {};
        for (var i = 0; i < objKeys.length; i++){
            headers[objKeys[i]] = objKeys[i];
        }
        console.log(headers);
            // var itemsNotFormatted = data;
            // itemsNotFormatted.forEach( function(item){
            //     itemsFormatted.push({
            //         Category1: item.Category1.replace(/,/g, ''), // remove commas to avoid errors,
            //         Category2: item.Category2.replace(/,/g, ''),
            //         Relation: item.Relation.replace(/,/g, ''),
            //         Category1Id: item.Category1Id.replace(/,/g, ''),
            //         Category2Id: item.Category2Id.replace(/,/g, ''),
            //         EdgeId: item.EdgeId.replace(/,/g, '')
            //
            //     });
            // });
        console.log(self.blosum50Table);

            var fileTitle = 'phosphositePlus-PTMProteinMapping'; // or 'my-unique-title'

            exportCSVFile(headers, self.blosum50Table, fileTitle); // call the exportCSVFile() function to process the JSON and trigger the download

        //})
        // format the data

    }

    // $scope.exportPhosphositePlusMappings = function () {
    //     //console.log(self.blosum50Table);
    //     alasql('SELECT * INTO XLSX("phosphositePlus-PTMProteinMapping.xlsx",{headers:true}) FROM ?', [self.blosum50Table]);
    //
    // };

    $scope.exportSignorMappings = function () {
        //console.log(self.blosum50Table);
        alasql('SELECT * INTO XLSX("SIGNOR-PTMProteinMapping.xlsx",{headers:true}) FROM ?', [self.signor_table]);

    };


    $scope.exportiPTMNetMappings = function () {
        // //console.log(self.sequence_acListComplete);
        // self.iptmNetForDownload = [];
        // //console.log(ontologyMappings);
        // //console.log(ontologyMappings);
        // self.PTM_table.map(function (e) {
        //
        //     var modificationElem = e.modification;
        //     var shorthandElem = e.shorthand;
        //     var identifierElem = e.identifier;
        //     var diffavgElem = e.diffavg;
        //     var descriptionElem = e.description;
        //     var similarElem = "";
        //     var mostSimilarElem = "";
        //     var familyElem = "";
        //
        //     //console.log(e.similar);
        //
        //
        //     if (e.similar !== null ) {
        //         e.similar.map(function (e2) {
        //             similarElem = similarElem + e2.string+ "   ";
        //         });
        //     }
        //
        //     if (e.mostSimilar !== null ) {
        //         e.mostSimilar.map(function (e2) {
        //             mostSimilarElem = mostSimilarElem + e2.string+ "   ";
        //         });
        //     }
        //     if (e.is_a !==  null) {
        //         e.is_a.map(function (e2) {
        //             familyElem = familyElem  + e2.mod+ "   ";
        //         });
        //     }
        //     var ontologyMappingsElem = {};
        //     ontologyMappingsElem["modification"] = modificationElem;
        //     ontologyMappingsElem["shorthand"] = shorthandElem;
        //     ontologyMappingsElem["identifier"] = identifierElem;
        //     ontologyMappingsElem["diffavg"] = diffavgElem;
        //     ontologyMappingsElem["description"] = descriptionElem;
        //     ontologyMappingsElem["similar"] = similarElem;
        //     ontologyMappingsElem["mostSimilar"] = mostSimilarElem;
        //     ontologyMappingsElem["family"] = familyElem;
        //
        //     self.ontologyMappingsForDownload.push(ontologyMappingsElem);
        //
        // });

        //console.log(self.ontologyMappingsForDownload);
        alasql('SELECT * INTO XLSX("iPTMNet-PTMProteinMapping.xlsx",{headers:true}) FROM ?', [self.PTM_table]);

    };




    $scope.$watch(function () {
        return self.inputMassPtmProteins
    }, function (newValue, oldValue) {



        // if (self.inputMassPtmProteins.length > 0) {
        //     self.parsedInputMassPtmProteins = self.inputMassPtmProteins
        //         .split(self.rowSplitPatternGenes)
        //         .map(function (e) {
        //             if (e.indexOf('[') == -1) {
        //                 return e
        //             }
        //         });
        //     self.parsedGenes.clean(undefined);
        // }

        // .filter(function (el) {
        //         return (el !== null);
        //     });
        // .filter(function (el) {
        //     ////console.log(peptide.indexOf(el.modification));
        //     return (peptide.indexOf(el.modification) > -1);
        // })


        // //console.log(self.inputMassPtmProteins);
        // //console.log(self.genes);
        if (self.inputMassPtmProteins.length > 0) {
            self.ptmProteinToAbundanceMap = {};

            self.proteinAbundance = self.inputMassPtmProteins
                .split(self.rowSplitPattern)
                .map(function (e) {
                    if (e) {
                        // var str = e.split(/[\s,]+/).join();
                        // //console.log(str);
                        // var str2 = str.replace(/[\s,]+/g, ',');
                        // //console.log(str2);
                        var str2 = e.replace(/,/g, '').replace(/^\s\s*/, '').replace(/\s\s*$/, '').replace(/[\s,]+/g, ',');
                        ////console.log(str2);
                        if (str2.indexOf(',') > -1) {
                            str2 = str2.split(',').slice(1);

                            return str2[0];
                        }
                        else {

                            return "NA";
                        };

                    }


                });

            ////console.log(self.proteinAbundance);


            self.parsedPTMs = self.inputMassPtmProteins
                .split(self.rowSplitPatternGenes)
                .map(function (e) {
                ////console.log(e.match(self.modificationPatternForAllPTMs));
                    return e.match(self.modificationPatternForAllPTMs);

                });


            self.parsedPTMProteins = self.inputMassPtmProteins
                .split(self.rowSplitPatternGenes)
                .map(function (e) {

                    var str2 = e.replace(/,/g, '').replace(/^\s\s*/, '').replace(/\s\s*$/, '').replace(/[\s,]+/g, ',');
                    //console.log(str2);
                    if (str2.indexOf(',') > -1) {
                        str2 = str2.split(',').slice(0);
                        //console.log(str2[0].replace(str2[0].match(self.modificationPatternForAllPTMs),""));
                        return str2[0].replace(str2[0].match(self.modificationPatternForAllPTMs),"");
                    }
                    else{
                        //console.log(e.replace(e.match(self.modificationPatternForAllPTMs),""));
                        return e.replace(e.match(self.modificationPatternForAllPTMs),"");
                    }

                    // if (e.indexOf('[') > -1) {
                    //     return e
                    // }
                    //return e.toUpperCase().match(self.modificationForptmProteins);;
                });

            self.inputMassPtmProteinsModified = self.inputMassPtmProteins
                .split(self.rowSplitPatternGenes)
                .map(function (e) {

                    var str2 = e.replace(/,/g, '').replace(/^\s\s*/, '').replace(/\s\s*$/, '').replace(/[\s,]+/g, ',');
                    //console.log(str2);
                    if (str2.indexOf(',') > -1) {
                        str2 = str2.split(',').slice(0);
                        //console.log(str2);
                        return str2[0];
                    }
                    else{
                        //console.log(e);
                        return e;
                    }

                    // if (e.indexOf('[') > -1) {
                    //     return e
                    // }
                    //return e.toUpperCase().match(self.modificationForptmProteins);;
                });



            for (var i = 0; i < self.inputMassPtmProteinsModified.length; i++) {
                self.ptmProteinToAbundanceMap[self.inputMassPtmProteinsModified[i]] = self.proteinAbundance[i];
                //Do something
            }
            //console.log("ptmProteinToAbundanceMap");
            //console.log(self.ptmProteinToAbundanceMap);

            self.parsedPTMProteins.clean(undefined);


        }
        if (self.parsedPTMProteins.length == 0) {
            self.showPhosphoGeneNetwork = false;
            SharedService.setVar('showPhosphoGeneNetwork', self.showPhosphoGeneNetwork);
            //console.log("self.showPhosphoGeneNetwork = false;");
        }
        // .filter(function (el) {
        //         return (el !== null);
        //     });
        //Because We need this for api query
        self.inputMassPtmProteinsModifiedForQuery = self.inputMassPtmProteinsModified.toString();
        //console.log(self.inputMassPtmProteinsModifiedForQuery);
        //console.log(self.parsedPTMProteins);
        //console.log(self.inputMassPtmProteinsModified);
        //console.log(self.parsedPTMs);
        //console.log(self.showPhosphoGeneNetwork);
        //console.log(self.showGeneNetwork);
        self.showPtmSubmit = true;
        SharedService.setVar('inputMassPtmProteins',self.inputMassPtmProteins);

    });


    var timeout;

    $scope.$watch(function () {
        return self.genes
    }, function (newValue, oldValue) {
        //console.log("in scope gene!---------------------------------------");
        //localStorage.setItem("genes", self.genes);
        //console.log("Setting genes -----");
        self.showGeneSubmit = false;
        // var localselfGenes = localStorage.getItem("genesForProtein2Pathways");
        // //console.log(localselfGenes);
        // $scope.showGeneNetworkProcessed = false;
        // $scope.showKinaseNetworkProcessed = false;
        // self.showGeneNetwork = true;
        //
        // SharedService.setVar('showGeneNetwork', self.showGeneNetwork);
        // SharedService.setVar('showGeneNetworkProcessed', $scope.showGeneNetworkProcessed);
        // SharedService.setVar('showKinaseNetworkProcessed', $scope.showKinaseNetworkProcessed);
        if (self.genes.length > 0) {
            self.geneToAbundanceMap = {};
            self.parsedGenes = self.genes
                .split(self.rowSplitPattern)
                .map(function (e) {
                    if (e) {

                        var str2 = e.replace(/,/g, '').replace(/^\s\s*/, '').replace(/\s\s*$/, '').replace(/[\s,]+/g, ',');
                        ////console.log(str2);
                        if (str2.indexOf(',') > -1) {
                            str2 = str2.split(',').slice(0);

                            return str2[0];
                        }
                        else {
                            return str2;
                        }
                        ;
                    }


                });


                // .split(self.rowSplitPatternGenes)
                // .map(function (e) {
                //     if (e.indexOf('[') == -1) {
                //         return e
                //     }
                // });
            self.parsedGenes.clean(undefined);
            //console.log(self.parsedGenes);
            self.geneAbundance = self.genes
                .split(self.rowSplitPattern)
                .map(function (e) {
                    if (e) {
                        // var str = e.split(/[\s,]+/).join();
                        // //console.log(str);
                        // var str2 = str.replace(/[\s,]+/g, ',');
                        // //console.log(str2);
                        var str2 = e.replace(/,/g, '').replace(/^\s\s*/, '').replace(/\s\s*$/, '').replace(/[\s,]+/g, ',');
                        ////console.log(str2);
                        if (str2.indexOf(',') > -1) {
                            str2 = str2.split(',').slice(1);

                            return str2[0];
                        }
                        else {
                            return "NA";
                        };
                    }


                });

            for (var i = 0; i < self.parsedGenes.length; i++) {
                self.geneToAbundanceMap[self.parsedGenes[i]] = self.geneAbundance[i];
                //Do something
            }
            //console.log("geneToAbundanceMap");
            //console.log(self.geneToAbundanceMap);
            //console.log(self.geneAbundance);
        }

        if (self.parsedGenes.length == 0) {
            self.showGeneNetwork = false;
            SharedService.setVar('showGeneNetwork', self.showGeneNetwork);
            //console.log("self.showGeneNetwork = false;");
        }
        // .filter(function (el) {
        //         return (el !== null);
        //     });
        // .filter(function (el) {
        //     ////console.log(peptide.indexOf(el.modification));
        //     return (peptide.indexOf(el.modification) > -1);
        // })
        // if (self.genes.length > 0) {
        //     self.parsedPTMProteins = self.genes
        //         .split(self.rowSplitPatternGenes)
        //         .map(function (e) {
        //             if (e.indexOf('[') > -1) {
        //                 return e
        //             }
        //             //return e.toUpperCase().match(self.modificationForptmProteins);;
        //         });
        //     self.parsedPTMProteins.clean(undefined);
        // }
        // if (self.parsedPTMProteins.length == 0) {
        //     self.showPhosphoGeneNetwork = false;
        //     //console.log("self.showPhosphoGeneNetwork = false;");
        // }
        // .filter(function (el) {
        //         return (el !== null);
        //     });
        //console.log(self.parsedGenes);
        // //console.log(self.parsedPTMProteins);
        // //console.log(self.showPhosphoGeneNetwork);
        //console.log(self.showGeneNetwork);
        SharedService.setVar('genes', self.genes);
    });


    $scope.$watch(function () {
        return self.parsedGenes

    }, function (nV, oV) {
        //console.log("in scope parsed gene!+++++++++++++++++++++++++++++++++++++");
        //self.showOutputPathway = false;
        self.flagFoundNPCG = false;
        self.waitingPathway = true;
        //self.showOutputPathway = false;
        //console.log("self.showOutputPathway");
        //console.log(self.showOutputPathway);
        //console.log(self.parsedGenes);

        // This is for slicing the input genes because it makes problems if we have long list of genes in the http.get

        if (timeout) {
            $timeout.cancel(timeout);
        };
        $timeout(function () {
            self.genePlaces = [];
            self.inputGeneInfo = [];
            self.nonValidGenes = [];
            // self.network = {};
            // self.kinaseNetwork = {};
            self.numberOfAllInputGenes = 0;
            self.numberOfAllValidGenes = 0;
            //console.log("self.parsedGenes.length");
            //console.log(self.parsedGenes.length);
            var genePartitioned = function splitarray(input, spacing) {
                var output = [];

                for (var i = 0; i < input.length; i += spacing) {
                    output[output.length] = input.slice(i, i + spacing);
                }

                return output;
            }(self.parsedGenes, self.parsedGenes.length)

            //console.log(genePartitioned);
            //console.log(genePartitioned.length);
            // var flag = true;
            // while (flag){
            //     var queryGeneList = [];
            //     self.parsedGenes
            //
            // }
            if (genePartitioned.length > 0) {
                for (i = 0; i < genePartitioned.length; i++) {

                    $http.get("api/pcg/checkgenes/" + genePartitioned[i])
                        .success(function (genePositions) {
                            //console.log("genePositions");
                            //console.log(genePositions);
                            self.genePlaces = genePositions;
                            for (var geneIter = 0; geneIter < self.genePlaces.length; geneIter++) {
                                self.numberOfAllInputGenes = self.numberOfAllInputGenes + 1;
                                if (self.genePlaces[geneIter] != -1) {
                                    self.numberOfAllValidGenes = self.numberOfAllValidGenes + 1;
                                }
                                else {
                                    self.flagFoundNPCG = true;
                                    self.nonValidGenes.push(self.parsedGenes[geneIter]);
                                    //console.log("self.nonValidGenes");
                                    //console.log(self.nonValidGenes);
                                }
                            }
                            // self.genePlaces.forEach(function (e) {
                            //     self.numberOfAllInputGenes = self.numberOfAllInputGenes + 1;
                            //     if (e != -1) {
                            //         self.numberOfAllValidGenes = self.numberOfAllValidGenes + 1;
                            //     }
                            //     else
                            //     {
                            //         self.nonValidGenes.push(self.parsedGenes[])
                            //     }
                            //     ;
                            // });
                            //self.inputGeneInfo = [];
                            $http.get("api/pcg/geneinfo/" + self.genePlaces)
                                .success(function (geneInfos) {
                                    self.inputGeneInfo = [];
                                    //console.log(geneInfos);
                                    for (var geneInfoIter = 0; geneInfoIter < geneInfos.length; geneInfoIter++) {
                                        self.inputGeneInfo.push(geneInfos[geneInfoIter]);
                                    }
                                    //console.log(self.inputGeneInfo);
                                    self.showGeneSubmit = true;
                                })
                                .error(function () {
                                    //console.log("Error in obtaining gene info from api/pcg/geneinfo/");
                                    self.showGeneSubmit = true;
                                });
                        })
                        .error(function () {
                            //console.log("Error in obtaining gene place from api/pcg/checkgenes/");
                        });
                }
            }

        }, 1100);

    });


    //var svgCola = d3cola.selectAll("#chart4").append("svg");

    // var svg3 = d3.selectAll("#chart3").append("svg");



//This is for interval progress bar
//     $interval(function(){
//         if(self.progressPtmPercent < 95) {
//             self.incrementWithTime += 1;
//             self.progressPtmPercent += 1;
//             $scope.getPtmPercentage = function () {
//                 //console.log("progressPtmPercent");
//                 //console.log(self.progressPtmPercent.toFixed(0));
//                 return self.progressPtmPercent.toFixed(0);
//
//             }
//         }
//
//     }, 2000);


    self.onSubmitPtm = function () {
        //computeWeightForupdatePtm
        self.incrementWithTime = 0;
        self.progressPtmPercent = 0;
        self.computeWeightForUpdatePtm = true;
        self.computeWeightForUpdateDeepPhos = true;
        self.computeWeightForUpdateSignor = true;
        self.computeWeightForUpdatePhospho = true;
        self.showPhosphoGeneNetworkProcessed = false;
        self.showPhosphoDeepGeneNetworkProcessed = false;
        self.showPtmGeneNetworkProcessed = false;
        self.showSignorGeneNetworkProcessed = false;

        self.showPhosphoDeepGraphTmp = false;
        self.showPhosphoGraphTmp = false;
        self.showPtmGraphTmp = false;
        self.showSignorGraphTmp = false;
        self.showKinaseGraphTmp = false;
        self.showPathwayGraphTmp = false;

        self.showEnrichmentGraphTmp = false;

        self.showPhosphoGeneNetwork = true;
        SharedService.setVar('showPhosphoGeneNetwork', self.showPhosphoGeneNetwork);

        self.showPhosphoDeepGeneNetwork = true;
        SharedService.setVar('showPhosphoDeepGeneNetwork', self.showPhosphoDeepGeneNetwork);

        self.showPtmGeneNetwork = true;
        SharedService.setVar('showPtmGeneNetwork', self.showPtmGeneNetwork);

        self.showSignorGeneNetwork = true;
        SharedService.setVar('showSignorGeneNetwork', self.showSignorGeneNetwork);

        self.secondPageQuery = true;
        self.ptmWaiting = true;
        self.phosphoError = false;
        self.phosphoWaiting = true;
        self.phosphoDeepError = false;
        self.phosphoDeepWaiting = true;
        self.ptmError = false;
        self.signorWaiting = true;
        self.signorError = false;
        //console.log("!self.secondPageQuery");
        //console.log(!self.secondPageQuery);
        var force;
        self.showOutputPtm = false;
        self.showPhosphoGraph = false;
        self.showPtmGraph = false;
        self.showSignorGraph = false;

        //console.log(" ----------------  ");
        //console.log(" onSubmitPtm  ");

        $http.get("api/increment/" + 2)
            .success(function (siteVisit) {

                self.siteVisit = siteVisit;

            })
            .error(function (data, status) {

                self.siteVisit = {"all": "", "peptide": "", "gene": "", "ptm": ""}

            });





        if (self.inputMassPtmProteins.length > 0) {

            //console.log(self.inputMassPtmProteins)
            //var spinner3 = new Spinner(opts).spin(target3);
            //console.log("self.inputMassPtmProteins");
            //console.log(self.inputMassPtmProteins);
            //console.log("self.inputMassPtmProteinsModifiedForQuery");
            //console.log(self.inputMassPtmProteinsModifiedForQuery);
            self.progressPtmPercent += 5;
            if (2>1) {
                $http.get("api/phosphoandptm/organism/" + self.organismForm + "/ptmprotein/" + self.inputMassPtmProteinsModifiedForQuery)
                    .success(function (apiPhosphoNetwork) {
                        self.progressPtmPercent += Math.max(0, 65 - self.incrementWithTime / 2);
                        self.phosphoWaiting = false;
                        self.showPhosphoGeneNetworkProcessed = true;
                        console.log("self.inputMassPtmProteinsModifiedForQuery");
                        console.log(self.inputMassPtmProteinsModifiedForQuery);
                        console.log(apiPhosphoNetwork);
                        //console.log(self.showPhosphoGeneNetworkProcessed);

                        SharedService.setVar('showPhosphoGeneNetworkProcessed', self.showPhosphoGeneNetworkProcessed);
                        //spinner3.stop();
                        self.phosphoNetwork = apiPhosphoNetwork;
                        SharedService.setVar('phosphoNetwork', self.phosphoNetwork);
                        //console.log(self.phosphoNetwork);

                        self.deepPhosNetwork = self.phosphoNetwork.deepPhosNetwork;
                        SharedService.setVar('deepPhosNetwork', self.deepPhosNetwork);

                        self.deepPhosTable = self.phosphoNetwork.deepPhosTable;
                        SharedService.setVar('deepPhosTable', self.deepPhosTable);

                        self.blosum50Table = self.phosphoNetwork.Blosum50_table;
                        SharedService.setVar('blosum50Table', self.blosum50Table);

                        self.signor_table = self.phosphoNetwork.signor_table;
                        SharedService.setVar('signor_table', self.signor_table);

                        self.signor_Network = self.phosphoNetwork.signor_Network;
                        SharedService.setVar('signor_Network', self.signor_Network);

                        self.signorWaiting = false;
                        self.showSignorGeneNetworkProcessed = true;
                        SharedService.setVar('showSignorGeneNetworkProcessed', self.showSignorGeneNetworkProcessed);

                        //console.log("signor_Network");
                        //console.log(self.signor_Network);

                        //console.log("phosphoNetwork");
                        //console.log(self.phosphoNetwork);
                        self.showOutputPhospho = true;
                        SharedService.setVar('showOutputPhospho', self.showOutputPhospho);


                        self.ptmWaiting = false;
                        self.showPtmGeneNetworkProcessed = true;
                        SharedService.setVar('showPtmGeneNetworkProcessed', self.showPtmGeneNetworkProcessed);
                        self.PTM_table = self.phosphoNetwork.PTM_table;
                        SharedService.setVar('PTM_table', self.PTM_table);

                        self.ptmNetwork = self.phosphoNetwork.ptm_Network;
                        SharedService.setVar('ptmNetwork', self.ptmNetwork);

                        self.showOutputSignor = true;
                        SharedService.setVar('showOutputSignor', self.showOutputSignor);
                        self.showOutputPtm = true;
                        SharedService.setVar('showOutputPtm', self.showOutputPtm);

                    })
                    .error(function () {
                        self.progressPtmPercent += Math.max(0, 65 - self.incrementWithTime / 2);
                        self.phosphoError = true;
                        self.ptmError = true;
                        self.signorError = true;
                        self.deepPhosError = true;
                        //console.log("Error in obtaining network from api/phospho/");
                    });

            }
            //This is for having different ptm and phosphonetwork
            if (1>2) {
                //console.log(self.inputMassPtmProteins)
                //var spinner3 = new Spinner(opts).spin(target3);
                //console.log("api/phospho2/uniprot/ + self.inputMassPtmProteins");
                //console.log(self.inputMassPtmProteins);
                self.progressPtmPercent += 5;
                $http.get("api/phospho2/organism/" + self.organismForm + "/ptmprotein/" + self.inputMassPtmProteinsModifiedForQuery)
                    .success(function (apiPhosphoNetwork) {
                        self.progressPtmPercent += Math.max(0, 65 - self.incrementWithTime / 2);
                        self.phosphoWaiting = false;
                        self.showPhosphoGeneNetworkProcessed = true;
                        //console.log("self.showPhosphoGeneNetworkProcessed");
                        //console.log(self.showPhosphoGeneNetworkProcessed);

                        SharedService.setVar('showPhosphoGeneNetworkProcessed', self.showPhosphoGeneNetworkProcessed);
                        //spinner3.stop();
                        self.phosphoNetwork = apiPhosphoNetwork;
                        SharedService.setVar('phosphoNetwork', self.phosphoNetwork);
                        //console.log(self.phosphoNetwork);

                        self.blosum50Table = self.phosphoNetwork.Blosum50_table;
                        SharedService.setVar('blosum50Table', self.blosum50Table);


                        //console.log("phosphoNetwork");
                        //console.log(self.phosphoNetwork);
                        self.showOutputPhospho = true;
                        SharedService.setVar('showOutputPhospho', self.showOutputPhospho);

                    })
                    .error(function () {
                        self.progressPtmPercent += Math.max(0, 65 - self.incrementWithTime / 2);
                        self.phosphoError = true;
                        //console.log("Error in obtaining network from api/phospho/");
                    });


                self.progressPtmPercent += 5;
                $http.get("api/ptm/organism/" + self.organismForm + "/ptmprotein/" + self.inputMassPtmProteinsModifiedForQuery)
                    .success(function (apiPtmNetwork) {
                        self.progressPtmPercent += Math.max(0, 25 - self.incrementWithTime / 2);
                        self.ptmWaiting = false;
                        self.showPtmGeneNetworkProcessed = true;
                        //console.log("self.showPtmGeneNetworkProcessed");
                        //console.log(self.showPtmGeneNetworkProcessed);
                        SharedService.setVar('showPtmGeneNetworkProcessed', self.showPtmGeneNetworkProcessed);
                        //spinner3.stop();
                        self.ptmNetwork = apiPtmNetwork;
                        //console.log("self.ptmNetwork");
                        //console.log(self.ptmNetwork);

                        self.PTM_table = self.ptmNetwork.PTM_table;
                        SharedService.setVar('PTM_table', self.PTM_table);

                        self.ptmNetwork = self.ptmNetwork.ptm_Network;
                        SharedService.setVar('ptmNetwork', self.ptmNetwork);


                        self.showOutputPtm = true;
                        SharedService.setVar('showOutputPtm', self.showOutputPtm);

                    })
                    .error(function () {
                        self.progressPtmPercent += Math.max(0, 25 - self.incrementWithTime / 2);
                        self.ptmError = true;
                        //console.log("Error in obtaining network from api/ptm/");
                    });
            }
        }


        self.waitingSignor = false;
        self.waitingPtm = false;

        //console.log("self.showOutputPtm");
        //console.log(self.showOutputPtm);
        // self.waitingPathway = false;
        // self.showOutputPathway = true;
    }





    $scope.graphType4signor = 1;
    $scope.circleSliderValue4signor = 1100;
    $scope.nodeSliderValue4signor = 15;
    $scope.fontSliderValue4signor = 14;
    $scope.widthSliderValue4signor = 1500;
    $(document).on('input', '#circle_slider4signor', function() {
        $('#circle_slider_value4signor').html( $(this).val() );
        ////console.log($(this).val());
        $scope.circleSliderValue4signor = $(this).val();

        $scope.$apply();

        $scope.makeSignorGraph(self.signor_Network, self.ptmProteinToAbundanceMap, $scope.graphType4signor, $scope.circleSliderValue4signor, $scope.nodeSliderValue4signor, $scope.fontSliderValue4signor, $scope.widthSliderValue4signor);

    });

    $(document).on('input', '#node_slider4signor', function() {
        $('#node_slider_value4signor').html( $(this).val() );
        ////console.log($(this).val());
        $scope.nodeSliderValue4signor = $(this).val();

        $scope.$apply();

        $scope.makeSignorGraph(self.signor_Network, self.ptmProteinToAbundanceMap, $scope.graphType4signor, $scope.circleSliderValue4signor, $scope.nodeSliderValue4signor, $scope.fontSliderValue4signor, $scope.widthSliderValue4signor);

    });

    $(document).on('input', '#font_slider4signor', function() {
        $('#font_slider_value4signor').html( $(this).val() );
        ////console.log($(this).val());
        $scope.fontSliderValue4signor = $(this).val();

        $scope.$apply();

        $scope.makeSignorGraph(self.signor_Network, self.ptmProteinToAbundanceMap, $scope.graphType4signor, $scope.circleSliderValue4signor, $scope.nodeSliderValue4signor, $scope.fontSliderValue4signor, $scope.widthSliderValue4signor);

    });

    $(document).on('input', '#width_slider4signor', function() {
        $('#width_slider_value4signor').html( $(this).val() );
        ////console.log($(this).val());
        $scope.widthSliderValue4signor = $(this).val();

        $scope.$apply();

        $scope.makeSignorGraph(self.signor_Network, self.ptmProteinToAbundanceMap, $scope.graphType4signor, $scope.circleSliderValue4signor, $scope.nodeSliderValue4signor, $scope.fontSliderValue4signor, $scope.widthSliderValue4signor);

    });






    $scope.hideSignorGraph = function () {
        self.showSignorGraphTmp = true;
        self.showSignorGraph = false;
    }
    $scope.makeSignorGraph = function (network, ptmToAbundance, graphType, circleSliderValue, nodeSliderValue, fontSliderValue, widthSliderValue) {
        //console.log(self.computeWeightForUpdateSignor);

//
//         if(self.showDeepPhosGraphTmp)
//         {
//             self.showDeepPhosGraphTmp = false;
//             self.showDeepPhosGraph = true;
//         }
//         else {
// //console.log("inside deepPhosGraph");
//             self.showDeepPhosGraphTmp = true;
//             self.showDeepPhosGraph = false;
//             d3.select("#chart4deep").select("svg").remove();



        if(self.showSignorGraphTmp)
        {
            self.showSignorGraphTmp = false;
            self.showSignorGraph = true;
        }
        else {
//console.log("inside deepPhosGraph");
//             self.showDeepPhosGraphTmp = true;
//             self.showDeepPhosGraph = false;
        // if (!self.showSignorGraphTmp) {
            console.log("in makeSignorGraph");
            self.showSignorGraphTmp = true;
            self.showSignorGraph = false;
            d3.select("#chart6").select("svg").remove();
            if (typeof svg6 === 'undefined') {
                var svg6 = d3.selectAll("#chart6").append("svg");
            }
            //var svg4 = d3.selectAll("#chart4").append("svg");


            var force;
            var colNodeScaleSeparate = d3.scale.ordinal()
                .range(["#987024", "#ed0909", "#0af702", "#d506d8"])
                //.range(["#987024", "#982482", "#0af702"])
                .domain([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);
//#f9a3f5
            // var colNodeScaleSeparate = d3.scale.ordinal()
            //     .range(["#767776", "#f91104", "#0af702"])
            //     .domain([0,1,2]);

            // var colNodeScale = d3.scale.linear().range(["#987024", "#ed0909"]);
            // var colScale = d3.scale.linear().range(["#987024", "#ed0909"]);

            var colScale = d3.scale.ordinal()
                .range(["#987024", "#ed0909", "#0af702", "#d506d8"])
                //.range(["#987024", "#982482", "#0af702"])
                .domain([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);

            var colNodeScale = d3.scale.ordinal()
                .range(["#987024", "#ed0909", "#0af702", "#d506d8"])
                //.range(["#987024", "#982482", "#0af702"])
                .domain([1, 2, 3, 4]);
            var edgeWeightScale = d3.scale.linear().range([1, 3]);
            var xScale = d3.scale.linear().range([nodeSliderValue/3.0, nodeSliderValue]);
            //var xScale = d3.scale.linear().range([5, 15]);
            var scoreScale = d3.scale.linear().range([1, 5]);
            var textPlacePlusMinus = d3.scale.ordinal()
                .range([18, -18, -18, -18, -18, -18, -18, -18, -18, -18, -18, -18])
                .domain([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);
            var textPlaceStartEnd = d3.scale.ordinal().range(["start", "end", "end", "end", "end", "end", "end", "end", "end", "end", "end", "end"])
                .domain([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);

            var colorsForAbundance = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
            var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];
            var colorScale = d3.scale.threshold()
                .domain(domain_data)
                .range(colorsForAbundance);


            function updateSignor(nodes, links, graphType, circleValue, nodeValue, fontValue, widthValue) {
                //
                //var svg;

                circleValue = Math.min(circleValue, widthValue - 300);
                // $('force1').click();
                //document.getElementById('force1').click();

                // //console.log(circularLayout);


                // self.computeWeightForupdatePtm = false;
                // SharedService.setVar('computeWeightForupdatePtm', self.computeWeightForupdatePtm);


                // Set-up the export button
                // d3.select('#download-png').on('click', function() {
                //
                // })



                function circularView6(){
                    svg6.remove();

                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    scoreScale.domain(d3.extent(links, function (d) {
                        return d.score;
                    }));
                    colNodeScale.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));
                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = w,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;


                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;


                    svg6 = d3.select("#chart6")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);
                    svg6.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");


                    // This is for grouping nodes


                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h]);

// evenly spaces nodes along arc
                    var circleCoord = function (node, index, num_nodes) {
                        var circumference = circle.node().getTotalLength();
                        var pointAtLength = function (l) {
                            return circle.node().getPointAtLength(l)
                        };
                        var sectionLength = (circumference) / num_nodes;
                        var position = sectionLength * index + sectionLength / 2;
                        return pointAtLength(circumference - position)
                    }

                    var is_connected = function (d, opacity) {
                        lines.transition().style("stroke-opacity", function (o) {
                            return o.source === d || o.target === d ? 1 : opacity;
                        });
                    }




                    var dim = w - (widthValue - circleValue);
                    var circle = svg6.append("path")
                        .attr("d", "M " + String((widthValue - circleValue)/2) + ", " + (dim / 2 + (widthValue - circleValue)/2) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                        .style("fill", "white");


                    // var dim = w - 900
                    // var circle = svg6.append("path")
                    //     .attr("d", "M 450, " + (dim / 2 + 450) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                    //     .style("fill", "white");

                    force.start();

                    nodes.forEach(function (n, i) {
                        var coord = circleCoord(n, i, nodes.length)
                        n.x = coord.x
                        n.y = coord.y
                    });


                    // use this one for straight line links...
                    // var lines = svg.selectAll("line.node-link")
                    //     .data(links).enter().append("line")
                    //     .attr("class", "node-link")
                    //     .attr("x1", function(d) { return d.source.x; })
                    //     .attr("y1", function(d) { return d.source.y; })
                    //     .attr("x2", function(d) { return d.target.x; })
                    //     .attr("y2", function(d) { return d.target.y; });

                    svg6.append('defs').append('marker')
                        .attr({
                            'id': 'arrowhead',
                            'viewBox': '-0 -5 10 10',
                            'refX': 25,
                            'refY': 0,
                            //'markerUnits':'strokeWidth',
                            'orient': 'auto',
                            'markerWidth': 5,
                            'markerHeight': 6,
                            'xoverflow': 'visible'
                        })
                        .append('svg:path')
                        .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
                        .attr('fill', '#0000ff')
                        .attr('stroke', '#0000ff');

                    svg6.append('defs').append('marker')
                        .attr({
                            'id': 'block',
                            'viewBox': '-0 -10 20 20',
                            'refX': 25,
                            'refY': 0,
                            //'markerUnits':'strokeWidth',
                            'orient': 'auto',
                            'markerWidth': 15,
                            'markerHeight': 10,
                            'xoverflow': 'visible'
                        })
                        .append('svg:path')
                        .attr('d', 'M 0,0 m -1,-10 L 1,-10 L 1,10 L -1,10 Z')
                        .attr('fill', '#f00')
                        .attr('stroke', '#f00');


                    // var path = svg6.append("svg:g").selectAll("path")
                    // //.data(links)
                    //     .data(force.links())
                    //     .enter().append("svg:path")
                    //     .style("fill", "none")
                    //     .style("stroke", "black")
                    //     .style("stroke", function (d) {
                    //         return colScale(d.value);
                    //     })
                    //     //.attr("marker-end", function(d) { return "url(#" + d.type + ")"; })
                    //     .attr("class", function (d) {
                    //         return "link ";
                    //     })
                    //     //.attr('marker-end', function(d,i){ return 'url(#marker_stub)' });
                    //     .attr('marker-end', 'url(#arrowhead)');


                    var lines = svg6.selectAll("path.node-link")
                        .data(links).enter().append("path")
                        .style("fill", "none")
                        .style("stroke", function (d) {
                            if (d.tag == 2) {
                                return '#f00';
                            }
                            else if (d.tag == 1) {
                                return '#0000ff';
                            }
                            else {
                                return '#000000';
                            }
                        })
                        //.style("stroke", "#726363")
                        .attr("class", "node-link")
                        .style("stroke-width", function (d) {
                            return d.score / 2;
                        })
                        .attr("d", function (d) {
                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,
                                dr = Math.sqrt(dx * dx + dy * dy);
                            return "M" +
                                d.source.x + "," +
                                d.source.y + "," +
                                d.target.x + "," +
                                d.target.y;

                        })
                        .attr("class", function (d) {
                            return "node-link";
                        })
                        .attr('marker-end', function (d) {
                            if (d.tag == 1) {
                                return 'url(#block)'
                            }
                            if (d.tag == 2) {
                                return 'url(#arrowhead)'
                            }

                        });
                    //.attr('marker-end', function(d,i){ return 'url(#marker_stub)' });
                    //.attr('marker-end', 'url(#arrowhead)');


                    var gnodes = svg6.selectAll('g.gnode')
                        .data(nodes).enter().append('g')
                        .attr("transform", function (d) {
                            return "translate(" + d.x + "," + d.y + ")"
                        })
                        .classed('gnode', true);


                    // node.append("circle")
                    //     .attr("r", function (d) { return xScale(d.weight); })
                    //     .style("fill", function(d) { return colNodeScale(d.group); });

                    var node = gnodes.append("circle")
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        .style("fill", function (d) {
                            if (d.group == 0) {
                                return colorScale(d.value);
                            }
                            else {

                                if (d.group == 1) {
                                    return ("#ed0909");
                                }
                                if (d.group == 2) {
                                    return ("#0af702");
                                }
                                if (d.group == 3) {
                                    return ("#FF00FF");
                                }
                                if (d.group == 4) {
                                    return ("#808000");
                                }
                                if (d.group == 5) {
                                    return ("#000080");
                                }
                                if (d.group == 6) {
                                    return ("#800080");
                                }
                                if (d.group == 7) {
                                    return ("#00ffff");
                                }
                                if (d.group == 8) {
                                    return ("#F5F5DC");
                                }
                                if (d.group == 9) {
                                    return ("#A52A2A");
                                }
                                if (d.group == 10) {
                                    return ("#8B0000");
                                }
                                if (d.group == 11) {
                                    return ("#FF8C00");
                                }
                                if (d.group == 12) {
                                    return ("#000000");
                                }
                            }
                            //return colNodeScale(d.group);
                        })
                        // .style("fill", function (d) {
                        //     return colNodeScale(d.group);
                        // })
                        .style("stroke", "#333")
                        .style("stroke-width", "2px")
                        .style("stroke-dasharray",
                            function (d) {
                                if (d.connected == "No") {
                                    ////console.log("not connected");
                                    return (5, 5);

                                }
                                else if (d.connected == "Yes") {
                                    ////console.log("connected");
                                    return (3, 0);
                                }
                            })

                        //.attr("class", "node")
                        .on("mouseenter", function (d) {
                            is_connected(d, 0.1)
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            d3.select(this).transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight + 3);
                            })
                        })
                        .on("mouseleave", function (d) {
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            is_connected(d, 1);
                        })
                        .call(force.drag);

                    var labels = gnodes.append("text")
                        .attr("dx", 4)
                        .attr("dy", 4)
                        //.style("font", "14px Times New Roman")
                        .style("font", String(fontValue) + "px Arial")
                        .attr("text-anchor", function (d) {
                            return d.x < w / 2 ? "end" : "start";
                        })
                        .attr("transform", function (d) {
                            return d.x < w / 2 ? "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(-20)" : "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(20)";
                        })
                        //.attr("transform", function(d) { return  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")"})
                        //.attr("transform", function(d) { return (d.x-w/2)/(d.y-w/2) < 0 ?  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")" : "rotate(180)"; })
                        .text(function (d) {
                            return d.full_name
                        })

                    var drag = force.drag()
                        .on("dragstart", dragstart);
                    //.on("dragstart", dragstartAll);


                    //For not moving after drag
                    function dragstart(d) {
                        d3.select(this).classed("fixed", d.fixed = true);

                        for (i = 0; i < nodes.length; i++) {
                            nodes[i].fixed = true;
                        }
                    }


                    var svgText = svg6.append("text");
                    svgText.attr("x", 10).attr("y", globalHPlus50 - 50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);




                    var legend2 = svg6.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());
                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg6.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg6.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg6.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();



                };

                function circosView6(){
                    svg6.remove();

                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    scoreScale.domain(d3.extent(links, function (d) {
                        return d.score;
                    }));
                    colNodeScale.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));
                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = w,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;


                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;


                    svg6 = d3.select("#chart6")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);
                    svg6.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");


                    // This is for grouping nodes


                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h]);

// evenly spaces nodes along arc
                    var circleCoord = function (node, index, num_nodes) {
                        var circumference = circle.node().getTotalLength();
                        var pointAtLength = function (l) {
                            return circle.node().getPointAtLength(l)
                        };
                        var sectionLength = (circumference) / num_nodes;
                        var position = sectionLength * index + sectionLength / 2;
                        return pointAtLength(circumference - position)
                    }

                    var is_connected = function (d, opacity) {
                        lines.transition().style("stroke-opacity", function (o) {
                            return o.source === d || o.target === d ? 1 : opacity;
                        });
                    }




                    var dim = w - (widthValue - circleValue);
                    var circle = svg6.append("path")
                        .attr("d", "M " + String((widthValue - circleValue)/2) + ", " + (dim / 2 + (widthValue - circleValue)/2) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                        .style("fill", "white");


                    // var dim = w - 900
                    // var circle = svg6.append("path")
                    //     .attr("d", "M 450, " + (dim / 2 + 450) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                    //     .style("fill", "white");

                    force.start();

                    nodes.forEach(function (n, i) {
                        var coord = circleCoord(n, i, nodes.length)
                        n.x = coord.x
                        n.y = coord.y
                    });


                    // use this one for straight line links...
                    // var lines = svg.selectAll("line.node-link")
                    //     .data(links).enter().append("line")
                    //     .attr("class", "node-link")
                    //     .attr("x1", function(d) { return d.source.x; })
                    //     .attr("y1", function(d) { return d.source.y; })
                    //     .attr("x2", function(d) { return d.target.x; })
                    //     .attr("y2", function(d) { return d.target.y; });

                    svg6.append('defs').append('marker')
                        .attr({
                            'id': 'arrowhead',
                            'viewBox': '-0 -5 10 10',
                            'refX': 25,
                            'refY': 0,
                            //'markerUnits':'strokeWidth',
                            'orient': 'auto',
                            'markerWidth': 5,
                            'markerHeight': 6,
                            'xoverflow': 'visible'
                        })
                        .append('svg:path')
                        .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
                        .attr('fill', '#0000ff')
                        .attr('stroke', '#0000ff');

                    svg6.append('defs').append('marker')
                        .attr({
                            'id': 'block',
                            'viewBox': '-0 -10 20 20',
                            'refX': 25,
                            'refY': 0,
                            //'markerUnits':'strokeWidth',
                            'orient': 'auto',
                            'markerWidth': 15,
                            'markerHeight': 10,
                            'xoverflow': 'visible'
                        })
                        .append('svg:path')
                        .attr('d', 'M 0,0 m -1,-10 L 1,-10 L 1,10 L -1,10 Z')
                        .attr('fill', '#f00')
                        .attr('stroke', '#f00');


                    // var path = svg6.append("svg:g").selectAll("path")
                    // //.data(links)
                    //     .data(force.links())
                    //     .enter().append("svg:path")
                    //     .style("fill", "none")
                    //     .style("stroke", "black")
                    //     .style("stroke", function (d) {
                    //         return colScale(d.value);
                    //     })
                    //     //.attr("marker-end", function(d) { return "url(#" + d.type + ")"; })
                    //     .attr("class", function (d) {
                    //         return "link ";
                    //     })
                    //     //.attr('marker-end', function(d,i){ return 'url(#marker_stub)' });
                    //     .attr('marker-end', 'url(#arrowhead)');


                    var lines = svg6.selectAll("path.node-link")
                        .data(links).enter().append("path")
                        .style("fill", "none")
                        .style("stroke", function (d) {
                            if (d.tag == 2) {
                                return '#f00';
                            }
                            else if (d.tag == 1) {
                                return '#0000ff';
                            }
                            else {
                                return '#000000';
                            }
                        })
                        //.style("stroke", "#726363")
                        .attr("class", "node-link")
                        .style("stroke-width", function (d) {
                            return d.score / 2;
                        })
                        .attr("d", function (d) {

                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,
                                dr = Math.sqrt(dx * dx + dy * dy),
                                a1 = dx,
                                a2 = dy,
                                c1 = w / 2 - d.source.x,
                                c2 = h / 2 - d.source.y,
                                d1 = w / 2 - d.target.x,
                                d2 = h / 2 - d.target.y,

                                drx = dr / 1.5,
                                dry = dr / 1.5,
                                xRotation = 0, // degrees
                                largeArc = 0, // 1 or 0

                                sweep = 1, // 1 or 0
                                x2 = d.target.x,
                                y2 = d.target.y;


                            // if( (a1*c2 - a2*c1) > 0)
                            // {
                            //     sweep = 0
                            // }
                            // else
                            // {sweep = 1}
                            if ((c1 * d2 - c2 * d1) > 0) {
                                sweep = 0
                            }
                            else {
                                sweep = 1
                            }


                            return "M" + d.source.x + "," + d.source.y + "A" + drx + "," + dry + " " + xRotation + "," + largeArc + "," + sweep + " " + x2 + "," + y2;
                        })
                        // .attr("d", function (d) {
                        //     var dx = d.target.x - d.source.x,
                        //         dy = d.target.y - d.source.y,
                        //         dr = Math.sqrt(dx * dx + dy * dy);
                        //     return "M" +
                        //         d.source.x + "," +
                        //         d.source.y + "," +
                        //         d.target.x + "," +
                        //         d.target.y;
                        //
                        // })
                        .attr("class", function (d) {
                            return "node-link";
                        })
                        .attr('marker-end', function (d) {
                            if (d.tag == 1) {
                                return 'url(#block)'
                            }
                            if (d.tag == 2) {
                                return 'url(#arrowhead)'
                            }

                        });
                    //.attr('marker-end', function(d,i){ return 'url(#marker_stub)' });
                    //.attr('marker-end', 'url(#arrowhead)');


                    var gnodes = svg6.selectAll('g.gnode')
                        .data(nodes).enter().append('g')
                        .attr("transform", function (d) {
                            return "translate(" + d.x + "," + d.y + ")"
                        })
                        .classed('gnode', true);


                    // node.append("circle")
                    //     .attr("r", function (d) { return xScale(d.weight); })
                    //     .style("fill", function(d) { return colNodeScale(d.group); });

                    var node = gnodes.append("circle")
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        .style("fill", function (d) {
                            if (d.group == 0) {
                                return colorScale(d.value);
                            }
                            else {

                                if (d.group == 1) {
                                    return ("#ed0909");
                                }
                                if (d.group == 2) {
                                    return ("#0af702");
                                }
                                if (d.group == 3) {
                                    return ("#FF00FF");
                                }
                                if (d.group == 4) {
                                    return ("#808000");
                                }
                                if (d.group == 5) {
                                    return ("#000080");
                                }
                                if (d.group == 6) {
                                    return ("#800080");
                                }
                                if (d.group == 7) {
                                    return ("#00ffff");
                                }
                                if (d.group == 8) {
                                    return ("#F5F5DC");
                                }
                                if (d.group == 9) {
                                    return ("#A52A2A");
                                }
                                if (d.group == 10) {
                                    return ("#8B0000");
                                }
                                if (d.group == 11) {
                                    return ("#FF8C00");
                                }
                                if (d.group == 12) {
                                    return ("#000000");
                                }
                            }
                            //return colNodeScale(d.group);
                        })
                        // .style("fill", function (d) {
                        //     return colNodeScale(d.group);
                        // })
                        .style("stroke", "#333")
                        .style("stroke-width", "2px")
                        .style("stroke-dasharray",
                            function (d) {
                                if (d.connected == "No") {
                                    ////console.log("not connected");
                                    return (5, 5);

                                }
                                else if (d.connected == "Yes") {
                                    ////console.log("connected");
                                    return (3, 0);
                                }
                            })

                        //.attr("class", "node")
                        .on("mouseenter", function (d) {
                            is_connected(d, 0.1)
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            d3.select(this).transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight + 3);
                            })
                        })
                        .on("mouseleave", function (d) {
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            is_connected(d, 1);
                        })
                        .call(force.drag);

                    var labels = gnodes.append("text")
                        .attr("dx", 4)
                        .attr("dy", 4)
                        //.style("font", "14px Times New Roman")
                        .style("font", String(fontValue) + "px Arial")
                        .attr("text-anchor", function (d) {
                            return d.x < w / 2 ? "end" : "start";
                        })
                        .attr("transform", function (d) {
                            return d.x < w / 2 ? "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(-20)" : "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(20)";
                        })
                        //.attr("transform", function(d) { return  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")"})
                        //.attr("transform", function(d) { return (d.x-w/2)/(d.y-w/2) < 0 ?  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")" : "rotate(180)"; })
                        .text(function (d) {
                            return d.full_name
                        })

                    var drag = force.drag()
                        .on("dragstart", dragstart);
                    //.on("dragstart", dragstartAll);


                    //For not moving after drag
                    function dragstart(d) {
                        d3.select(this).classed("fixed", d.fixed = true);

                        for (i = 0; i < nodes.length; i++) {
                            nodes[i].fixed = true;
                        }
                    }


                    var svgText = svg6.append("text");
                    svgText.attr("x", 10).attr("y", globalHPlus50 - 50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);




                    var legend2 = svg6.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());
                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg6.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg6.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg6.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();



                };


                function parallelView6() {
                    svg6.remove();

                    //xPosition.domain(d3.extent(nodes, function (d) { return d.text; }));
                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    colNodeScale.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));
                    textPlacePlusMinus.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    textPlaceStartEnd.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    scoreScale.domain(d3.extent(links, function (d) {
                        return d.score;
                    }));
                    n1 = 0;
                    n2 = 0;

                    nodes.forEach(function (n, i) {


                        if (n.group == 0) {

                            n1 = n1 + 1;
                        }
                        else {

                            n2 = n2 + 1;
                        }

                    });


                    var totalN1 = n1;
                    var totalN2 = n2;
                    //console.log(n1);
                    //console.log(n1 * 12);
                    //console.log(n2);
                    //console.log(n2 * 12);
                    var parallelH = Math.max(n1 * 12, n2 * 12, 500);
                    //var parallelH = Math.max(n1 * 12, n2 * 12);

                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = parallelH,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;

                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;


                    svg6 = d3.select("#chart6")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);

                    svg6.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");


                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h]);


                    var parallelCoordx = function (group) {

                        if (group == 0) {
                            return w * 1.5 / 3.0;
                        }
                        else {
                            return w / 3.0;
                        }
                    }

                    var parallelCoordy = function (index, num_nodes) {
                        var dist = h / (num_nodes + 1);

                        return (index + 1) * dist;
                    }

                    var is_connected = function (d, opacity) {
                        lines.transition().style("stroke-opacity", function (o) {
                            return o.source === d || o.target === d ? 1 : opacity;
                        });
                    }

                    //var dim = w-80
                    // var circle = svg.append("path")
                    //     .attr("d", "M 40, "+(dim/2+40)+" a "+dim/2+","+dim/2+" 0 1,0 "+dim+",0 a "+dim/2+","+dim/2+" 0 1,0 "+dim*-1+",0")
                    //     .style("fill", "#f5f5f5");

                    force.start();


                    // //console.log(nodes.length);
                    var groupId = [];
                    var maxId = 0;
                    for (var i = 0; i < nodes.length; i++) {
                        var item = nodes[i];

                        if (!groupId[item.group]) {
                            groupId[item.group] = [];
                        }

                        groupId[item.group].push({name: item.name});
                        // //console.log(item.group);
                        // //console.log(groupId[item.group]);
                        if (maxId < item.group) {
                            maxId = item.group;
                        }
                    }
                    // //console.log(maxId);
                    // //console.log(groupId[1].length);
                    // //console.log(groupId[2].length);

                    n1 = 0;
                    n2 = 0;

                    nodes.forEach(function (n, i) {
                        var item = nodes[i];

                        if (n.group == 0) {
                            n.x = parallelCoordx(n.group)
                            n.y = parallelCoordy(n1, totalN1)
                            n1 = n1 + 1;
                        }
                        else {
                            n.x = parallelCoordx(n.group)
                            n.y = parallelCoordy(n2, totalN2)
                            n2 = n2 + 1;
                        }
                        // n.weight = links.filter(function (l) {
                        //     return l.source.index == n.index || l.target.index == n.index
                        // }).size();

                    });


                    // use this one for straight line links...
                    // var lines = svg.selectAll("line.node-link")
                    //   .data(links).enter().append("line")
                    //     .attr("class", "node-link")
                    //   .attr("x1", function(d) { return d.source.x; })
                    //   .attr("y1", function(d) { return d.source.y; })
                    //   .attr("x2", function(d) { return d.target.x; })
                    //   .attr("y2", function(d) { return d.target.y; });


                    svg6.append('defs').append('marker')
                        .attr({
                            'id': 'arrowhead',
                            'viewBox': '-0 -5 10 10',
                            'refX': 25,
                            'refY': 0,
                            //'markerUnits':'strokeWidth',
                            'orient': 'auto',
                            'markerWidth': 5,
                            'markerHeight': 6,
                            'xoverflow': 'visible'
                        })
                        .append('svg:path')
                        .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
                        .attr('fill', '#0000ff')
                        .attr('stroke', '#0000ff');

                    svg6.append('defs').append('marker')
                        .attr({
                            'id': 'block',
                            'viewBox': '-0 -10 20 20',
                            'refX': 25,
                            'refY': 0,
                            //'markerUnits':'strokeWidth',
                            'orient': 'auto',
                            'markerWidth': 15,
                            'markerHeight': 10,
                            'xoverflow': 'visible'
                        })
                        .append('svg:path')
                        .attr('d', 'M 0,0 m -1,-10 L 1,-10 L 1,10 L -1,10 Z')
                        .attr('fill', '#f00')
                        .attr('stroke', '#f00');


                    var lines = svg6.selectAll("path.node-link")
                        .data(links).enter().append("path")
                        .style("fill", "none")
                        .style("stroke", function (d) {
                            if (d.tag == 2) {
                                return '#f00';
                            }
                            else if (d.tag == 1) {
                                return '#0000ff';
                            }
                            else {
                                return '#000000';
                            }
                        })
                        .attr("class", "node-link")
                        .style("stroke-width", function (d) {
                            return d.score / 2;
                        })
                        .attr("d", function (d) {
                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,
                                dr = Math.sqrt(dx * dx + dy * dy);
                            return "M" +
                                d.source.x + "," +
                                d.source.y + "," +
                                d.target.x + "," +
                                d.target.y;
                        });


                    // nodes.weight = lines.filter(function(l) {
                    //     return l.source.index == d.index || l.target.index == d.index
                    // }).size();

                    // var lines = svg.selectAll("path.node-link")
                    //     .data(links).enter().append("path")
                    //     .style("fill", "none")
                    //     .style("stroke", "black")
                    //     .attr("class", "node-link")
                    //     .attr("d", function(d) {
                    //         var dx = d.target.x - d.source.x,
                    //             dy = d.target.y - d.source.y,
                    //             dr = Math.sqrt(dx * dx + dy * dy);
                    //         return "M" +
                    //             d.source.x + "," +
                    //             d.source.y + "A" +
                    //             dr + "," + dr + " 0 0,1 " +
                    //             d.target.x + "," +
                    //             d.target.y;
                    //     });

                    var gnodes = svg6.selectAll('g.gnode')
                        .data(nodes).enter().append('g')
                        .attr("transform", function (d) {
                            return "translate(" + d.x + "," + d.y + ")"
                        })
                        .classed('gnode', true);

                    // gnodes.forEach(function (n, i) {
                    //     n.weight = lines.filter(function (l) {
                    //         return l.source.idx == n.idx || l.target.idx == n.idx
                    //     }).size();
                    //
                    // });
                    var node = gnodes.append("circle")
                    //.attr("r", function(d) {
                    // d.sizes = lines.filter(function(l) {
                    //     return l.source.index == d.index || l.target.index == d.index
                    // }).size();
                    // var minRadius = 5;
                    // return minRadius + (d.sizes * 2);
                    //     return colorScale(d.weight);
                    // })
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        .style("fill", function (d) {
                            if (d.group == 0) {
                                return colorScale(d.value);
                            }
                            else {
                                if (d.group == 1) {
                                    return ("#ed0909");
                                }
                                if (d.group == 2) {
                                    return ("#0af702");
                                }
                                if (d.group == 3) {
                                    return ("#FF00FF");
                                }
                                if (d.group == 4) {
                                    return ("#808000");
                                }
                                if (d.group == 5) {
                                    return ("#000080");
                                }
                                if (d.group == 6) {
                                    return ("#800080");
                                }
                                if (d.group == 7) {
                                    return ("#00ffff");
                                }
                                if (d.group == 8) {
                                    return ("#F5F5DC");
                                }
                                if (d.group == 9) {
                                    return ("#A52A2A");
                                }
                                if (d.group == 10) {
                                    return ("#8B0000");
                                }
                                if (d.group == 11) {
                                    return ("#FF8C00");
                                }
                                if (d.group == 12) {
                                    return ("#000000");
                                }
                            }
                            //return colNodeScale(d.group);
                        })
                        // .style("fill", function (d) {
                        //     return colNodeScale(d.group);
                        // })
                        .style("stroke", "#333")
                        .style("stroke-width", "2px")
                        .style("stroke-dasharray",
                            function (d) {
                                if (d.connected == "No") {
                                    ////console.log("not connected");
                                    return (5, 5);

                                }
                                else if (d.connected == "Yes") {
                                    ////console.log("connected");
                                    return (3, 0);
                                }
                            })
                        //.attr("class", "node")
                        .on("mouseenter", function (d) {
                            is_connected(d, 0.1)
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            d3.select(this).transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight + 3);
                            })
                        })
                        .on("mouseleave", function (d) {
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            is_connected(d, 1);
                        })
                        .call(force.drag);
                    // var bbox = textElement.getBBox();
                    // var width = bbox.width;
                    // var height = bbox.height;
                    var labels = gnodes.append("text")
                        //.style("font", "14px Times New Roman")
                        .style("font", String(fontValue) + "px Arial")
                        .attr("dx", function (d) {
                            return textPlacePlusMinus(d.group);
                        })
                        .attr("dy", 4)
                        .attr("text-anchor", function (d) {
                            return textPlaceStartEnd(d.group);
                        })
                        .text(function (d) {
                            return d.full_name
                        })

                    var svgText = svg6.append("text");
                    svgText.attr("x", 10).attr("y", globalHPlus50 - 50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);




                    var legend2 = svg6.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());
                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg6.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg6.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg6.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();



                    //till here for coloring the legend

                };


                function defaultView6() {


                    svg6.remove();

                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    colNodeScale.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    // colorScale.domain(d3.extent(nodes, function (d) {
                    //     return d.value;
                    // }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));
                    scoreScale.domain(d3.extent(links, function (d) {
                        return d.score;
                    }));
                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = w,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;

//These variables are global variables
                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;

                    svg6 = d3.select("#chart6")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);
                    svg6.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");


                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h])
                        .linkDistance(150)
                        .charge(-500)
                        //.linkStrength(0.9)
                        //.friction(0.9)
                        //.chargeDistance(300)
                        .gravity(0.25)
                        //.theta(0.8)
                        //.alpha(0.1)
                        .on("tick", tick)
                        .start();

                    // for (var i = n*n; i > 0; --i) force.tick();
                    // force.stop();

                    //.stop();


                    svg6.append('defs').append('marker')
                        .attr({
                            'id': 'arrowhead',
                            'viewBox': '-0 -5 10 10',
                            'refX': 25,
                            'refY': 0,
                            //'markerUnits':'strokeWidth',
                            'orient': 'auto',
                            'markerWidth': 5,
                            'markerHeight': 6,
                            'xoverflow': 'visible'
                        })
                        .append('svg:path')
                        .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
                        .attr('fill', '#0000ff')
                        .attr('stroke', '#0000ff');

                    svg6.append('defs').append('marker')
                        .attr({
                            'id': 'block',
                            'viewBox': '-0 -10 20 20',
                            'refX': 25,
                            'refY': 0,
                            //'markerUnits':'strokeWidth',
                            'orient': 'auto',
                            'markerWidth': 15,
                            'markerHeight': 10,
                            'xoverflow': 'visible'
                        })
                        .append('svg:path')
                        .attr('d', 'M 0,0 m -1,-10 L 1,-10 L 1,10 L -1,10 Z')
                        .attr('fill', '#f00')
                        .attr('stroke', '#f00');


                    var path = svg6.append("svg:g").selectAll("path")
                    //.data(links)
                        .data(force.links())
                        .enter().append("svg:path")
                        .style("stroke-width", function (d) {
                            return d.score / 2;
                        })
                        .style("stroke", function (d) {
                            if (d.tag == 2) {
                                return '#f00';
                            }
                            else if (d.tag == 1) {
                                return '#0000ff';
                            }
                            else {
                                return '#000000';
                            }
                        })
                        //.style("stroke", function (d) {return colScale(d.value); })
                        .attr("class", function (d) {
                            return "link ";
                        })
                        // .attr("class", function (d) {
                        //     return "node-link";
                        // })
                        .attr('marker-end', function (d) {
                            if (d.tag == 1) {
                                return 'url(#block)'
                            }
                            if (d.tag == 2) {
                                return 'url(#arrowhead)'
                            }

                        });


                    var node = svg6.append("svg:g").selectAll("g.node")
                        .data(force.nodes())
                        .enter().append("svg:g")
                        // .style("stroke-width", 3)
                        // .style('stroke', "black")
                        //.attr("class", "node")
                        .call(force.drag);

                    // nodes.forEach(function(v) {
                    //     var nd;
                    //     var cx = v.coord[0];
                    //     var cy = v.coord[1];
                    //
                    //     switch (v.group) {
                    //         case 1:
                    //             nd = svg.append("circle");
                    //             break;
                    //         case 2:
                    //             nd = svg.append("rect");
                    //             break;
                    //     }
                    // });


                    var colorsForAbundance = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];
                    var colorScale = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colorsForAbundance);


                    node.append("circle")
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        .style("fill", function (d) {
                            if (d.group == 0) {
                                if (d.value < -2.0) {
                                    return "#00A6FF";
                                }
                                if (d.value <= -1.6 && d.value > -2) {
                                    return "#1097E0";
                                }
                                if (d.value <= -1.2 && d.value > -1.6) {
                                    return "#2885B7";
                                }
                                if (d.value <= -0.8 && d.value > -1.2) {
                                    return "#35799E";
                                }
                                if (d.value <= -0.4 && d.value > -1.8) {
                                    return "#4C7991";
                                }
                                if (d.value <= -0.01 && d.value > -0.4) {
                                    return "#6D828D";
                                }
                                if (d.value <= 0.01 && d.value > -0.01) {
                                    return "#8C8C8C";
                                }
                                if (d.value <= 0.4 && d.value > 0.01) {
                                    return "#8E8E5C";
                                }
                                if (d.value <= 0.8 && d.value > 0.4) {
                                    return "#92923C";
                                }
                                if (d.value <= 1.2 && d.value > 0.8) {
                                    return "#A5A52E";
                                }
                                if (d.value <= 1.6 && d.value > 1.2) {
                                    return "#BDBD24";
                                }
                                if (d.value <= 2.0 && d.value > 1.6) {
                                    return "#DDDD15";
                                }
                                if (d.value > 2.0) {
                                    return "#FFFF00";
                                }
                                ////console.log(d.value);
                                //return colorScale(d.value);
                                //   return d3.scale.threshold()
                                //       .domain(d.value)
                                //       .range(colorsForAbundance);

                            }
                            else {
                                if (d.group == 1) {
                                    return ("#ed0909");
                                }
                                if (d.group == 2) {
                                    return ("#0af702");
                                }
                                if (d.group == 3) {
                                    return ("#FF00FF");
                                }
                                if (d.group == 4) {
                                    return ("#808000");
                                }
                                if (d.group == 5) {
                                    return ("#000080");
                                }
                                if (d.group == 6) {
                                    return ("#800080");
                                }
                                if (d.group == 7) {
                                    return ("#00ffff");
                                }
                                if (d.group == 8) {
                                    return ("#F5F5DC");
                                }
                                if (d.group == 9) {
                                    return ("#A52A2A");
                                }
                                if (d.group == 10) {
                                    return ("#8B0000");
                                }
                                if (d.group == 11) {
                                    return ("#FF8C00");
                                }
                                if (d.group == 12) {
                                    return ("#000000");
                                }

                            }
                            //return colNodeScale(d.group);
                        })
                        // .style("fill", function (d) {
                        //     return colNodeScale(d.group);
                        // })
                        .style("stroke", "#333")
                        .style("stroke-dasharray",
                            function (d) {
                                if (d.connected == "No") {
                                    ////console.log("not connected");
                                    return (5, 5);

                                }
                                else if (d.connected == "Yes") {
                                    ////console.log("connected");
                                    return (3, 0);
                                }
                            })
                        .style("stroke-width", "2px");
                    //.on("dblclick", dblclick);


                    // node.append("circle")
                    //     .attr("r", function (d) {
                    //         return xScale(d.weight);
                    //     })
                    //     .style("fill", function (d) {
                    //         if (d.group == 1) {
                    //             return colorScale(d.value);
                    //         }
                    //         else {
                    //             return colNodeScale(d.group);
                    //         }
                    //         //return colNodeScale(d.group);
                    //     })
                    //     .style("stroke", "#333")
                    //     .style("stroke-width", "2px");


                    function openLink() {
                        return function (d) {
                            var url = "";
                            if (d.slug != "") {
                                url = d.slug
                            } //else if(d.type == 2) {
                            //url = "clients/" + d.slug
                            //} else if(d.type == 3) {
                            //url = "agencies/" + d.slug
                            //}
                            window.open("//" + url)
                        }
                    };
                    node.append("svg:image")
                    //****************************************
                    //.attr("class", function(d){ return d.name })
                    //****************************************
                    //.attr("xlink:href", function(d){ return d.img_hrefD})
                        .attr("x", "-36px")
                        .attr("y", "-36px")
                        .attr("width", "70px")
                        .attr("height", "70px")
                    //.on("dblclick", openLink());

                    // .on("mouseover", function (d) { if(d.entity == "company")
                    // {
                    //     d3.select(this).attr("width", "90px")
                    //         .attr("x", "-46px")
                    //         .attr("y", "-36.5px")
                    //         .attr("xlink:href", function(d){ return d.img_hrefL});
                    // }
                    // })
                    // .on("mouseout", function (d) { if(d.entity == "company")
                    // {
                    //     d3.select(this).attr("width", "70px")
                    //         .attr("x", "-36px")
                    //         .attr("y", "-36px")
                    //         .attr("xlink:href", function(d){ return d.img_hrefD});
                    // }
                    // });


                    //.text(function(d) { return d.name })
                    node.append("svg:text")
                    //****************************************
                        .attr("class", function (d) {
                            return d.full_name
                        })
                        //****************************************
                        .attr("x", 16)
                        .attr("y", ".31em")
                        //.attr("class", "shadow")
                        //.style("font-size","10px")
                        // .attr("dx", 0)
                        // .attr("dy", ".35em")
                        //.style("font-size","12px")
                        //****************************************
                        //text.shadow {
                        .style("stroke", "#fff")
                        .style("stroke-width", "4px")
                        //}
                        //.attr("class", "shadow")
                        .style("font", String(fontValue) + "px Arial")
                        //.style("font", "14px Times New Roman")
                        //****************************************
                        //.attr("text-anchor", "middle")
                        //****************************************
                        .text(function (d) {
                            return d.full_name
                        });
                    //****************************************


                    //This one is for the actual text
                    node.append("svg:text")
                    //****************************************
                        .attr("class", function (d) {
                            return d.full_name
                        })
                        //****************************************
                        .attr("x", 16)
                        .attr("y", ".31em")
                        //.attr("class", "shadow")
                        //.style("font-size","10px")
                        // .attr("dx", 0)
                        // .attr("dy", ".35em")
                        //.style("font-size","12px")
                        //****************************************
                        //.style("font", "14px Times New Roman")
                        .style("font", String(fontValue) + "px Arial")
                        //****************************************
                        //.attr("text-anchor", "middle")
                        //****************************************
                        .text(function (d) {
                            return d.full_name
                        });
                    //****************************************


                    node.on("mouseover", function (d) {
                        // d3.select(this).select("text")
                        //     .transition()
                        //     .duration(300)
                        //     .text(function (d) {
                        //         return d.full_name;
                        //     })
                        // //.style("font-size", "15px")
                        // .style("font", "14px Times New Roman");
                        //
                        // d3.select(this).select("text")
                        //     .transition()
                        //     .duration(300)
                        //     .text(function (d) {
                        //         return d.full_name;
                        //     })
                        //     //.style("font-size", "15px")
                        //     //.attr("class", "shadow")
                        //     .style("font", "14px Times New Roman");
                        // d3.select(this).select("text")
                        //     .transition()
                        //     .duration(300)
                        //     .text(function (d) {
                        //         return d.full_name;
                        //     })
                        //
                        //     .style("fill",'black')
                        //     .style("font", "14px Times New Roman");

                        //d3.selectAll("text").remove();
                        //d3.select(this).style("stroke-width", 6);

                        //d3.select(this).select("text").style("stroke", "blue");

                        var nodeNeighbors = links.filter(function (link) {
                            // Filter the list of links to only those links that have our target
                            // node as a source or target
                            return link.source.index === d.index || link.target.index === d.index;
                        })
                            .map(function (link) {
                                // Map the list of links to a simple array of the neighboring indices - this is
                                // technically not required but makes the code below simpler because we can use
                                // indexOf instead of iterating and searching ourselves.
                                return link.source.index === d.index ? link.target.index : link.source.index;
                            });

                        d3.selectAll('circle').filter(function (node) {
                            // I filter the selection of all circles to only those that hold a node with an
                            // index in my listg of neighbors
                            return nodeNeighbors.indexOf(node.index) > -1;
                        })
                            .style('stroke', 'blue');

                        //d3.selectAll('text').filter(d).style('fill', 'blue');
                        //****************************
                        // d3.selectAll('text').filter(function(node) {
                        //     // I filter the selection of all circles to only those that hold a node with an
                        //     // index in my listg of neighbors
                        //     return nodeNeighbors.indexOf(node.index) > -1;
                        // }).style('fill', 'blue')
                        //     //.style("font-size", "16px")
                        //     //.style("font-weight", "bold");
                        // //****************************
                        path.style('stroke', function (l) {
                            if (d === l.source || d === l.target)
                                return "blue";
                            else
                                return "grey";
                        })

                        path.style('stroke-width', function (l) {
                            if (d === l.source || d === l.target)
                                return 2;
                            else
                                return 1;
                        })

                    })
                        .on("mouseout", function (d) {
                            d3.select(this).select("text")
                                .transition()
                                .duration(300)
                                .text(function (d) {

                                    return d.full_name;
                                });
                            // d3.select(this).select("text")
                            //     //*******************************
                            //     .style("font", "14px Times New Roman")
                            //     //*******************************
                            //     .style("font-size", "14px")
                            //     .style("fill",'black')
                            //     .style("font-weight", "normal");

                            // d3.select(this).select("text")
                            // //*******************************
                            //     .style("font", "14px Times New Roman")
                            //     //*******************************
                            //     .style("font-size", "14px")
                            //     .style("fill",'black')
                            //     .style("font-weight", "normal");
                            //d3.select(this).style("stroke", "black");
                            //d3.select(this).style("stroke-width", 1);
                            //d3.select(this).style("stroke", "#333");
                            path.style('stroke', "grey");
                            path.style('stroke-width', 1);
                            //circle.style('stroke', "grey");
                            //node.style("stroke-width", 3);
                            //node.style("stroke", "#333");
                            //d3.selectAll('text').style('fill', 'black')
                            // d3.selectAll('text').style('fill', 'black')
                            //     .style("font-weight", "normal");
                            //d3.selectAll("text").style("font-weight", "normal");
                            node.selectAll("circle").style("stroke-width", 3)
                                .style('stroke', "black");
                            //.style("font-size", "12px");
                            //}
                        });


                    function pythag(r, b, coord) {
                        r += nodeBaseRad;

                        // force use of b coord that exists in circle to avoid sqrt(x<0)
                        b = Math.min(w - r - strokeWidth, Math.max(r + strokeWidth, b));

                        var b2 = Math.pow((b - radius), 2),
                            a = Math.sqrt(hyp2 - b2);

                        function openLink() {
                            return function (d) {
                                var url = "";
                                if (d.slug != "") {
                                    url = d.slug
                                } //else if(d.type == 2) {
                                //url = "clients/" + d.slug
                                //} else if(d.type == 3) {
                                //url = "agencies/" + d.slug
                                //}
                                window.open("//" + url)
                            }
                        }

                        // radius - sqrt(hyp^2 - b^2) < coord < sqrt(hyp^2 - b^2) + radius
                        coord = Math.max(radius - a + r + strokeWidth,
                            Math.min(a + radius - r - strokeWidth, coord));

                        return coord;
                    }

                    function tick(e) {
                        path.attr("d", function (d) {
                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,

                                dr = Math.sqrt(dx * dx + dy * dy);
                            ////console.log(d.source.x);
                            // //console.log(d.target.x);
                            return "M" + d.source.x + "," + d.source.y + "," + d.target.x + "," + d.target.y;
                            //return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
                        });

                        node.attr('x', function (d) {
                            return d.x = pythag(Math.random() * 12, d.y, d.x);
                        })
                            .attr('y', function (d) {
                                return d.y = pythag(Math.random() * 12, d.x, d.y);
                            })
                            .attr("transform", function (d) {
                                return "translate(" + d.x + "," + d.y + ")"
                            });

                        //d3.select(this).classed("fixed", d.fixed = true);
                        // circle.attr("transform", function(d) {
                        //     return "translate(" + d.x + "," + d.y + ")";
                        // });
                        //************************************
                        // text.attr("transform", function(d) {
                        //     return "translate(" + d.x + "," + d.y + ")";
                        // });
                        //************************************
                    }

                    //For not moving after drag
                    var drag = force.drag()
                        .on("dragstart", dragstart);
                    //.on("dragstart", dragstartAll);

                    //For not moving after drag
                    function dblclick(d) {
                        d3.select(this).classed("fixed", d.fixed = false);

                    }

                    //For not moving after drag
                    function dragstart(d) {
                        d3.select(this).classed("fixed", d.fixed = true);

                        for (i = 0; i < nodes.length; i++) {
                            nodes[i].fixed = true;
                        }
                    }


                    var svgText = svg6.append("text");
                    svgText.attr("x", 10).attr("y", globalHPlus50 - 50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);




                    var legend2 = svg6.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());
                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg6.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg6.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg6.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();



                    //till here for coloring the legend


                    // For legend
                    // var colNodeScaleSeparateInfo = d3.scale.ordinal()
                    //     .range(["#767776", "#f91104"])
                    //     .domain(["Query Gene Set", "Pathways / Kinases Perturbation"]);
                    //
                    //
                    // var legend = svg.selectAll(".legend")
                    //     .data(colNodeScaleSeparateInfo.domain())
                    //     .enter().append("g")
                    //     .attr("class", "legend")
                    //     .attr("transform", function (d, i) {
                    //         return "translate(0," + (i) * 25 + ")";
                    //     });
                    //
                    // legend.append("rect")
                    //     .attr("x", w - 25)
                    //     .attr("width", 25)
                    //     .attr("height", 25)
                    //     .style("fill", colNodeScaleSeparateInfo);
                    //
                    // legend.append("text")
                    //     .attr("x", w - 35)
                    //     .attr("y", 12.5)
                    //     .attr("dy", ".35em")
                    //     .style("text-anchor", "end")
                    //     .text(function (d) {
                    //         return d;
                    //     });
                    //
                    //
                    // d3.select("#download").on("click", function () {
                    //     d3.select(this)
                    //         .attr("href", 'data:application/octet-stream;base64,' + btoa(d3.select("#chart").html()))
                    //         .attr("download", "pathway_network.svg")
                    // })

                };

                //defaultSVGPtm();
                //SharedService.setVar('svg', svg);

                d3.select('#force6').on('click', function () {
                    defaultView6();
                    $scope.graphType4signor = 0;
                });
                d3.select('#parallelView6').on('click', function () {
                    parallelView6();
                    $scope.graphType4signor = 1;
                });
                d3.select('#circosView6').on('click', function (){
                    circosView6();
                    $scope.graphType4signor = 2;
                });
                d3.select('#circularView6').on('click', function (){
                    circularView6();
                    $scope.graphType4signor = 3;
                });


                if(graphType == 0){
                    defaultView6();
                }
                else if(graphType == 1){
                    parallelView6();
                }
                else if(graphType == 2){
                    circosView6();
                }
                else if(graphType == 3){
                    circularView6();
                }



                d3.select("#download-svg6").on("click", function ()  {
                    var name = 'PiNET-SIGNOR-Graph.svg';
                    var svgEl = svg6.node();
                    svgEl.setAttribute("xmlns", "http://www.w3.org/2000/svg");
                    var svgData = svgEl.outerHTML;
                    var preface = '<?xml version="1.0" standalone="no"?>\r\n';
                    var svgBlob = new Blob([preface, svgData], {type:"image/svg+xml;charset=utf-8"});
                    var svgUrl = URL.createObjectURL(svgBlob);
                    var downloadLink = document.createElement("a");
                    downloadLink.href = svgUrl;
                    downloadLink.download = name;
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                })


//             d3.select('#drug1').on('click', function () {
//                 svg.remove();
//
//                 //xPosition.domain(d3.extent(nodes, function (d) { return d.text; }));
//                 xScale.domain(d3.extent(nodes, function (d) {
//                     return d.weight;
//                 }));
//                 colNodeScale.domain(d3.extent(nodes, function (d) {
//                     return d.group;
//                 }));
//                 colScale.domain(d3.extent(links, function (d) {
//                     return d.weight;
//                 }));
//                 textPlacePlusMinus.domain(d3.extent(nodes, function (d) {
//                     return d.group;
//                 }));
//                 textPlaceStartEnd.domain(d3.extent(nodes, function (d) {
//                     return d.group;
//                 }));
//
//                 var drug_data = {
//                     "nodes": [{"full_name": "PRKCG", "weight": 0, "idx": 0, "group": 1},
//                         {"full_name": "YWHAZ", "weight": 0, "idx": 1, "group": 1},
//                         {"full_name": "ALB", "weight": 0, "idx": 2, "group": 1},
//                         {"full_name": "NSF", "weight": 0, "idx": 3, "group": 1},
//                         {"full_name": "FGA", "weight": 0, "idx": 4, "group": 1},
//                         {"full_name": "VCAN", "weight": 0, "idx": 5, "group": 1},
//                         {"full_name": "AK5", "weight": 0, "idx": 6, "group": 1},
//                         {"full_name": "CAMK2A", "weight": 0, "idx": 7, "group": 1},
//                         {"full_name": "LANCL1", "weight": 0, "idx": 8, "group": 1},
//                         {"full_name": "PRKCB", "weight": 0, "idx": 9, "group": 1},
//                         {"full_name": "CAMK2B", "weight": 0, "idx": 10, "group": 1},
//                         {"full_name": "TUBA1A", "weight": 0, "idx": 11, "group": 1},
//                         {"full_name": "CKB", "weight": 0, "idx": 12, "group": 1},
//                         {"full_name": "TUBB2A", "weight": 0, "idx": 13, "group": 1},
//                         {"full_name": "ACTB", "weight": 0, "idx": 14, "group": 1},
//                         {"full_name": "CAMK2D", "weight": 0, "idx": 15, "group": 1},
//                         {"full_name": "FGG", "weight": 0, "idx": 16, "group": 1},
//                         {"full_name": "APOE", "weight": 0, "idx": 17, "group": 1},
//                         {"full_name": "fluphenazine", "weight": 0, "idx": 18, "group": 2},
//                         {"full_name": "mesoridazine", "weight": 0, "idx": 19, "group": 2},
//                         {"full_name": "thioproperazine", "weight": 0, "idx": 20, "group": 2},
//                         {"full_name": "thioridazine", "weight": 0, "idx": 21, "group": 2},
//                         {"full_name": "trifluoperazine", "weight": 0, "idx": 22, "group": 2}],
//                     "edges": [{"source": 0, "target": 18}, {"source": 0, "target": 21}, {"source": 0, "target": 22},
//                         {"source": 3, "target": 19}, {"source": 3, "target": 20}, {
//                             "source": 3,
//                             "target": 21
//                         }, {"source": 3, "target": 22},
//                         {"source": 4, "target": 19}, {"source": 4, "target": 20}, {
//                             "source": 4,
//                             "target": 21
//                         }, {"source": 4, "target": 22},
//                         {"source": 5, "target": 18}, {"source": 5, "target": 19}, {
//                             "source": 5,
//                             "target": 21
//                         }, {"source": 5, "target": 22},
//                         {"source": 7, "target": 18}, {"source": 7, "target": 21}, {"source": 7, "target": 22},
//                         {"source": 9, "target": 18}, {"source": 9, "target": 21}, {"source": 9, "target": 22},
//                         {"source": 10, "target": 19}, {"source": 10, "target": 20},
//                         {"source": 11, "target": 18}, {"source": 11, "target": 21}, {"source": 11, "target": 22},
//                         {"source": 12, "target": 19}, {"source": 12, "target": 21}, {"source": 12, "target": 22},
//                         {"source": 13, "target": 18}, {"source": 13, "target": 21}, {"source": 13, "target": 22},
//                         {"source": 15, "target": 18}, {"source": 15, "target": 22},
//                         {"source": 17, "target": 22}]
//                 };
//
//                 var margin = 75,
//                     w = 750 - 2 * margin,
//                     h = w,
//                     radius = w / 2,
//                     strokeWidth = 4,
//                     hyp2 = Math.pow(radius, 2),
//                     nodeBaseRad = 5;
//
//
//                 nodes = drug_data.nodes;
//                 links = drug_data.edges;
//                 svg = d3.select("#chart")
//                     .append("svg")
//                     .attr("style", "outline: thin solid yellow;")
//                     .attr("width", w)
//                     .attr("height", h);
//
//                 svg.append("rect")
//                     .attr("width", "100%")
//                     .attr("height", "100%")
//                     .attr("fill", "white");
//
//
//                 var force = d3.layout.force()
//                     .nodes(nodes)
//                     .links(links)
//                     .size([w, h]);
//
//
//                 var parallelCoordx = function (group) {
//
//                     if (group == 1) {
//                         return w * 2 / 3;
//                     }
//                     else {
//                         return w / 2.2;
//                     }
//                 }
//
//                 var parallelCoordy = function (index, num_nodes) {
//                     var dist = h / (num_nodes + 1);
//
//                     return (index + 1) * dist;
//                 }
//
//                 var is_connected = function (d, opacity) {
//                     lines.transition().style("stroke-opacity", function (o) {
//                         return o.source === d || o.target === d ? 1 : opacity;
//                     });
//                 }
//
//                 //var dim = w-80
//                 // var circle = svg.append("path")
//                 //     .attr("d", "M 40, "+(dim/2+40)+" a "+dim/2+","+dim/2+" 0 1,0 "+dim+",0 a "+dim/2+","+dim/2+" 0 1,0 "+dim*-1+",0")
//                 //     .style("fill", "#f5f5f5");
//
//                 force.start();
//
//
//                 // //console.log(nodes.length);
//                 var groupId = [];
//                 var maxId = 0;
//                 for (var i = 0; i < nodes.length; i++) {
//                     var item = nodes[i];
//
//                     if (!groupId[item.group]) {
//                         groupId[item.group] = [];
//                     }
//
//                     groupId[item.group].push({name: item.name});
//                     // //console.log(item.group);
//                     // //console.log(groupId[item.group]);
//                     if (maxId < item.group) {
//                         maxId = item.group;
//                     }
//                 }
//                 // //console.log(maxId);
//                 // //console.log(groupId[1].length);
//                 // //console.log(groupId[2].length);
//
//                 n1 = 0;
//                 n2 = 0;
//
//                 nodes.forEach(function (n, i) {
//                     var item = nodes[i];
//
//                     if (n.group == 1) {
//                         n.x = parallelCoordx(n.group)
//                         n.y = parallelCoordy(n1, groupId[1].length)
//                         n1 = n1 + 1;
//                     }
//                     if (n.group == 2) {
//                         n.x = parallelCoordx(n.group)
//                         n.y = parallelCoordy(n2, groupId[2].length)
//                         n2 = n2 + 1;
//                     }
//
//                 });
//
//
//                 var lines = svg.selectAll("path.node-link")
//                     .data(links).enter().append("path")
//                     .style("fill", "none")
//                     .style("stroke", "#726363")
//                     .attr("class", "node-link")
//                     .attr("d", function (d) {
//                         var dx = d.target.x - d.source.x,
//                             dy = d.target.y - d.source.y,
//                             dr = Math.sqrt(dx * dx + dy * dy);
//                         return "M" +
//                             d.source.x + "," +
//                             d.source.y + "," +
//                             d.target.x + "," +
//                             d.target.y;
//                     });
//
//
//                 var gnodes = svg.selectAll('g.gnode')
//                     .data(nodes).enter().append('g')
//                     .attr("transform", function (d) {
//                         return "translate(" + d.x + "," + d.y + ")"
//                     })
//                     .classed('gnode', true);
//
//
// //to include molecule figure substitute this
//                 var node = gnodes.append("circle")
//                     .attr("r", function (d) {
//                         return xScale(d.weight);
//                     })
//                     .style("fill", function (d) {
//                         return colNodeScale(d.group);
//                     })
//                     .style("stroke", "#333")
//                     .style("stroke-width", "2px")
//                     //.attr("class", "node")
//                     .on("mouseenter", function (d) {
//                         is_connected(d, 0.1)
//                         node.transition().duration(100).attr("r", function (d) {
//                             return xScale(d.weight);
//                         })
//                         d3.select(this).transition().duration(100).attr("r", function (d) {
//                             return xScale(d.weight + 10);
//                         })
//                     })
//                     .on("mouseleave", function (d) {
//                         node.transition().duration(100).attr("r", function (d) {
//                             return xScale(d.weight);
//                         })
//                         is_connected(d, 1);
//                     })
//                     .call(force.drag);
//
//
//                 // gnodes.append("image")
//                 //     .attr("xlink:href", function(d) { return d.group < 2 ? "images/molecule-icon.png" : "images/pathway.png"; })
//                 //     .attr("x", -8)
//                 //     .attr("y", -8)
//                 //     .attr("width", 16)
//                 //     .attr("height", 16);
//
//
//                 var labels = gnodes.append("text")
//
//                     .attr("dx", function (d) {
//                         return textPlacePlusMinus(d.group);
//                     })
//                     .attr("dy", 4)
//                     .attr("text-anchor", function (d) {
//                         return textPlaceStartEnd(d.group);
//                     })
//                     .text(function (d) {
//                         return d.full_name
//                     })
//
//             });
//
//             d3.select('#customizedParallelView1').on('click', function () {
//                 svg.remove();
//
//
//                 var margin = {top: 75, right: 75, bottom: 75, left: 75}, cus
//                 width = 1550 - margin.left - margin.right,
//                     height = 1550 - margin.top - margin.bottom;
//
//                 var x = d3.scale.ordinal().rangePoints([0, width], 1),
//                     y = {},
//                     dragging = {};
//
//                 var line = d3.svg.line(),
//                     axis = d3.svg.axis().orient("left"),
//                     background,
//                     foreground;
//
//
//                 svg = d3.select("#chart").append("svg")
//                     .attr("width", width + margin.left + margin.right)
//                     .attr("style", "outline: thin solid yellow;")
//                     .attr("height", height + margin.top + margin.bottom)
//                     .append("g")
//                     .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
//
//                 var margin = 75,
//                     w = 1550 - 2 * margin,
//                     h = w,
//                     radius = w / 2,
//                     strokeWidth = 4,
//                     hyp2 = Math.pow(radius, 2),
//                     nodeBaseRad = 5;
//
//                 var data = parallelLayout;
//
//
//                 x.domain(dimensions = d3.keys(data[0]).filter(function (d) {
//
//                     if (d === "name") return false;
//
//                     else {
//                         y[d] = d3.scale.ordinal()
//                             .domain(data.map(function (p) {
//                                 return p[d];
//                             }))
//                             .rangePoints([height, 0]);
//
//                     }
//                     //else {
//                     //    y[d] = d3.scale.linear()
//                     //      .domain(d3.extent(data, function(p) { return +p[d]; }))
//                     //      .range([h, 0]);
//                     //}
//
//                     return true;
//                 }));
//
//                 background = svg.append("g")
//                     .style("fill", "none")
//                     .style("stroke", "#ddd")
//                     .style("shape-rendering", "crispEdges")
//
//                     .selectAll("path")
//                     .data(data)
//                     .enter().append("path")
//                     .attr("d", path);
//
//                 // Add blue foreground lines for focus.
//                 foreground = svg.append("g")
//                     .style("fill", "none")
//                     .style("stroke", "steelblue")
//                     //.style("shape-rendering", "crispEdges")
//                     .selectAll("path")
//                     .data(data)
//                     .enter().append("path")
//                     .attr("d", path);
//
// // Add a group element for each dimension.
//                 var g = svg.selectAll(".dimension")
//                     .data(dimensions)
//                     .enter().append("g")
//                     .attr("class", "dimension")
//                     .attr("transform", function (d) {
//                         return "translate(" + x(d) + ")";
//                     })
//                     .call(d3.behavior.drag()
//                         .origin(function (d) {
//                             return {x: x(d)};
//                         })
//                         .on("dragstart", function (d) {
//                             dragging[d] = x(d);
//                             background.attr("visibility", "hidden");
//                         })
//                         .on("drag", function (d) {
//                             dragging[d] = Math.min(width, Math.max(0, d3.event.x));
//                             foreground.attr("d", path);
//                             dimensions.sort(function (a, b) {
//                                 return position(a) - position(b);
//                             });
//                             x.domain(dimensions);
//                             g.attr("transform", function (d) {
//                                 return "translate(" + position(d) + ")";
//                             })
//                         })
//                         .on("dragend", function (d) {
//                             delete dragging[d];
//                             transition(d3.select(this)).attr("transform", "translate(" + x(d) + ")");
//                             transition(foreground).attr("d", path);
//                             background
//                                 .attr("d", path)
//                                 .transition()
//                                 .delay(500)
//                                 .duration(0)
//                                 .attr("visibility", null);
//                         }));
//
//                 // Add an axis and title.
//                 g.append("g")
//                     .style("fill", "none")
//                     .style("stroke", "black")
//                     //.style("stroke-width","#000")
//                     //.style("fill", "none")
//                     .style("stroke-width", "1")
//                     .style("shape-rendering", "crispEdges")
//                     //.style("shape-rendering","crispEdges")
//                     // fill: none;
//                     // stroke: #000;
//                     // shape-rendering: crispEdges;
//                     //.attr("class", "axis")
//                     .each(function (d) {
//                         d3.select(this).call(axis.scale(y[d]));
//                     })
//                     .append("text")
//                     .style("font", "13px Times New Roman")
//                     .style("text-anchor", "middle")
//                     .attr("y", -9)
//                     .text(function (d) {
//                         return d;
//                     });
//
//                 // Add and store a brush for each axis.
//                 g.append("g")
//
//                 // fill-opacity: .3;
//                 // stroke: #fff;
//                 // shape-rendering: crispEdges;
//                 //.attr("class", "brush")
//                     .each(function (d) {
//                         d3.select(this).call(y[d].brush = d3.svg.brush().y(y[d]).on("brushstart", brushstart).on("brush", brush));
//                     })
//                     .selectAll("rect")
//                     .attr("x", -8)
//                     .style("fill-opacity", ".3")
//                     .style("stroke", "#fff")
//                     .style("shape-rendering", "crispEdges")
//                     .attr("width", 16);
//
// //Added from here========================================
//
//
//                 var projection = svg.selectAll(".foreground path")
//                     .on("mouseover", mouseover)
//                     .on("mouseout", mouseout);
//
//                 function mouseover(d) {
//                     //svg.classed("active", false);
//                     projection.classed("inactive", function (p) {
//                         return p !== d;
//                     });
//                     projection.classed("active", function (p) {
//                         return p === d;
//                     });
//                     //projection.filter(function(p) { return p === d; }).each(moveToFront);
//                 }
//
//                 function mouseout(d) {
//
//                     //projection.classed("inactive", function(p) { return p !== d; });
//                     projection.classed("active");
//
//                 }
//
//                 function position(d) {
//                     var v = dragging[d];
//                     return v == null ? x(d) : v;
//                 }
//
//                 function transition(g) {
//                     return g.transition().duration(500);
//                 }
//
//                 function path(d) {
//                     return line(dimensions.map(function (p) {
//                         return [position(p), y[p](d[p])];
//                     }));
//                 }
//
//                 function brushstart() {
//                     d3.event.sourceEvent.stopPropagation();
//                 }
//
// // Handles a brush event, toggling the display of foreground lines.
//                 function brush() {
//                     var actives = dimensions.filter(function (p) {
//                             return !y[p].brush.empty();
//                         }),
//                         extents = actives.map(function (p) {
//                             return y[p].brush.extent();
//                         });
//                     foreground.style("display", function (d) {
//                         return actives.every(function (p, i) {
//
//                             return extents[i][0] <= y[p](d[p]) && y[p](d[p]) <= extents[i][1];
// //This one is for numeric
//                             //return extents[i][0] <= d[p] && d[p] <= extents[i][1];
//                         }) ? null : "none";
//                     });
//                 }
//
//
//             });
//
//             d3.select('#customizedCircularView1').on('click', function () {
//
//                 svg.remove();
//                 var diameter = 1200;
//                 svg = d3.select("#chart").append("svg")
//                     .attr("width", diameter)
//                     .attr("height", diameter)
//                     .attr("style", "outline: thin solid yellow;")
//                     .append("g")
//                     .attr("transform", "translate(" + diameter / 2 + "," + diameter / 2 + ")");
//
//                 var outer = d3.map();
//                 var inner = [];
//                 var links = [];
//                 var outerId = [0];
//                 var data = circularLayout;
//                 //console.log(data);
//                 data.forEach(function (d) {
//
//                     if (d == null)
//                         return;
//
//                     i = {id: 'i' + inner.length, name: d[0], related_links: []};
//                     i.related_nodes = [i.id];
//                     inner.push(i);
//
//                     if (!Array.isArray(d[1]))
//                         d[1] = [d[1]];
//
//                     d[1].forEach(function (d1) {
//
//                         o = outer.get(d1);
//
//                         if (o == null) {
//                             o = {name: d1, id: 'o' + outerId[0], related_links: []};
//                             o.related_nodes = [o.id];
//                             outerId[0] = outerId[0] + 1;
//
//                             outer.set(d1, o);
//                         }
//
//                         // create the links
//                         l = {id: 'l-' + i.id + '-' + o.id, inner: i, outer: o}
//                         links.push(l);
//
//                         // and the relationships
//                         i.related_nodes.push(o.id);
//                         i.related_links.push(l.id);
//                         o.related_nodes.push(i.id);
//                         o.related_links.push(l.id);
//                     });
//                 });
//                 data = {
//                     inner: inner,
//                     outer: outer.values(),
//                     links: links
//                 }
// // sort the data -- TODO: have multiple sort options
//                 outer = data.outer;
//                 data.outer = Array(outer.length);
//                 var i1 = 0;
//                 var i2 = outer.length - 1;
//                 for (var i = 0; i < data.outer.length; ++i) {
//                     if (i % 2 == 1)
//                         data.outer[i2--] = outer[i];
//                     else
//                         data.outer[i1++] = outer[i];
//                 }
//                 //console.log(data.outer.reduce(function (a, b) {
//                         return a + b.related_links.length;
//                     }, 0) / data.outer.length);
// // from d3 colorbrewer:
// // This product includes color specifications and designs developed by Cynthia Brewer (http://colorbrewer.org/).
//                 //var colors = ["#a50026","#d73027","#f46d43","#fdae61","#fee090","#ffffbf","#e0f3f8","#abd9e9","#74add1","#4575b4","#313695"]
//                 // var color = d3.scale.linear()
//                 //     .domain([60, 220])
//                 //     .range([colors.length-1, 0])
//                 //     .clamp(true);
//
//
//                 var rect_width = 100;
//                 var rect_height = 20;
//                 var link_width = "1px";
//                 var il = data.inner.length;
//                 var ol = data.outer.length;
//                 var inner_y = d3.scale.linear()
//                     .domain([0, il])
//                     .range([-(il * rect_height) / 2, (il * rect_height) / 2]);
//                 mid = (data.outer.length / 2.0)
//                 var outer_x = d3.scale.linear()
//                     .domain([0, mid, mid, data.outer.length])
//                     .range([15, 170, 190, 355]);
//                 var outer_y = d3.scale.linear()
//                     .domain([0, data.outer.length])
//                     .range([0, diameter / 2 - 150]);
// // setup positioning
//                 data.outer = data.outer.map(function (d, i) {
//                     d.x = outer_x(i);
//                     d.y = diameter / 3;
//                     return d;
//                 });
//                 data.inner = data.inner.map(function (d, i) {
//                     d.x = -(rect_width / 2);
//                     d.y = inner_y(i);
//                     return d;
//                 });
//                 function get_color(name) {
//                     // var c = Math.round(color(name));
//                     // if (isNaN(c))
//                     //     return '#dddddd';	// fallback color
//                     //
//                     // return colors[c];
//
//
//                     return '#a39c9c';
//                 }
//
// // Can't just use d3.svg.diagonal because one edge is in normal space, the
// // other edge is in radial space. Since we can't just ask d3 to do projection
// // of a single point, do it ourselves the same way d3 would do it.
//                 function projectX(x) {
//                     return ((x - 90) / 180 * Math.PI) - (Math.PI / 2);
//                 }
//
//                 var diagonal = d3.svg.diagonal()
//                     .source(function (d) {
//                         return {
//                             "x": d.outer.y * Math.cos(projectX(d.outer.x)),
//                             "y": -d.outer.y * Math.sin(projectX(d.outer.x))
//                         };
//                     })
//                     .target(function (d) {
//                         return {
//                             "x": d.inner.y + rect_height / 2,
//                             "y": d.outer.x > 180 ? d.inner.x : d.inner.x + rect_width
//                         };
//                     })
//                     .projection(function (d) {
//                         return [d.y, d.x];
//                     });
//
//                 // svg = d3.select("#chart")
//                 //     .append("svg")
//                 //     .attr("style", "outline: thin solid yellow;")
//                 //     .attr("width", w)
//                 //     .attr("height", h);
//
//
// // links
//                 var link = svg.append('g')
//                 //.attr('class', 'links')
//                     .selectAll(".link")
//                     .data(data.links)
//                     .enter().append('path')
//                     .style('fill', 'none')
//                     .attr('id', function (d) {
//                         return d.id
//                     })
//                     .attr("d", diagonal)
//                     .attr('stroke', function (d) {
//                         return get_color(d.inner.name);
//                     })
//                     .attr('stroke-width', link_width);
// // outer nodes
//                 var onode = svg.append('g').selectAll(".outer_node")
//                     .data(data.outer)
//                     .enter().append("g")
//                     .style("stroke", "#315B7E")
//                     .style("stroke-width", "2px")
//
//                     // .attr("class", "outer_node")
//                     .attr("transform", function (d) {
//                         return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")";
//                     })
//                     .on("mouseover", mouseover)
//                     .on("mouseout", mouseout);
//
//                 onode.append("circle")
//                     .attr('id', function (d) {
//                         return d.id
//                     })
//                     .attr("r", 4.5);
//
//                 onode.append("circle")
//                     .attr('r', 20)
//                     .attr('visibility', 'hidden');
//
//                 onode.append("text")
//                     .attr('id', function (d) {
//                         return d.id + '-txt';
//                     })
//                     .attr("dy", ".31em")
//                     .style("stroke", "black")
//                     .style("font-weight", "normal")
//                     .style("font", "13px Times New Roman")
//                     .attr("text-anchor", function (d) {
//                         return d.x < 180 ? "start" : "end";
//                     })
//                     .attr("transform", function (d) {
//                         return d.x < 180 ? "translate(8)" : "rotate(180)translate(-8)";
//                     })
//                     .text(function (d) {
//                         return d.name;
//                     });
//
// // inner nodes
//
//                 var inode = svg.append('g').selectAll(".inner_node")
//                     .data(data.inner)
//                     .enter().append("g")
//                     .style("stroke", "#315B7E")
//                     .style("stroke-width", "2px")
//
//                     //.attr("class", "inner_node")
//                     .attr("transform", function (d, i) {
//                         return "translate(" + d.x + "," + d.y + ")"
//                     })
//                     .on("mouseover", mouseover)
//                     .on("mouseout", mouseout);
//
//                 inode.append('rect')
//                     .attr('width', rect_width)
//                     .attr('height', rect_height)
//                     .attr('id', function (d) {
//                         return d.id;
//                     })
//                     .attr('fill', function (d) {
//                         return get_color(d.name);
//                     });
//
//                 inode.append("text")
//                     .attr('id', function (d) {
//                         return d.id + '-txt';
//                     })
//                     .attr('text-anchor', 'middle')
//                     .style("stroke", "#315B7E")
//                     .style("font-weight", "normal")
//                     .style("font", "13px Times New Roman")
//                     .attr("transform", "translate(" + rect_width / 2 + ", " + rect_height * .75 + ")")
//                     .text(function (d) {
//                         return d.name;
//                     });
// // need to specify x/y/etc
//                 d3.select(self.frameElement).style("height", diameter - 150 + "px");
//                 function mouseover(d) {
//                     // bring to front
//                     d3.selectAll('.links .link').sort(function (a, b) {
//                         return d.related_links.indexOf(a.id);
//                     });
//
//                     for (var i = 0; i < d.related_nodes.length; i++) {
//                         d3.select('#' + d.related_nodes[i]).classed('highlight', true);
//                         d3.select('#' + d.related_nodes[i] + '-txt').attr("font-weight", 'bold');
//                     }
//
//                     for (var i = 0; i < d.related_links.length; i++)
//                         d3.select('#' + d.related_links[i]).attr('stroke-width', '5px');
//                 }
//
//                 function mouseout(d) {
//                     for (var i = 0; i < d.related_nodes.length; i++) {
//                         d3.select('#' + d.related_nodes[i]).classed('highlight', false);
//                         d3.select('#' + d.related_nodes[i] + '-txt').attr("font-weight", 'normal');
//                     }
//
//                     for (var i = 0; i < d.related_links.length; i++)
//                         d3.select('#' + d.related_links[i]).attr('stroke-width', link_width);
//                 }
//
//             });
                // Set-up the export button
                d3.select('#download-png6').on('click', function () {
                    var svgString = getSVGString(svg6.node());

                    svgString2Image(svgString, 4 * globalW, 4 * globalHPlus50, 'png', save); // passes Blob and filesize String to the callback

                    function save(dataBlob, filesize) {
                        saveAs(dataBlob, 'Pinet-SIGNOR-Graph.png'); // FileSaver.js function
                    }
                });
                d3.select('#saveButton').on('click', function () {
                    var svgString = getSVGString(svg6.node());

                    svgString2Image(svgString, 4 * 1550, 4 * 1550, 'png', save); // passes Blob and filesize String to the callback

                    function save(dataBlob, filesize) {
                        saveAs(dataBlob, 'PiNET-SIGNOR-Graph.png'); // FileSaver.js function
                    }
                });

// Below are the functions that handle actual exporting:
// getSVGString ( svgNode ) and svgString2Image( svgString, width, height, format, callback )
                function getSVGString(svgNode) {
                    svgNode.setAttribute('xlink', 'http://www.w3.org/1999/xlink');
                    var cssStyleText = getCSSStyles(svgNode);
                    appendCSS(cssStyleText, svgNode);

                    var serializer = new XMLSerializer();
                    var svgString = serializer.serializeToString(svgNode);
                    svgString = svgString.replace(/(\w+)?:?xlink=/g, 'xmlns:xlink='); // Fix root xlink without namespace
                    svgString = svgString.replace(/NS\d+:href/g, 'xlink:href'); // Safari NS namespace fix

                    return svgString;

                    function getCSSStyles(parentElement) {
                        var selectorTextArr = [];

                        // Add Parent element Id and Classes to the list
                        selectorTextArr.push('#' + parentElement.id);
                        for (var c = 0; c < parentElement.classList.length; c++)
                            if (!contains('.' + parentElement.classList[c], selectorTextArr))
                                selectorTextArr.push('.' + parentElement.classList[c]);

                        // Add Children element Ids and Classes to the list
                        var nodes = parentElement.getElementsByTagName("*");
                        for (var i = 0; i < nodes.length; i++) {
                            var id = nodes[i].id;
                            if (!contains('#' + id, selectorTextArr))
                                selectorTextArr.push('#' + id);

                            var classes = nodes[i].classList;
                            for (var c = 0; c < classes.length; c++)
                                if (!contains('.' + classes[c], selectorTextArr))
                                    selectorTextArr.push('.' + classes[c]);
                        }

                        // Extract CSS Rules
                        var extractedCSSText = "";
                        for (var i = 0; i < document.styleSheets.length; i++) {
                            var s = document.styleSheets[i];

                            try {
                                if (!s.cssRules) continue;
                            } catch (e) {
                                if (e.name !== 'SecurityError') throw e; // for Firefox
                                continue;
                            }

                            var cssRules = s.cssRules;
                            for (var r = 0; r < cssRules.length; r++) {
                                if (contains(cssRules[r].selectorText, selectorTextArr))
                                    extractedCSSText += cssRules[r].cssText;
                            }
                        }


                        return extractedCSSText;

                        function contains(str, arr) {
                            return arr.indexOf(str) === -1 ? false : true;
                        }

                    }

                    function appendCSS(cssText, element) {
                        var styleElement = document.createElement("style");
                        styleElement.setAttribute("type", "text/css");
                        styleElement.innerHTML = cssText;
                        var refNode = element.hasChildNodes() ? element.children[0] : null;
                        element.insertBefore(styleElement, refNode);
                    }
                }


                function svgString2Image(svgString, width, height, format, callback) {
                    var format = format ? format : 'png';

                    var imgsrc = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgString))); // Convert SVG string to data URL

                    var canvas = document.createElement("canvas");
                    var context = canvas.getContext("2d");

                    canvas.width = width;
                    canvas.height = height;

                    var image = new Image();
                    image.onload = function () {
                        context.clearRect(0, 0, width, height);
                        context.drawImage(image, 0, 0, width, height);

                        canvas.toBlob(function (blob) {
                            var filesize = Math.round(blob.length / 1024) + ' KB';
                            if (callback) callback(blob, filesize);
                        });


                    };

                    image.src = imgsrc;
                }


                // d3.select("#download").on("click", function(){
                //     var html = d3.select("svg")
                //         .attr("version", 1.1)
                //         .attr("xmlns", "http://www.w3.org/2000/svg")
                //         .node().parentNode.innerHTML;
                //
                //     ////console.log(html);
                //     var imgsrc = 'data:image/svg+xml;base64,'+ btoa(html);
                //     var img = '<img src="'+imgsrc+'">';
                //     d3.select("#svgdataurl").html(img);
                //
                //
                //     var canvas = document.querySelector("canvas"),
                //         context = canvas.getContext("2d");
                //
                //     var image = new Image;
                //     image.src = imgsrc;
                //     image.onload = function() {
                //         context.drawImage(image, 0, 0);
                //
                //         var canvasdata = canvas.toDataURL("image/png");
                //
                //         var pngimg = '<img src="'+canvasdata+'">';
                //         d3.select("#pngdataurl").html(pngimg);
                //
                //         var a = document.createElement("a");
                //         a.download = "sample.png";
                //         a.href = canvasdata;
                //         a.click();
                //     };
                //
                // });


            }


            // //console.log(network.parallel);
            // //console.log(network.circular);
            // update(network.nodes, network.edges, network.parallel, network.circular);
            //console.log(network.nodes);
            //console.log(ptmToAbundance);
            for (var iterNetNode = 0; iterNetNode < network.nodes.length; iterNetNode++) {
                var iterNetNodeKey = network.nodes[iterNetNode]["name"];
                if (iterNetNodeKey in ptmToAbundance) {
                    //console.log(iterNetNodeKey);
                    if (ptmToAbundance[iterNetNodeKey] == "NA") {
                        network.nodes[iterNetNode]["value"] = 0.0;
                    }
                    else {
                        network.nodes[iterNetNode]["value"] = ptmToAbundance[iterNetNodeKey];
                    }
                }
            }
            //console.log(self.computeWeightForupdateSignor);
            if (self.computeWeightForUpdateSignor) {
                //console.log("---  inside computeWeightForUpdateSignor");
                for (var iterNetNode = 0; iterNetNode < network.edges.length; iterNetNode++) {
                    //var iterNetNodeKey = network.nodes[iterNetNode]["name"];
                    var idx1 = network.edges[iterNetNode]["source"];
                    var idx2 = network.edges[iterNetNode]["target"];
                    network.nodes[idx1]["weight"] += 1;
                    network.nodes[idx2]["weight"] += 1;

                }
                self.computeWeightForUpdateSignor = false;
                SharedService.setVar('computeWeightForUpdateSignor', self.computeWeightForUpdateSignor);
            }
            //console.log(network);
            updateSignor(network.nodes, network.edges, graphType, circleSliderValue, nodeSliderValue, fontSliderValue, widthSliderValue);


            self.showSignorGraph = true;
        }
        // else {
        //     //self.showPtmGraphTmp = false;
        //     self.showSignorGraph = true;
        // }
    }





    //
    // $( document ).ready(function() {
    //
    //     function createHoverState (myobject){
    //         myobject.hover(function() {
    //             $(this).prev().toggleClass('hilite');
    //         });
    //         myobject.mousedown(function() {
    //             $(this).prev().addClass('dragging');
    //             $("*").mouseup(function() {
    //                 $(myobject).prev().removeClass('dragging');
    //             });
    //         });
    //     }
    //
    //     $(".slider").slider({
    //         orientation: "horizontal",
    //         range: "min",
    //         max: 100,
    //         value: 0,
    //         animate: 1300
    //     });
    //     $("#blue").slider( "value", 100 );
    //     $('.slider').each(function(index) {
    //         $(this).slider( "value", 75-index*(50/($('.slider').length-1)));
    //     });
    //
    //     createHoverState($(".slider a.ui-slider-handle"));
    //
    // });



    $scope.graphType4deep = 1;
    $scope.circleSliderValue4deep = 1100;
    $scope.nodeSliderValue4deep = 15;
    $scope.fontSliderValue4deep = 14;
    $scope.widthSliderValue4deep = 1500;
    $(document).on('input', '#circle_slider4deep', function() {
        $('#circle_slider_value4deep').html( $(this).val() );
        ////console.log($(this).val());
        $scope.circleSliderValue4deep = $(this).val();

        $scope.$apply();
        $scope.makeDeepPhosGraph(self.deepPhosNetwork, self.ptmProteinToAbundanceMap, $scope.graphType4deep, $scope.circleSliderValue4deep, $scope.nodeSliderValue4deep, $scope.fontSliderValue4deep, $scope.widthSliderValue4deep);

    });

    $(document).on('input', '#node_slider4deep', function() {
        $('#node_slider_value4deep').html( $(this).val() );
        ////console.log($(this).val());
        $scope.nodeSliderValue4deep = $(this).val();

        $scope.$apply();

        $scope.makeDeepPhosGraph(self.deepPhosNetwork, self.ptmProteinToAbundanceMap, $scope.graphType4deep, $scope.circleSliderValue4deep, $scope.nodeSliderValue4deep, $scope.fontSliderValue4deep, $scope.widthSliderValue4deep);

    });

    $(document).on('input', '#font_slider4deep', function() {
        $('#font_slider_value4deep').html( $(this).val() );
        ////console.log($(this).val());
        $scope.fontSliderValue4deep = $(this).val();

        $scope.$apply();

        $scope.makeDeepPhosGraph(self.deepPhosNetwork, self.ptmProteinToAbundanceMap, $scope.graphType4deep, $scope.circleSliderValue4deep, $scope.nodeSliderValue4deep, $scope.fontSliderValue4deep, $scope.widthSliderValue4deep);

    });

    $(document).on('input', '#width_slider4deep', function() {
        $('#width_slider_value4deep').html( $(this).val() );
        ////console.log($(this).val());
        $scope.widthSliderValue4deep = $(this).val();

        $scope.$apply();

        $scope.makeDeepPhosGraph(self.deepPhosNetwork, self.ptmProteinToAbundanceMap, $scope.graphType4deep, $scope.circleSliderValue4deep, $scope.nodeSliderValue4deep, $scope.fontSliderValue4deep, $scope.widthSliderValue4deep);

    });




    $scope.hideDeepPhosGraph = function () {
        self.showDeepPhosGraphTmp = true;
        self.showDeepPhosGraph = false;
    }
    $scope.makeDeepPhosGraph = function (network, ptmToAbundance, graphType, circleSliderValue, nodeSliderValue, fontSliderValue, widthSliderValue) {
        // console.log("inside makeDeepPhosGraph");
        // console.log(graphType);
        console.log(self.showDeepPhosGraphTmp);
        console.log(self.showDeepPhosGraph);
        if(self.showDeepPhosGraphTmp)
        {
            self.showDeepPhosGraphTmp = false;
            self.showDeepPhosGraph = true;
        }
        else {
//console.log("inside deepPhosGraph");
            self.showDeepPhosGraphTmp = true;
            self.showDeepPhosGraph = false;
            d3.select("#chart4deep").select("svg").remove();
            if (typeof svg4deep === 'undefined') {
                var svg4deep = d3.selectAll("#chart4deep").append("svg");
            }
            //var svg4 = d3.selectAll("#chart4").append("svg");


            var force;
            var colNodeScaleSeparate = d3.scale.ordinal()
                .range(["#987024", "#ed0909", "#0af702", "#d506d8"])
                //.range(["#987024", "#982482", "#0af702"])
                .domain([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);
//#f9a3f5
            // var colNodeScaleSeparate = d3.scale.ordinal()
            //     .range(["#767776", "#f91104", "#0af702"])
            //     .domain([0,1,2]);

            // var colNodeScale = d3.scale.linear().range(["#987024", "#ed0909"]);
            // var colScale = d3.scale.linear().range(["#987024", "#ed0909"]);

            var colScale = d3.scale.ordinal()
                .range(["#987024", "#ed0909", "#0af702", "#d506d8"])
                //.range(["#987024", "#982482", "#0af702"])
                .domain([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);

            var colNodeScale = d3.scale.ordinal()
                .range(["#987024", "#ed0909", "#0af702", "#d506d8"])
                //.range(["#987024", "#982482", "#0af702"])
                .domain([1, 2, 3, 4]);
            var edgeWeightScale = d3.scale.linear().range([1, 3]);

            var xScale = d3.scale.linear().range([nodeSliderValue/3.0, nodeSliderValue]);
            //var xScale = d3.scale.linear().range([5, 15]);
            var scoreScale = d3.scale.linear().range([2, 5]);
            var textPlacePlusMinus = d3.scale.ordinal()
                .range([18, -18, -18, -18, -18, -18, -18, -18, -18, -18, -18, -18])
                .domain([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);
            var textPlaceStartEnd = d3.scale.ordinal().range(["start", "end", "end", "end", "end", "end", "end", "end", "end", "end", "end", "end"])
                .domain([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);

            var colorsForAbundance = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
            var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];
            var colorScale = d3.scale.threshold()
                .domain(domain_data)
                .range(colorsForAbundance);


            function updateDeepPhos(nodes, links, graphType, circleValue, nodeValue, fontValue, widthValue) {

                console.log("inside updateDeepPhos");
                circleValue = Math.min(circleValue, widthValue - 300);
                // console.log(graphType);
                // console.log(circleValue);
                // console.log(nodeValue);
                // console.log(fontValue);
                // console.log(widthValue);

                function circularView4deep(){
                    svg4deep.remove();
                    console.log("inside circularView4deep");
                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    scoreScale.domain(d3.extent(links, function (d) {
                        return d.score;
                    }));
                    colNodeScale.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));
                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = w,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;


                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;


                    svg4deep = d3.select("#chart4deep")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);
                    svg4deep.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");


                    // This is for grouping nodes


                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h]);

// evenly spaces nodes along arc
                    var circleCoord = function (node, index, num_nodes) {
                        var circumference = circle.node().getTotalLength();
                        var pointAtLength = function (l) {
                            return circle.node().getPointAtLength(l)
                        };
                        var sectionLength = (circumference) / num_nodes;
                        var position = sectionLength * index + sectionLength / 2;
                        return pointAtLength(circumference - position)
                    }

                    var is_connected = function (d, opacity) {
                        lines.transition().style("stroke-opacity", function (o) {
                            return o.source === d || o.target === d ? 1 : opacity;
                        });
                    }


                    var dim = w - (widthValue - circleValue);
                    var circle = svg4deep.append("path")
                        .attr("d", "M " + String((widthValue - circleValue)/2) + ", " + (dim / 2 + (widthValue - circleValue)/2) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                        .style("fill", "white");

                    force.start();

                    nodes.forEach(function (n, i) {
                        var coord = circleCoord(n, i, nodes.length)
                        n.x = coord.x
                        n.y = coord.y
                    });


                    // use this one for straight line links...
                    // var lines = svg.selectAll("line.node-link")
                    //     .data(links).enter().append("line")
                    //     .attr("class", "node-link")
                    //     .attr("x1", function(d) { return d.source.x; })
                    //     .attr("y1", function(d) { return d.source.y; })
                    //     .attr("x2", function(d) { return d.target.x; })
                    //     .attr("y2", function(d) { return d.target.y; });

                    var lines = svg4deep.selectAll("path.node-link")
                        .data(links).enter().append("path")
                        .style("fill", "none")
                        .style("stroke", "#726363")
                        .attr("class", "node-link")
                        .style("stroke-width", function (d) {return d.score*2; })
                        .attr("d", function (d) {
                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,
                                dr = Math.sqrt(dx * dx + dy * dy);
                            return "M" +
                                d.source.x + "," +
                                d.source.y + "," +
                                d.target.x + "," +
                                d.target.y;

                        });


                    var gnodes = svg4deep.selectAll('g.gnode')
                        .data(nodes).enter().append('g')
                        .attr("transform", function (d) {
                            return "translate(" + d.x + "," + d.y + ")"
                        })
                        .classed('gnode', true);


                    // node.append("circle")
                    //     .attr("r", function (d) { return xScale(d.weight); })
                    //     .style("fill", function(d) { return colNodeScale(d.group); });

                    var node = gnodes.append("circle")
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        .style("fill", function (d) {
                            if (d.group == 0) {
                                return colorScale(d.value);
                            }
                            else {

                                if (d.group == 1) {
                                    return("#ed0909");
                                }
                                if (d.group == 2) {
                                    return("#0af702");
                                }
                                if (d.group == 3) {
                                    return("#FF00FF");
                                }
                                if (d.group == 4) {
                                    return("#808000");
                                }
                                if (d.group == 5) {
                                    return("#000080");
                                }
                                if (d.group == 6) {
                                    return("#800080");
                                }
                                if (d.group == 7) {
                                    return("#00ffff");
                                }
                                if (d.group == 8) {
                                    return("#F5F5DC");
                                }
                                if (d.group == 9) {
                                    return("#A52A2A");
                                }
                                if (d.group == 10) {
                                    return("#8B0000");
                                }
                                if (d.group == 11) {
                                    return("#FF8C00");
                                }

                            }
                            //return colNodeScale(d.group);
                        })
                        // .style("fill", function (d) {
                        //     return colNodeScale(d.group);
                        // })
                        .style("stroke", "#333")
                        .style("stroke-width", "2px")
                        .style("stroke-dasharray",
                            function (d) {
                                if (d.connected == "No") {
                                    ////console.log("not connected");
                                    return (5, 5);

                                }
                                else if(d.connected == "Yes") {
                                    ////console.log("connected");
                                    return (3, 0);
                                }
                            })

                        //.attr("class", "node")
                        .on("mouseenter", function (d) {
                            is_connected(d, 0.1)
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            d3.select(this).transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight + 3);
                            })
                        })
                        .on("mouseleave", function (d) {
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            is_connected(d, 1);
                        })
                        .call(force.drag);

                    var labels = gnodes.append("text")
                        .attr("dx", 4)
                        .attr("dy", 4)

                        .style("font", String(fontValue) + "px Arial")
                        .attr("text-anchor", function (d) {
                            return d.x < w / 2 ? "end" : "start";
                        })
                        .attr("transform", function (d) {
                            return d.x < w / 2 ? "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(-20)" : "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(20)";
                        })
                        //.attr("transform", function(d) { return  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")"})
                        //.attr("transform", function(d) { return (d.x-w/2)/(d.y-w/2) < 0 ?  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")" : "rotate(180)"; })
                        .text(function (d) {
                            return d.name
                        })

                    var drag = force.drag()
                        .on("dragstart", dragstart);
                    //.on("dragstart", dragstartAll);


                    //For not moving after drag
                    function dragstart(d) {
                        d3.select(this).classed("fixed", d.fixed = true);

                        for (i = 0; i < nodes.length; i++) {
                            nodes[i].fixed = true;
                        }
                    }


                    var svgText = svg4deep.append("text");
                    svgText.attr("x",10).attr("y",globalHPlus50-50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);




                    var legend2 = svg4deep.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());
                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg4deep.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg4deep.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg4deep.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();





                };

                function parallelView4deep() {
                    svg4deep.remove();
                    console.log("inside parallelView4deep");

                    //xPosition.domain(d3.extent(nodes, function (d) { return d.text; }));
                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    colNodeScale.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));
                    textPlacePlusMinus.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    textPlaceStartEnd.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    scoreScale.domain(d3.extent(links, function (d) {
                        return d.score;
                    }));
                    n1 = 0;
                    n2 = 0;

                    nodes.forEach(function (n, i) {


                        if (n.group == 0) {

                            n1 = n1 + 1;
                        }
                        else {

                            n2 = n2 + 1;
                        }

                    });


                    var totalN1 = n1;
                    var totalN2 = n2;
                    //console.log(n1);
                    //console.log(n1 * 12);
                    //console.log(n2);
                    //console.log(n2 * 12);
                    var parallelH = Math.max(n1 * 12, n2 * 12, 500);
                    //var parallelH = Math.max(n1 * 12, n2 * 12);

                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = parallelH,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;

                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;


                    svg4deep = d3.select("#chart4deep")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);

                    svg4deep.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");


                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h]);


                    var parallelCoordx = function (group) {

                        if (group == 0) {
                            return w * 1.5 / 3.0;
                        }
                        else {
                            return w / 3.0;
                        }
                    }

                    var parallelCoordy = function (index, num_nodes) {
                        var dist = h / (num_nodes + 1);

                        return (index + 1) * dist;
                    }

                    var is_connected = function (d, opacity) {
                        lines.transition().style("stroke-opacity", function (o) {
                            return o.source === d || o.target === d ? 1 : opacity;
                        });
                    }

                    //var dim = w-80
                    // var circle = svg.append("path")
                    //     .attr("d", "M 40, "+(dim/2+40)+" a "+dim/2+","+dim/2+" 0 1,0 "+dim+",0 a "+dim/2+","+dim/2+" 0 1,0 "+dim*-1+",0")
                    //     .style("fill", "#f5f5f5");

                    force.start();


                    // //console.log(nodes.length);
                    var groupId = [];
                    var maxId = 0;
                    for (var i = 0; i < nodes.length; i++) {
                        var item = nodes[i];

                        if (!groupId[item.group]) {
                            groupId[item.group] = [];
                        }

                        groupId[item.group].push({name: item.name});
                        // //console.log(item.group);
                        // //console.log(groupId[item.group]);
                        if (maxId < item.group) {
                            maxId = item.group;
                        }
                    }
                    // //console.log(maxId);
                    // //console.log(groupId[1].length);
                    // //console.log(groupId[2].length);

                    n1 = 0;
                    n2 = 0;

                    nodes.forEach(function (n, i) {
                        var item = nodes[i];

                        if (n.group == 0) {
                            n.x = parallelCoordx(n.group)
                            n.y = parallelCoordy(n1, totalN1)
                            n1 = n1 + 1;
                        }
                        else {
                            n.x = parallelCoordx(n.group)
                            n.y = parallelCoordy(n2, totalN2)
                            n2 = n2 + 1;
                        }
                        // n.weight = links.filter(function (l) {
                        //     return l.source.index == n.index || l.target.index == n.index
                        // }).size();

                    });


                    // use this one for straight line links...
                    // var lines = svg.selectAll("line.node-link")
                    //   .data(links).enter().append("line")
                    //     .attr("class", "node-link")
                    //   .attr("x1", function(d) { return d.source.x; })
                    //   .attr("y1", function(d) { return d.source.y; })
                    //   .attr("x2", function(d) { return d.target.x; })
                    //   .attr("y2", function(d) { return d.target.y; });

                    var lines = svg4deep.selectAll("path.node-link")
                        .data(links).enter().append("path")
                        .style("fill", "none")
                        .style("stroke", "#726363")
                        .attr("class", "node-link")
                        .style("stroke-width", function (d) {return d.score*2; })
                        .attr("d", function (d) {
                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,
                                dr = Math.sqrt(dx * dx + dy * dy);
                            return "M" +
                                d.source.x + "," +
                                d.source.y + "," +
                                d.target.x + "," +
                                d.target.y;
                        });


                    // nodes.weight = lines.filter(function(l) {
                    //     return l.source.index == d.index || l.target.index == d.index
                    // }).size();

                    // var lines = svg.selectAll("path.node-link")
                    //     .data(links).enter().append("path")
                    //     .style("fill", "none")
                    //     .style("stroke", "black")
                    //     .attr("class", "node-link")
                    //     .attr("d", function(d) {
                    //         var dx = d.target.x - d.source.x,
                    //             dy = d.target.y - d.source.y,
                    //             dr = Math.sqrt(dx * dx + dy * dy);
                    //         return "M" +
                    //             d.source.x + "," +
                    //             d.source.y + "A" +
                    //             dr + "," + dr + " 0 0,1 " +
                    //             d.target.x + "," +
                    //             d.target.y;
                    //     });

                    var gnodes = svg4deep.selectAll('g.gnode')
                        .data(nodes).enter().append('g')
                        .attr("transform", function (d) {
                            return "translate(" + d.x + "," + d.y + ")"
                        })
                        .classed('gnode', true);

                    // gnodes.forEach(function (n, i) {
                    //     n.weight = lines.filter(function (l) {
                    //         return l.source.idx == n.idx || l.target.idx == n.idx
                    //     }).size();
                    //
                    // });
                    var node = gnodes.append("circle")
                    //.attr("r", function(d) {
                    // d.sizes = lines.filter(function(l) {
                    //     return l.source.index == d.index || l.target.index == d.index
                    // }).size();
                    // var minRadius = 5;
                    // return minRadius + (d.sizes * 2);
                    //     return colorScale(d.weight);
                    // })
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        .style("fill", function (d) {
                            if (d.group == 0) {
                                return colorScale(d.value);
                            }
                            else {
                                if (d.group == 1) {
                                    return("#ed0909");
                                }
                                if (d.group == 2) {
                                    return("#0af702");
                                }
                                if (d.group == 3) {
                                    return("#FF00FF");
                                }
                                if (d.group == 4) {
                                    return("#808000");
                                }
                                if (d.group == 5) {
                                    return("#000080");
                                }
                                if (d.group == 6) {
                                    return("#800080");
                                }
                                if (d.group == 7) {
                                    return("#00ffff");
                                }
                                if (d.group == 8) {
                                    return("#F5F5DC");
                                }
                                if (d.group == 9) {
                                    return("#A52A2A");
                                }
                                if (d.group == 10) {
                                    return("#8B0000");
                                }
                                if (d.group == 11) {
                                    return("#FF8C00");
                                }
                            }
                            //return colNodeScale(d.group);
                        })
                        // .style("fill", function (d) {
                        //     return colNodeScale(d.group);
                        // })
                        .style("stroke", "#333")
                        .style("stroke-width", "2px")
                        .style("stroke-dasharray",
                            function (d) {
                                if (d.connected == "No") {
                                    ////console.log("not connected");
                                    return (5, 5);

                                }
                                else if(d.connected == "Yes") {
                                    ////console.log("connected");
                                    return (3, 0);
                                }
                            })
                        //.attr("class", "node")
                        .on("mouseenter", function (d) {
                            is_connected(d, 0.1)
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            d3.select(this).transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight + 3);
                            })
                        })
                        .on("mouseleave", function (d) {
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            is_connected(d, 1);
                        })
                        .call(force.drag);
                    // var bbox = textElement.getBBox();
                    // var width = bbox.width;
                    // var height = bbox.height;
                    var labels = gnodes.append("text")
                        .style("font", String(fontValue) + "px Arial")
                        //.style("font", "14px Times New Roman")
                        .attr("dx", function (d) {
                            return textPlacePlusMinus(d.group);
                        })
                        .attr("dy", 4)
                        .attr("text-anchor", function (d) {
                            return textPlaceStartEnd(d.group);
                        })
                        .text(function (d) {
                            return d.name
                        })

                    var svgText = svg4deep.append("text");
                    svgText.attr("x",10).attr("y",globalHPlus50-50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);




                    var legend2 = svg4deep.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());
                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg4deep.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg4deep.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg4deep.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();


                };

                function circosView4deep(){
                    svg4deep.remove();
                    console.log("inside circosView4deep");

                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    scoreScale.domain(d3.extent(links, function (d) {
                        return d.score;
                    }));

                    colNodeScale.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));
                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = w,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;


                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;

                    var first_click = false;


                    svg4deep = d3.select("#chart4deep")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);
                    svg4deep.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");


                    // This is for grouping nodes


                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h]);

// evenly spaces nodes along arc
                    var circleCoord = function (node, index, input_num_nodes, has_focus) {
                        //console.log("in circleCoord");

                        // console.log(node["name"]);
                        // console.log(index);
                        // String(node["name"]).valueOf() ==
                        var circumference = circle.node().getTotalLength();
                        var pointAtLength = function (l) {
                            return circle.node().getPointAtLength(l)
                        };


                        if (has_focus){
                            var added_num = parseInt(input_num_nodes/4);
                            if (added_num%2 == 1){
                                added_num += 1;
                            }
                            var num_nodes = input_num_nodes + added_num;
                            var sectionLength = (circumference) / num_nodes;
                            if (String(node["name"]).valueOf() === $scope.interest){
                                var position = 0;
                                // console.log("in ATP");
                                // console.log(pointAtLength(circumference - position));
                                // console.log(position);
                            }
                            else {


                                var position = sectionLength * (index + added_num/2) + sectionLength / 2;
                            }
                        }
                        else{
                            var num_nodes = input_num_nodes;
                            var sectionLength = (circumference) / num_nodes;
                            var position = sectionLength * (index) + sectionLength / 2;

                        }

                        //console.log(pointAtLength(circumference - position));
                        return pointAtLength(circumference - position)
                    }

                    var is_connected = function (d, opacity) {
                        lines.transition().style("stroke-opacity", function (o) {
                            return o.source === d || o.target === d ? 1 : opacity;
                        });
                    }



                    // lines.transition().style("stroke-opacity", function (o) {
                    //     if (o.source === d || o.target === d){
                    //         return 1;
                    //     }
                    //
                    // });

                    var is_connected_on_click = function (d, opacity) {
                        //console.log(d);
                        lines.transition().style("stroke-opacity", function (o) {
                            return o.source.group === d.group || o.target.group === d.group ? 1 : opacity;
                        });
                    }

                    // var dim = w - 400
                    // var circle = svgGE.append("path")
                    //     .attr("d", "M 200, " + (dim / 2 + 200) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                    //     .style("fill", "white");

                    var dim = w - (widthValue - circleValue)
                    var circle = svg4deep.append("path")
                        .attr("d", "M " + String((widthValue - circleValue)/2) + ", " + (dim / 2 + (widthValue - circleValue)/2) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                        .style("fill", "white");

                    force.start();
                    var has_focus = false;
                    nodes.forEach(function (n, i) {
                        if (String(n["name"]).valueOf() == $scope.interest){
                            //if (String(n["name"]).valueOf() === $scope.interest) {
                            has_focus = true;
                        }

                    })

                    console.log(has_focus);
                    nodes.forEach(function (n, i) {
                        var coord = circleCoord(n, i, nodes.length, has_focus)
                        // console.log("calculating coor");
                        // console.log(coord);
                        // console.log(coord.x);
                        // console.log(coord.y);
                        n.x = coord.x
                        n.y = coord.y
                    });


                    // use this one for straight line links...
                    // var lines = svg.selectAll("line.node-link")
                    //     .data(links).enter().append("line")
                    //     .attr("class", "node-link")
                    //     .attr("x1", function(d) { return d.source.x; })
                    //     .attr("y1", function(d) { return d.source.y; })
                    //     .attr("x2", function(d) { return d.target.x; })
                    //     .attr("y2", function(d) { return d.target.y; });

                    var lines = svg4deep.selectAll("path.node-link")
                        .data(links).enter().append("path")
                        .style("fill", "none")
                        .style("stroke", function (d) {


                            if (d.tag == 0) {
                                return("#696969");
                            }

                            else if (d.tag == 1) {
                                return("#006400");
                            }
                            else if (d.tag == 2) {
                                return("#00FF00");
                            }
                            else if (d.tag == 3) {
                                return("#0000FF");
                            }
                            else if (d.tag == 4) {
                                return("#808080");
                            }
                            else if (d.tag == 5) {
                                return("#8B4513");
                            }
                            else if (d.tag == 6) {
                                return("#FFFFE0");
                            }
                            else if (d.tag == 7) {
                                return("#8464c5");
                            }
                            else if (d.tag == 8) {
                                return("#00FFFF");
                            }
                            else if (d.tag == 9) {
                                return("#FF7F50");
                            }
                            else if (d.tag == 10) {
                                return("#FF0000");
                            }
                            else if (d.tag == 11) {
                                return("#FF00FF");
                            }
                            else if (d.tag == 12) {
                                return("#8FBC8F");
                            }
                            else if (d.tag == 13) {
                                return("#A52A2A");
                            }
                            else if (d.tag == 14) {
                                return("#FFD700");
                            }
                            else if (d.tag == 15) {
                                return("#A0522D");
                            }
                            else if (d.tag == 16) {
                                return("#FFFF00");
                            }
                            else if (d.tag == 17) {
                                return("#6A5ACD");
                            }
                            else if (d.tag == 18) {
                                return("#708090");
                            }
                            else if (d.tag == 19) {
                                return("#FF6347");
                            }
                            else if (d.tag == 20) {
                                return("#CD5C5C");
                            }
                            else if (d.tag == 21) {
                                return("#DB7093");
                            }
                            else if (d.tag == 22) {
                                return("#2E8B57");
                            }
                            else if (d.tag == 23) {
                                return("#000080");
                            }
                            else if (d.tag == 24) {
                                return("#9370DB");
                            }
                            else if (d.tag == 25) {
                                return("#A52A2A");
                            }
                            else if (d.tag == 26) {
                                return("#FDF5E6");
                            }
                            else if (d.tag == 27) {
                                return("#7B68EE");
                            }
                            else if (d.tag == 28) {
                                return("#696969");
                            }
                            else if (d.tag == 29) {
                                return("#FF4500");
                            }
                            else if (d.tag == 30) {
                                return("#DC143C");
                            }
                            else if (d.tag == 31) {
                                return("#FF69B4");
                            }
                            else if (d.tag == 32) {
                                return("#006400");
                            }
                            else if (d.tag == 33) {
                                return("#87CEEB");
                            }
                            else if (d.tag == 34) {
                                return("#EE82EE");
                            }
                            else if (d.tag == 35) {
                                return("#800000");
                            }
                            else if (d.tag == 36) {
                                return("#FAEBD7");
                            }
                            else if (d.tag == 37) {
                                return("#4B0082");
                            }
                            else if (d.tag == 38) {
                                return("#808080");
                            }
                            else if (d.tag == 39) {
                                return("#FF8C00");
                            }
                            else if (d.tag == 40) {
                                return("#FA8072");
                            }
                            else if (d.tag == 41) {
                                return("#FFC0CB");
                            }
                            else if (d.tag == 42) {
                                return("#9ACD32");
                            }
                            else if (d.tag == 43) {
                                return("#4682B4");
                            }
                            else if (d.tag == 44) {
                                return("#DDA0DD");
                            }
                            else if (d.tag == 45) {
                                return("#CD853F");
                            }
                            else if (d.tag == 46) {
                                return("#FFE4E1");
                            }
                            else if (d.tag == 47) {
                                return("#696969");
                            }
                            else if (d.tag == 48) {
                                return("#A9A9A9");
                            }
                            else if (d.tag == 49) {
                                return("#FFA500");
                            }
                            else{
                                return("#000000");
                            }













                            // if (d.group == 0) {
                            //     return colorScale(d.value);
                            // }
                            // else {
                            //
                            //     if (d.group == 1) {
                            //         return("#ed0909");
                            //     }
                            //     if (d.group == 2) {
                            //         return("#0af702");
                            //     }
                            //     if (d.group == 3) {
                            //         return("#FF00FF");
                            //     }
                            //     if (d.group == 4) {
                            //         return("#808000");
                            //     }
                            //     if (d.group == 5) {
                            //         return("#000080");
                            //     }
                            //     if (d.group == 6) {
                            //         return("#800080");
                            //     }
                            //     if (d.group == 7) {
                            //         return("#00ffff");
                            //     }
                            //     if (d.group == 8) {
                            //         return("#F5F5DC");
                            //     }
                            //     if (d.group == 9) {
                            //         return("#A52A2A");
                            //     }
                            //     if (d.group == 10) {
                            //         return("#8B0000");
                            //     }
                            //     if (d.group == 11) {
                            //         return("#FF8C00");
                            //     }
                            //
                            // }

                        })



                        //.style("stroke", "#726363")
                        .attr("class", "node-link")
                        .style("stroke-width", function (d) {


                            return d.score*2; })
                        //.style("stroke-width", 0.1)
                        .attr("d", function (d) {

                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,
                                dr = Math.sqrt(dx * dx + dy * dy),
                                a1 = dx,
                                a2 = dy,
                                c1 = w/2 - d.source.x,
                                c2 = h/2 - d.source.y,
                                d1 = w/2 - d.target.x,
                                d2 = h/2 - d.target.y,

                                drx = dr/1.5,
                                dry = dr/1.5,
                                xRotation = 0, // degrees
                                largeArc = 0, // 1 or 0

                                sweep = 1, // 1 or 0
                                x2 = d.target.x,
                                y2 = d.target.y;


                            // if( (a1*c2 - a2*c1) > 0)
                            // {
                            //     sweep = 0
                            // }
                            // else
                            // {sweep = 1}
                            if( (c1*d2 - c2*d1) > 0)
                            {
                                sweep = 0
                            }
                            else
                            {sweep = 1}


                            return "M" + d.source.x + "," + d.source.y + "A" + drx + "," + dry + " " + xRotation + "," + largeArc + "," + sweep + " " + x2 + "," + y2;


                            //return "M" + d.source.x + "," + d.source.y + ","+ d.target.x + "," + d.target.y;
                            //return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
                        });






                    //     var dx = d.target.x - d.source.x,
                    //         dy = d.target.y - d.source.y,
                    //         dr = Math.sqrt(dx * dx + dy * dy);
                    //     return "M" +
                    //         d.source.x + "," +
                    //         d.source.y + "," +
                    //         d.target.x + "," +
                    //         d.target.y;
                    //
                    // });


                    var gnodes = svg4deep.selectAll('g.gnode')
                        .data(nodes).enter().append('g')
                        .attr("transform", function (d) {
                            return "translate(" + d.x + "," + d.y + ")"
                        })
                        .classed('gnode', true);


                    // node.append("circle")
                    //     .attr("r", function (d) { return xScale(d.weight); })
                    //     .style("fill", function(d) { return colNodeScale(d.group); });

//                 function click() {
//                     d3.select(this).select("text").transition()
//                         .duration(750)
//                         .attr("x", 22)
//                         .style("stroke", "lightsteelblue")
//                         .style("stroke-width", ".5px")
//                         .style("font", "20px sans-serif");
//                     d3.select(this).select("circle").transition()
//                         .duration(750)
//                         .attr("r", 16);
//                 }
//
// // action to take on mouse double click
//                 function dblclick() {
//                     d3.select(this).select("circle").transition()
//                         .duration(750)
//                         .attr("r", 6);
//                     d3.select(this).select("text").transition()
//                         .duration(750)
//                         .attr("x", 12)
//                         .style("stroke", "none")
//                         .style("fill", "black")
//                         .style("stroke", "none")
//                         .style("font", "10px sans-serif");
//                 }



                    var node = gnodes.append("circle")
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        .style("fill", function (d) {
                            if (d.group == 0) {
                                return colorScale(d.value);
                            }
                            else {

                                if (d.group == 1) {
                                    return("#ed0909");
                                }
                                if (d.group == 2) {
                                    return("#0af702");
                                }
                                if (d.group == 3) {
                                    return("#FF00FF");
                                }
                                if (d.group == 4) {
                                    return("#808000");
                                }
                                if (d.group == 5) {
                                    return("#000080");
                                }
                                if (d.group == 6) {
                                    return("#800080");
                                }
                                if (d.group == 7) {
                                    return("#00ffff");
                                }
                                if (d.group == 8) {
                                    return("#F5F5DC");
                                }
                                if (d.group == 9) {
                                    return("#A52A2A");
                                }
                                if (d.group == 10) {
                                    return("#8B0000");
                                }
                                if (d.group == 11) {
                                    return("#FF8C00");
                                }

                            }
                            //return colNodeScale(d.group);
                        })

                        // .style("fill", function (d) {
                        //     return colNodeScale(d.group);
                        // })
                        .style("stroke", "#333")
                        .style("stroke-width", "2px")
                        .style("stroke-dasharray",
                            function (d) {
                                if (d.connected == "No") {
                                    ////console.log("not connected");
                                    return (5, 5);

                                }
                                else if(d.connected == "Yes") {
                                    ////console.log("connected");
                                    return (3, 0);
                                }
                            })

                        //.attr("class", "node")
                        .on("mouseenter", function (d) {
                            is_connected(d, 0.1)
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            d3.select(this).transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight + 3);
                            })
                        })
                        // .on("mouseleave", function (d) {
                        //     node.transition().duration(100).attr("r", function (d) {
                        //         return xScale(d.weight);
                        //     })
                        //     //is_connected(d, 1);
                        // })
                        .on("click", function(d){

                            //if(!first_click) {
                            is_connected_on_click(d, 0.1);
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            d3.select(this).transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight + 3);
                            })

                        })

                        .call(force.drag);

                    var labels = gnodes.append("text")
                        .attr("dx", 4)
                        .attr("dy", 4)
                        .style("font", String(fontValue) + "px Arial")
                        .attr("text-anchor", function (d) {
                            return d.x < w / 2 ? "end" : "start";
                        })
                        .attr("transform", function (d) {
                            return d.x < w / 2 ? "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(-20)" : "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(20)";
                        })
                        //.attr("transform", function(d) { return  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")"})
                        //.attr("transform", function(d) { return (d.x-w/2)/(d.y-w/2) < 0 ?  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")" : "rotate(180)"; })
                        .text(function (d) {
                            return d.name
                        })

                    var drag = force.drag()
                        .on("dragstart", dragstart);
                    //.on("dragstart", dragstartAll);


                    //For not moving after drag
                    function dragstart(d) {
                        d3.select(this).classed("fixed", d.fixed = true);

                        for (i = 0; i < nodes.length; i++) {
                            nodes[i].fixed = true;
                        }
                    }


                    var svgText = svg4deep.append("text");
                    svgText.attr("x",10).attr("y",globalHPlus50-50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                        var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                        var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                        var colorScale2 = d3.scale.threshold()
                            .domain(domain_data)
                            .range(colors);


                        var legend2 = svg4deep.selectAll(".legend")

                        //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                            .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                                return d;
                            });

                        // //console.log("colorScale.quantiles()");
                        // //console.log(colorScale.quantiles());
                        legend2.enter().append("g")
                            .attr("class", "legend");
                        var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                        var legendElementWidth = gridSize * 2;
                        legend2.append("rect")
                            .attr("x", function (d, i) {
                                return legendElementWidth * i;
                            })
                            .attr("y", globalHPlus50 - 40)
                            .attr("width", legendElementWidth)
                            .attr("height", gridSize / 2)
                            .style("fill", function (d, i) {
                                return colors[i];
                            });

                        legend2.append("text")
                        //.attr("class", "mono")
                            .text(function (d, i) {
                                if (i == 0) {
                                    return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                                }
                                else if (i == svg4deep.selectAll(".legend").data().length - 1) {

                                    return parseFloat(Math.round((svg4deep.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                                }
                                else {

                                    return parseFloat(Math.round((svg4deep.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                                }
                                //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                            })
                            .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                            .attr("x", function (d, i) {
                                return legendElementWidth * i;
                            })
                            .attr("y", globalHPlus50 - 40 + gridSize);

                        legend2.exit().remove();



                }

                function defaultSVGDeepPhos() {

                    console.log("inside defaultSVGDeepPhos");

                    svg4deep.remove();

                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    colNodeScale.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    // colorScale.domain(d3.extent(nodes, function (d) {
                    //     return d.value;
                    // }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));
                    scoreScale.domain(d3.extent(links, function (d) {
                        return d.score;
                    }));
                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = w,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;

//These variables are global variables
                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;

                    svg4deep = d3.select("#chart4deep")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);
                    svg4deep.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");


                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h])
                        .linkDistance(350)
                        .charge(-2000)
                        //.linkStrength(0.9)
                        //.friction(0.9)
                        //.chargeDistance(300)
                        .gravity(0.15)
                        .on("tick", tick)
                        .start();

                    // for (var i = n*n; i > 0; --i) force.tick();
                    // force.stop();

                    //.stop();


                    var path = svg4deep.append("svg:g").selectAll("path")
                    //.data(links)
                        .data(force.links())
                        .enter().append("svg:path")
                        .style("stroke-width", function (d) {return d.score*2; })
                        .style('stroke', "black")
                        //.style("stroke", function (d) {return colScale(d.value); })
                        .attr("class", function (d) {
                            return "link ";
                        });


                    var node = svg4deep.append("svg:g").selectAll("g.node")
                        .data(force.nodes())
                        .enter().append("svg:g")
                        // .style("stroke-width", 3)
                        // .style('stroke', "black")
                        //.attr("class", "node")
                        .call(force.drag);

                    // nodes.forEach(function(v) {
                    //     var nd;
                    //     var cx = v.coord[0];
                    //     var cy = v.coord[1];
                    //
                    //     switch (v.group) {
                    //         case 1:
                    //             nd = svg.append("circle");
                    //             break;
                    //         case 2:
                    //             nd = svg.append("rect");
                    //             break;
                    //     }
                    // });


                    var colorsForAbundance = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];
                    var colorScale = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colorsForAbundance);


                    node.append("circle")
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        .style("fill", function (d) {
                            if (d.group == 0) {
                                if (d.value < -2.0) {
                                    return "#00A6FF";
                                }
                                if (d.value <= -1.6 && d.value > -2) {
                                    return "#1097E0";
                                }
                                if (d.value <= -1.2 && d.value > -1.6) {
                                    return "#2885B7";
                                }
                                if (d.value <= -0.8 && d.value > -1.2) {
                                    return "#35799E";
                                }
                                if (d.value <= -0.4 && d.value > -1.8) {
                                    return "#4C7991";
                                }
                                if (d.value <= -0.01 && d.value > -0.4) {
                                    return "#6D828D";
                                }
                                if (d.value <= 0.01 && d.value > -0.01) {
                                    return "#8C8C8C";
                                }
                                if (d.value <= 0.4 && d.value > 0.01) {
                                    return "#8E8E5C";
                                }
                                if (d.value <= 0.8 && d.value > 0.4) {
                                    return "#92923C";
                                }
                                if (d.value <= 1.2 && d.value > 0.8) {
                                    return "#A5A52E";
                                }
                                if (d.value <= 1.6 && d.value > 1.2) {
                                    return "#BDBD24";
                                }
                                if (d.value <= 2.0 && d.value > 1.6) {
                                    return "#DDDD15";
                                }
                                if (d.value > 2.0) {
                                    return "#FFFF00";
                                }
                                ////console.log(d.value);
                                //return colorScale(d.value);
                                //   return d3.scale.threshold()
                                //       .domain(d.value)
                                //       .range(colorsForAbundance);

                            }
                            else {
                                if (d.group == 1) {
                                    return("#ed0909");
                                }
                                if (d.group == 2) {
                                    return("#0af702");
                                }
                                if (d.group == 3) {
                                    return("#FF00FF");
                                }
                                if (d.group == 4) {
                                    return("#808000");
                                }
                                if (d.group == 5) {
                                    return("#000080");
                                }
                                if (d.group == 6) {
                                    return("#800080");
                                }
                                if (d.group == 7) {
                                    return("#00ffff");
                                }
                                if (d.group == 8) {
                                    return("#F5F5DC");
                                }
                                if (d.group == 9) {
                                    return("#A52A2A");
                                }
                                if (d.group == 10) {
                                    return("#8B0000");
                                }
                                if (d.group == 11) {
                                    return("#FF8C00");
                                }

                            }
                            //return colNodeScale(d.group);
                        })
                        // .style("fill", function (d) {
                        //     return colNodeScale(d.group);
                        // })
                        .style("stroke", "#333")
                        .style("stroke-dasharray",
                            function (d) {
                                if (d.connected == "No") {
                                    ////console.log("not connected");
                                    return (5, 5);

                                }
                                else if(d.connected == "Yes") {
                                    ////console.log("connected");
                                    return (3, 0);
                                }
                            })
                        .style("stroke-width", "2px");
                    //.on("dblclick", dblclick);



                    // node.append("circle")
                    //     .attr("r", function (d) {
                    //         return xScale(d.weight);
                    //     })
                    //     .style("fill", function (d) {
                    //         if (d.group == 1) {
                    //             return colorScale(d.value);
                    //         }
                    //         else {
                    //             return colNodeScale(d.group);
                    //         }
                    //         //return colNodeScale(d.group);
                    //     })
                    //     .style("stroke", "#333")
                    //     .style("stroke-width", "2px");



                    function openLink() {
                        return function (d) {
                            var url = "";
                            if (d.slug != "") {
                                url = d.slug
                            } //else if(d.type == 2) {
                            //url = "clients/" + d.slug
                            //} else if(d.type == 3) {
                            //url = "agencies/" + d.slug
                            //}
                            window.open("//" + url)
                        }
                    };
                    node.append("svg:image")
                    //****************************************
                    //.attr("class", function(d){ return d.name })
                    //****************************************
                    //.attr("xlink:href", function(d){ return d.img_hrefD})
                        .attr("x", "-36px")
                        .attr("y", "-36px")
                        .attr("width", "70px")
                        .attr("height", "70px")
                    //.on("dblclick", openLink());

                    // .on("mouseover", function (d) { if(d.entity == "company")
                    // {
                    //     d3.select(this).attr("width", "90px")
                    //         .attr("x", "-46px")
                    //         .attr("y", "-36.5px")
                    //         .attr("xlink:href", function(d){ return d.img_hrefL});
                    // }
                    // })
                    // .on("mouseout", function (d) { if(d.entity == "company")
                    // {
                    //     d3.select(this).attr("width", "70px")
                    //         .attr("x", "-36px")
                    //         .attr("y", "-36px")
                    //         .attr("xlink:href", function(d){ return d.img_hrefD});
                    // }
                    // });


                    //.text(function(d) { return d.name })
                    node.append("svg:text")
                    //****************************************
                        .attr("class", function (d) {
                            return d.name
                        })
                        //****************************************
                        .attr("x", 16)
                        .attr("y", ".31em")
                        //.attr("class", "shadow")
                        //.style("font-size","10px")
                        // .attr("dx", 0)
                        // .attr("dy", ".35em")
                        //.style("font-size","12px")
                        //****************************************
                        //text.shadow {
                        .style("stroke", "#fff")
                        .style("stroke-width", "4px")
                        //}
                        //.attr("class", "shadow")
                        .style("font", String(fontValue) + "px Arial")
                        //****************************************
                        //.attr("text-anchor", "middle")
                        //****************************************
                        .text(function (d) {
                            return d.name
                        });
                    //****************************************


                    //This one is for the actual text
                    node.append("svg:text")
                    //****************************************
                        .attr("class", function (d) {
                            return d.name
                        })
                        //****************************************
                        .attr("x", 16)
                        .attr("y", ".31em")
                        //.attr("class", "shadow")
                        //.style("font-size","10px")
                        // .attr("dx", 0)
                        // .attr("dy", ".35em")
                        //.style("font-size","12px")
                        //****************************************
                        .style("font", String(fontValue) + "px Arial")
                        //****************************************
                        //.attr("text-anchor", "middle")
                        //****************************************
                        .text(function (d) {
                            return d.name
                        });
                    //****************************************


                    node.on("mouseover", function (d) {
                        // d3.select(this).select("text")
                        //     .transition()
                        //     .duration(300)
                        //     .text(function (d) {
                        //         return d.full_name;
                        //     })
                        // //.style("font-size", "15px")
                        // .style("font", "14px Times New Roman");
                        //
                        // d3.select(this).select("text")
                        //     .transition()
                        //     .duration(300)
                        //     .text(function (d) {
                        //         return d.full_name;
                        //     })
                        //     //.style("font-size", "15px")
                        //     //.attr("class", "shadow")
                        //     .style("font", "14px Times New Roman");
                        // d3.select(this).select("text")
                        //     .transition()
                        //     .duration(300)
                        //     .text(function (d) {
                        //         return d.full_name;
                        //     })
                        //
                        //     .style("fill",'black')
                        //     .style("font", "14px Times New Roman");

                        //d3.selectAll("text").remove();
                        //d3.select(this).style("stroke-width", 6);

                        //d3.select(this).select("text").style("stroke", "blue");

                        var nodeNeighbors = links.filter(function (link) {
                            // Filter the list of links to only those links that have our target
                            // node as a source or target
                            return link.source.index === d.index || link.target.index === d.index;
                        })
                            .map(function (link) {
                                // Map the list of links to a simple array of the neighboring indices - this is
                                // technically not required but makes the code below simpler because we can use
                                // indexOf instead of iterating and searching ourselves.
                                return link.source.index === d.index ? link.target.index : link.source.index;
                            });

                        d3.selectAll('circle').filter(function (node) {
                            // I filter the selection of all circles to only those that hold a node with an
                            // index in my listg of neighbors
                            return nodeNeighbors.indexOf(node.index) > -1;
                        })
                            .style('stroke', 'blue');

                        //d3.selectAll('text').filter(d).style('fill', 'blue');
                        //****************************
                        // d3.selectAll('text').filter(function(node) {
                        //     // I filter the selection of all circles to only those that hold a node with an
                        //     // index in my listg of neighbors
                        //     return nodeNeighbors.indexOf(node.index) > -1;
                        // }).style('fill', 'blue')
                        //     //.style("font-size", "16px")
                        //     //.style("font-weight", "bold");
                        // //****************************
                        path.style('stroke', function (l) {
                            if (d === l.source || d === l.target)
                                return "blue";
                            else
                                return "grey";
                        })

                        path.style('stroke-width', function (l) {
                            if (d === l.source || d === l.target)
                                return 2;
                            else
                                return 1;
                        })

                    })
                        .on("mouseout", function (d) {
                            d3.select(this).select("text")
                                .transition()
                                .duration(300)
                                .text(function (d) {

                                    return d.name;
                                });
                            // d3.select(this).select("text")
                            //     //*******************************
                            //     .style("font", "14px Times New Roman")
                            //     //*******************************
                            //     .style("font-size", "14px")
                            //     .style("fill",'black')
                            //     .style("font-weight", "normal");

                            // d3.select(this).select("text")
                            // //*******************************
                            //     .style("font", "14px Times New Roman")
                            //     //*******************************
                            //     .style("font-size", "14px")
                            //     .style("fill",'black')
                            //     .style("font-weight", "normal");
                            //d3.select(this).style("stroke", "black");
                            //d3.select(this).style("stroke-width", 1);
                            //d3.select(this).style("stroke", "#333");
                            path.style('stroke', "grey");
                            path.style('stroke-width', 1);
                            //circle.style('stroke', "grey");
                            //node.style("stroke-width", 3);
                            //node.style("stroke", "#333");
                            //d3.selectAll('text').style('fill', 'black')
                            // d3.selectAll('text').style('fill', 'black')
                            //     .style("font-weight", "normal");
                            //d3.selectAll("text").style("font-weight", "normal");
                            node.selectAll("circle").style("stroke-width", 3)
                                .style('stroke', "black");
                            //.style("font-size", "12px");
                            //}
                        });


                    function pythag(r, b, coord) {
                        r += nodeBaseRad;

                        // force use of b coord that exists in circle to avoid sqrt(x<0)
                        b = Math.min(w - r - strokeWidth, Math.max(r + strokeWidth, b));

                        var b2 = Math.pow((b - radius), 2),
                            a = Math.sqrt(hyp2 - b2);

                        function openLink() {
                            return function (d) {
                                var url = "";
                                if (d.slug != "") {
                                    url = d.slug
                                } //else if(d.type == 2) {
                                //url = "clients/" + d.slug
                                //} else if(d.type == 3) {
                                //url = "agencies/" + d.slug
                                //}
                                window.open("//" + url)
                            }
                        }

                        // radius - sqrt(hyp^2 - b^2) < coord < sqrt(hyp^2 - b^2) + radius
                        coord = Math.max(radius - a + r + strokeWidth,
                            Math.min(a + radius - r - strokeWidth, coord));

                        return coord;
                    }

                    function tick(e) {
                        path.attr("d", function (d) {
                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,

                                dr = Math.sqrt(dx * dx + dy * dy);
                            ////console.log(d.source.x);
                            // //console.log(d.target.x);
                            return "M" + d.source.x + "," + d.source.y + "," + d.target.x + "," + d.target.y;
                            //return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
                        });

                        node.attr('x', function (d) {
                            return d.x = pythag(Math.random() * 12, d.y, d.x);
                        })
                            .attr('y', function (d) {
                                return d.y = pythag(Math.random() * 12, d.x, d.y);
                            })
                            .attr("transform", function (d) {
                                return "translate(" + d.x + "," + d.y + ")"
                            });

                        //d3.select(this).classed("fixed", d.fixed = true);
                        // circle.attr("transform", function(d) {
                        //     return "translate(" + d.x + "," + d.y + ")";
                        // });
                        //************************************
                        // text.attr("transform", function(d) {
                        //     return "translate(" + d.x + "," + d.y + ")";
                        // });
                        //************************************
                    }

                    //For not moving after drag
                    var drag = force.drag()
                        .on("dragstart", dragstart);
                    //.on("dragstart", dragstartAll);

                    //For not moving after drag
                    function dblclick(d) {
                        d3.select(this).classed("fixed", d.fixed = false);

                    }

                    //For not moving after drag
                    function dragstart(d) {
                        d3.select(this).classed("fixed", d.fixed = true);

                        for (i = 0; i < nodes.length; i++) {
                            nodes[i].fixed = true;
                        }
                    }


                    var svgText = svg4deep.append("text");
                    svgText.attr("x",10).attr("y",globalHPlus50-50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);




                    var legend2 = svg4deep.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());
                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg4deep.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg4deep.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg4deep.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();




                };

                //defaultSVGPtm();
                //SharedService.setVar('svg', svg);


                if(graphType == 0){
                    defaultSVGDeepPhos();
                }
                else if(graphType == 1){
                    parallelView4deep();
                }
                else if(graphType == 2){
                    circosView4deep();
                }
                else if(graphType == 3){
                    circularView4deep();
                }


                d3.select('#force4deep').on('click', function () {
                    defaultSVGDeepPhos();
                    $scope.graphType4deep = 0;
                });
                d3.select('#parallelView4deep').on('click', function () {
                    parallelView4deep();
                    $scope.graphType4deep = 1;
                });
                d3.select('#circosView4deep').on('click', function () {
                    circosView4deep();
                    $scope.graphType4deep = 2;
                });

                d3.select('#circularView4deep').on('click', function () {
                    circularView4deep();
                    $scope.graphType4deep = 3;
                });

                d3.select("#download-svg4deep").on("click", function ()  {
                    var name = 'PiNET-iPTMnet-Graph.svg';
                    var svgEl = svg4.node();
                    svgEl.setAttribute("xmlns", "http://www.w3.org/2000/svg");
                    var svgData = svgEl.outerHTML;
                    var preface = '<?xml version="1.0" standalone="no"?>\r\n';
                    var svgBlob = new Blob([preface, svgData], {type:"image/svg+xml;charset=utf-8"});
                    var svgUrl = URL.createObjectURL(svgBlob);
                    var downloadLink = document.createElement("a");
                    downloadLink.href = svgUrl;
                    downloadLink.download = name;
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                });

                // Set-up the export button
                d3.select('#download-png4deep').on('click', function () {
                    var svgString = getSVGString(svg4deep.node());

                    svgString2Image(svgString, 4 * globalW, 4 * globalHPlus50, 'png', save); // passes Blob and filesize String to the callback

                    function save(dataBlob, filesize) {
                        saveAs(dataBlob, 'PiNET-deepPhos-graph.png'); // FileSaver.js function
                    }
                });
                d3.select('#saveButton').on('click', function () {
                    var svgString = getSVGString(svg4deep.node());

                    svgString2Image(svgString, 4 * 1550, 4 * 1550, 'png', save); // passes Blob and filesize String to the callback

                    function save(dataBlob, filesize) {
                        saveAs(dataBlob, 'PiNET-deepPhos-graph.png'); // FileSaver.js function
                    }
                });

// Below are the functions that handle actual exporting:
// getSVGString ( svgNode ) and svgString2Image( svgString, width, height, format, callback )
                function getSVGString(svgNode) {
                    svgNode.setAttribute('xlink', 'http://www.w3.org/1999/xlink');
                    var cssStyleText = getCSSStyles(svgNode);
                    appendCSS(cssStyleText, svgNode);

                    var serializer = new XMLSerializer();
                    var svgString = serializer.serializeToString(svgNode);
                    svgString = svgString.replace(/(\w+)?:?xlink=/g, 'xmlns:xlink='); // Fix root xlink without namespace
                    svgString = svgString.replace(/NS\d+:href/g, 'xlink:href'); // Safari NS namespace fix

                    return svgString;

                    function getCSSStyles(parentElement) {
                        var selectorTextArr = [];

                        // Add Parent element Id and Classes to the list
                        selectorTextArr.push('#' + parentElement.id);
                        for (var c = 0; c < parentElement.classList.length; c++)
                            if (!contains('.' + parentElement.classList[c], selectorTextArr))
                                selectorTextArr.push('.' + parentElement.classList[c]);

                        // Add Children element Ids and Classes to the list
                        var nodes = parentElement.getElementsByTagName("*");
                        for (var i = 0; i < nodes.length; i++) {
                            var id = nodes[i].id;
                            if (!contains('#' + id, selectorTextArr))
                                selectorTextArr.push('#' + id);

                            var classes = nodes[i].classList;
                            for (var c = 0; c < classes.length; c++)
                                if (!contains('.' + classes[c], selectorTextArr))
                                    selectorTextArr.push('.' + classes[c]);
                        }

                        // Extract CSS Rules
                        var extractedCSSText = "";
                        for (var i = 0; i < document.styleSheets.length; i++) {
                            var s = document.styleSheets[i];

                            try {
                                if (!s.cssRules) continue;
                            } catch (e) {
                                if (e.name !== 'SecurityError') throw e; // for Firefox
                                continue;
                            }

                            var cssRules = s.cssRules;
                            for (var r = 0; r < cssRules.length; r++) {
                                if (contains(cssRules[r].selectorText, selectorTextArr))
                                    extractedCSSText += cssRules[r].cssText;
                            }
                        }


                        return extractedCSSText;

                        function contains(str, arr) {
                            return arr.indexOf(str) === -1 ? false : true;
                        }

                    }

                    function appendCSS(cssText, element) {
                        var styleElement = document.createElement("style");
                        styleElement.setAttribute("type", "text/css");
                        styleElement.innerHTML = cssText;
                        var refNode = element.hasChildNodes() ? element.children[0] : null;
                        element.insertBefore(styleElement, refNode);
                    }
                }


                function svgString2Image(svgString, width, height, format, callback) {
                    var format = format ? format : 'png';

                    var imgsrc = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgString))); // Convert SVG string to data URL

                    var canvas = document.createElement("canvas");
                    var context = canvas.getContext("2d");

                    canvas.width = width;
                    canvas.height = height;

                    var image = new Image();
                    image.onload = function () {
                        context.clearRect(0, 0, width, height);
                        context.drawImage(image, 0, 0, width, height);

                        canvas.toBlob(function (blob) {
                            var filesize = Math.round(blob.length / 1024) + ' KB';
                            if (callback) callback(blob, filesize);
                        });


                    };

                    image.src = imgsrc;
                }


                // d3.select("#download").on("click", function(){
                //     var html = d3.select("svg")
                //         .attr("version", 1.1)
                //         .attr("xmlns", "http://www.w3.org/2000/svg")
                //         .node().parentNode.innerHTML;
                //
                //     ////console.log(html);
                //     var imgsrc = 'data:image/svg+xml;base64,'+ btoa(html);
                //     var img = '<img src="'+imgsrc+'">';
                //     d3.select("#svgdataurl").html(img);
                //
                //
                //     var canvas = document.querySelector("canvas"),
                //         context = canvas.getContext("2d");
                //
                //     var image = new Image;
                //     image.src = imgsrc;
                //     image.onload = function() {
                //         context.drawImage(image, 0, 0);
                //
                //         var canvasdata = canvas.toDataURL("image/png");
                //
                //         var pngimg = '<img src="'+canvasdata+'">';
                //         d3.select("#pngdataurl").html(pngimg);
                //
                //         var a = document.createElement("a");
                //         a.download = "sample.png";
                //         a.href = canvasdata;
                //         a.click();
                //     };
                //
                // });


            }


            // //console.log(network.parallel);
            // //console.log(network.circular);
            // update(network.nodes, network.edges, network.parallel, network.circular);
            //console.log(network.nodes);
            //console.log(ptmToAbundance);
            for (var iterNetNode = 0; iterNetNode < network.nodes.length; iterNetNode++)
            {
                var iterNetNodeKey = network.nodes[iterNetNode]["name"];
                if (iterNetNodeKey in ptmToAbundance)
                {
                    //console.log(iterNetNodeKey);
                    if (ptmToAbundance[iterNetNodeKey] == "NA")
                    {
                        network.nodes[iterNetNode]["value"] = 0.0;
                    }
                    else {
                        network.nodes[iterNetNode]["value"] = ptmToAbundance[iterNetNodeKey];
                    }
                }
            }
            //console.log(self.computeWeightForupdatePtm);
            if(self.computeWeightForUpdateDeepPhos) {
                //console.log("---  inside computeWeightForUpdatePtm");
                for (var iterNetNode = 0; iterNetNode < network.edges.length; iterNetNode++) {
                    //var iterNetNodeKey = network.nodes[iterNetNode]["name"];
                    var idx1 = network.edges[iterNetNode]["source"];
                    var idx2 = network.edges[iterNetNode]["target"];
                    network.nodes[idx1]["weight"] += 1;
                    network.nodes[idx2]["weight"] += 1;

                }
                self.computeWeightForUpdateDeepPhos = false;
                SharedService.setVar('computeWeightForUpdateDeepPhos',self.computeWeightForUpdateDeepPhos);
            }
            console.log(network);
            console.log(ptmToAbundance);
            updateDeepPhos(network.nodes, network.edges, graphType, circleSliderValue, nodeSliderValue, fontSliderValue, widthSliderValue);


            self.showDeepPhosGraph = true;
        }
    }


    $scope.graphType4ptm = 1;
    $scope.circleSliderValue4ptm = 1100;
    $scope.nodeSliderValue4ptm = 15;
    $scope.fontSliderValue4ptm = 14;
    $scope.widthSliderValue4ptm = 1500;
    $(document).on('input', '#circle_slider4ptm', function() {
        $('#circle_slider_value4ptm').html( $(this).val() );
        ////console.log($(this).val());
        $scope.circleSliderValue4ptm = $(this).val();

        $scope.$apply();

        $scope.makePtmGraph(self.ptmNetwork, self.ptmProteinToAbundanceMap, $scope.graphType4ptm, $scope.circleSliderValue4ptm, $scope.nodeSliderValue4ptm, $scope.fontSliderValue4ptm, $scope.widthSliderValue4ptm);
    });

    $(document).on('input', '#node_slider4ptm', function() {
        $('#node_slider_value4ptm').html( $(this).val() );
        ////console.log($(this).val());
        $scope.nodeSliderValue4ptm = $(this).val();

        $scope.$apply();

        $scope.makePtmGraph(self.ptmNetwork, self.ptmProteinToAbundanceMap, $scope.graphType4ptm, $scope.circleSliderValue4ptm, $scope.nodeSliderValue4ptm, $scope.fontSliderValue4ptm, $scope.widthSliderValue4ptm);
    });

    $(document).on('input', '#font_slider4ptm', function() {
        $('#font_slider_value4ptm').html( $(this).val() );
        ////console.log($(this).val());
        $scope.fontSliderValue4ptm = $(this).val();

        $scope.$apply();

        $scope.makePtmGraph(self.ptmNetwork, self.ptmProteinToAbundanceMap, $scope.graphType4ptm, $scope.circleSliderValue4ptm, $scope.nodeSliderValue4ptm, $scope.fontSliderValue4ptm, $scope.widthSliderValue4ptm);
    });

    $(document).on('input', '#width_slider4ptm', function() {
        $('#width_slider_value4ptm').html( $(this).val() );
        ////console.log($(this).val());
        $scope.widthSliderValue4ptm = $(this).val();

        $scope.$apply();

        $scope.makePtmGraph(self.ptmNetwork, self.ptmProteinToAbundanceMap, $scope.graphType4ptm, $scope.circleSliderValue4ptm, $scope.nodeSliderValue4ptm, $scope.fontSliderValue4ptm, $scope.widthSliderValue4ptm);


    });



    $scope.hidePtmGraph = function () {
        self.showPtmGraphTmp = true;
        self.showPtmGraph = false;
    }
    $scope.makePtmGraph = function (network, ptmToAbundance, graphType, circleSliderValue, nodeSliderValue, fontSliderValue, widthSliderValue) {
        //console.log(self.computeWeightForUpdatePtm);
        if(self.showPtmGraphTmp)
        {
            self.showPtmGraphTmp = false;
            self.showPtmGraph = true;
        }
        else {

            self.showPtmGraphTmp = true;
            self.showPtmGraph = false;
            console.log("in makePtmGraph");
            console.log("graphType");
            console.log(graphType);
            console.log($scope.graphType4ptm);
            d3.select("#chart4").select("svg").remove();
            if (typeof svg4 === 'undefined') {
                var svg4 = d3.selectAll("#chart4").append("svg");
            }
            //var svg4 = d3.selectAll("#chart4").append("svg");


            var force;
            var colNodeScaleSeparate = d3.scale.ordinal()
                .range(["#987024", "#ed0909", "#0af702", "#d506d8"])
                //.range(["#987024", "#982482", "#0af702"])
                .domain([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);
//#f9a3f5
            // var colNodeScaleSeparate = d3.scale.ordinal()
            //     .range(["#767776", "#f91104", "#0af702"])
            //     .domain([0,1,2]);

            // var colNodeScale = d3.scale.linear().range(["#987024", "#ed0909"]);
            // var colScale = d3.scale.linear().range(["#987024", "#ed0909"]);

            var colScale = d3.scale.ordinal()
                .range(["#987024", "#ed0909", "#0af702", "#d506d8"])
                //.range(["#987024", "#982482", "#0af702"])
                .domain([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);

            var colNodeScale = d3.scale.ordinal()
                .range(["#987024", "#ed0909", "#0af702", "#d506d8"])
                //.range(["#987024", "#982482", "#0af702"])
                .domain([1, 2, 3, 4]);
            var edgeWeightScale = d3.scale.linear().range([1, 3]);
            var xScale = d3.scale.linear().range([nodeSliderValue/3.0, nodeSliderValue]);
            //var xScale = d3.scale.linear().range([5, 15]);
            var scoreScale = d3.scale.linear().range([1, 5]);
            var textPlacePlusMinus = d3.scale.ordinal()
                .range([18, -18, -18, -18, -18, -18, -18, -18, -18, -18, -18, -18])
                .domain([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);
            var textPlaceStartEnd = d3.scale.ordinal().range(["start", "end", "end", "end", "end", "end", "end", "end", "end", "end", "end", "end"])
                .domain([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);

            var colorsForAbundance = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
            var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];
            var colorScale = d3.scale.threshold()
                .domain(domain_data)
                .range(colorsForAbundance);


            function updatePtm(nodes, links, graphType, circleValue, nodeValue, fontValue, widthValue) {
                //
                //var svg;
                circleValue = Math.min(circleValue, widthValue - 300);

                // $('force1').click();
                //document.getElementById('force1').click();

                // //console.log(circularLayout);



                // self.computeWeightForupdatePtm = false;
                // SharedService.setVar('computeWeightForupdatePtm', self.computeWeightForupdatePtm);




                // Set-up the export button
                // d3.select('#download-png').on('click', function() {
                //
                // })

                function circularView4() {
                    svg4.remove();

                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    scoreScale.domain(d3.extent(links, function (d) {
                        return d.score;
                    }));
                    colNodeScale.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));
                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = w,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;


                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;


                    svg4 = d3.select("#chart4")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);
                    svg4.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");


                    // This is for grouping nodes


                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h]);

// evenly spaces nodes along arc
                    var circleCoord = function (node, index, num_nodes) {
                        var circumference = circle.node().getTotalLength();
                        var pointAtLength = function (l) {
                            return circle.node().getPointAtLength(l)
                        };
                        var sectionLength = (circumference) / num_nodes;
                        var position = sectionLength * index + sectionLength / 2;
                        return pointAtLength(circumference - position)
                    }

                    var is_connected = function (d, opacity) {
                        lines.transition().style("stroke-opacity", function (o) {
                            return o.source === d || o.target === d ? 1 : opacity;
                        });
                    }

                    var dim = w - (widthValue - circleValue);
                    var circle = svg4.append("path")
                        .attr("d", "M " + String((widthValue - circleValue)/2) + ", " + (dim / 2 + (widthValue - circleValue)/2) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                        .style("fill", "white");

                    // var dim = w - 900
                    // var circle = svg4.append("path")
                    //     .attr("d", "M 450, " + (dim / 2 + 450) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                    //     .style("fill", "white");

                    force.start();

                    nodes.forEach(function (n, i) {
                        var coord = circleCoord(n, i, nodes.length)
                        n.x = coord.x
                        n.y = coord.y
                    });


                    // use this one for straight line links...
                    // var lines = svg.selectAll("line.node-link")
                    //     .data(links).enter().append("line")
                    //     .attr("class", "node-link")
                    //     .attr("x1", function(d) { return d.source.x; })
                    //     .attr("y1", function(d) { return d.source.y; })
                    //     .attr("x2", function(d) { return d.target.x; })
                    //     .attr("y2", function(d) { return d.target.y; });

                    var lines = svg4.selectAll("path.node-link")
                        .data(links).enter().append("path")
                        .style("fill", "none")
                        .style("stroke", "#726363")
                        .attr("class", "node-link")
                        .style("stroke-width", function (d) {return d.score/2; })
                        .attr("d", function (d) {
                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,
                                dr = Math.sqrt(dx * dx + dy * dy);
                            return "M" +
                                d.source.x + "," +
                                d.source.y + "," +
                                d.target.x + "," +
                                d.target.y;

                        });


                    var gnodes = svg4.selectAll('g.gnode')
                        .data(nodes).enter().append('g')
                        .attr("transform", function (d) {
                            return "translate(" + d.x + "," + d.y + ")"
                        })
                        .classed('gnode', true);


                    // node.append("circle")
                    //     .attr("r", function (d) { return xScale(d.weight); })
                    //     .style("fill", function(d) { return colNodeScale(d.group); });

                    var node = gnodes.append("circle")
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        .style("fill", function (d) {
                            if (d.group == 0) {
                                return colorScale(d.value);
                            }
                            else {

                                if (d.group == 1) {
                                    return("#ed0909");
                                }
                                if (d.group == 2) {
                                    return("#0af702");
                                }
                                if (d.group == 3) {
                                    return("#FF00FF");
                                }
                                if (d.group == 4) {
                                    return("#808000");
                                }
                                if (d.group == 5) {
                                    return("#000080");
                                }
                                if (d.group == 6) {
                                    return("#800080");
                                }
                                if (d.group == 7) {
                                    return("#00ffff");
                                }
                                if (d.group == 8) {
                                    return("#F5F5DC");
                                }
                                if (d.group == 9) {
                                    return("#A52A2A");
                                }
                                if (d.group == 10) {
                                    return("#8B0000");
                                }
                                if (d.group == 11) {
                                    return("#FF8C00");
                                }

                            }
                            //return colNodeScale(d.group);
                        })
                        // .style("fill", function (d) {
                        //     return colNodeScale(d.group);
                        // })
                        .style("stroke", "#333")
                        .style("stroke-width", "2px")
                        .style("stroke-dasharray",
                            function (d) {
                                if (d.connected == "No") {
                                    ////console.log("not connected");
                                    return (5, 5);

                                }
                                else if(d.connected == "Yes") {
                                    ////console.log("connected");
                                    return (3, 0);
                                }
                            })

                        //.attr("class", "node")
                        .on("mouseenter", function (d) {
                            is_connected(d, 0.1)
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            d3.select(this).transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight + 3);
                            })
                        })
                        .on("mouseleave", function (d) {
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            is_connected(d, 1);
                        })
                        .call(force.drag);

                    var labels = gnodes.append("text")
                        .attr("dx", 4)
                        .attr("dy", 4)
                        //.style("font", "14px Times New Roman")
                        .style("font", String(fontValue) + "px Arial")
                        .attr("text-anchor", function (d) {
                            return d.x < w / 2 ? "end" : "start";
                        })
                        .attr("transform", function (d) {
                            return d.x < w / 2 ? "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(-20)" : "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(20)";
                        })
                        //.attr("transform", function(d) { return  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")"})
                        //.attr("transform", function(d) { return (d.x-w/2)/(d.y-w/2) < 0 ?  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")" : "rotate(180)"; })
                        .text(function (d) {
                            return d.full_name
                        })

                    var drag = force.drag()
                        .on("dragstart", dragstart);
                    //.on("dragstart", dragstartAll);


                    //For not moving after drag
                    function dragstart(d) {
                        d3.select(this).classed("fixed", d.fixed = true);

                        for (i = 0; i < nodes.length; i++) {
                            nodes[i].fixed = true;
                        }
                    }


                    var svgText = svg4.append("text");
                    svgText.attr("x",10).attr("y",globalHPlus50-50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);



                    var legend2 = svg4.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());
                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg4.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg4.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg4.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();



                };


                function parallelView4() {
                    svg4.remove();

                    //xPosition.domain(d3.extent(nodes, function (d) { return d.text; }));
                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    colNodeScale.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));
                    textPlacePlusMinus.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    textPlaceStartEnd.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    scoreScale.domain(d3.extent(links, function (d) {
                        return d.score;
                    }));
                    n1 = 0;
                    n2 = 0;

                    nodes.forEach(function (n, i) {


                        if (n.group == 0) {

                            n1 = n1 + 1;
                        }
                        else {

                            n2 = n2 + 1;
                        }

                    });


                    var totalN1 = n1;
                    var totalN2 = n2;
                    //console.log(n1);
                    //console.log(n1 * 12);
                    //console.log(n2);
                    //console.log(n2 * 12);
                    var parallelH = Math.max(n1 * 12, n2 * 12, 500);
                    //var parallelH = Math.max(n1 * 12, n2 * 12);

                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = parallelH,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;

                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;


                    svg4 = d3.select("#chart4")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);

                    svg4.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");


                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h]);


                    var parallelCoordx = function (group) {

                        if (group == 0) {
                            return w * 1.5 / 3.0;
                        }
                        else {
                            return w / 3.0;
                        }
                    }

                    var parallelCoordy = function (index, num_nodes) {
                        var dist = h / (num_nodes + 1);

                        return (index + 1) * dist;
                    }

                    var is_connected = function (d, opacity) {
                        lines.transition().style("stroke-opacity", function (o) {
                            return o.source === d || o.target === d ? 1 : opacity;
                        });
                    }

                    //var dim = w-80
                    // var circle = svg.append("path")
                    //     .attr("d", "M 40, "+(dim/2+40)+" a "+dim/2+","+dim/2+" 0 1,0 "+dim+",0 a "+dim/2+","+dim/2+" 0 1,0 "+dim*-1+",0")
                    //     .style("fill", "#f5f5f5");

                    force.start();


                    // //console.log(nodes.length);
                    var groupId = [];
                    var maxId = 0;
                    for (var i = 0; i < nodes.length; i++) {
                        var item = nodes[i];

                        if (!groupId[item.group]) {
                            groupId[item.group] = [];
                        }

                        groupId[item.group].push({name: item.name});
                        // //console.log(item.group);
                        // //console.log(groupId[item.group]);
                        if (maxId < item.group) {
                            maxId = item.group;
                        }
                    }
                    // //console.log(maxId);
                    // //console.log(groupId[1].length);
                    // //console.log(groupId[2].length);

                    n1 = 0;
                    n2 = 0;

                    nodes.forEach(function (n, i) {
                        var item = nodes[i];

                        if (n.group == 0) {
                            n.x = parallelCoordx(n.group)
                            n.y = parallelCoordy(n1, totalN1)
                            n1 = n1 + 1;
                        }
                        else {
                            n.x = parallelCoordx(n.group)
                            n.y = parallelCoordy(n2, totalN2)
                            n2 = n2 + 1;
                        }
                            // n.weight = links.filter(function (l) {
                            //     return l.source.index == n.index || l.target.index == n.index
                            // }).size();

                    });


                    // use this one for straight line links...
                    // var lines = svg.selectAll("line.node-link")
                    //   .data(links).enter().append("line")
                    //     .attr("class", "node-link")
                    //   .attr("x1", function(d) { return d.source.x; })
                    //   .attr("y1", function(d) { return d.source.y; })
                    //   .attr("x2", function(d) { return d.target.x; })
                    //   .attr("y2", function(d) { return d.target.y; });

                    var lines = svg4.selectAll("path.node-link")
                        .data(links).enter().append("path")
                        .style("fill", "none")
                        .style("stroke", "#726363")
                        .attr("class", "node-link")
                        .style("stroke-width", function (d) {return d.score/2; })
                        .attr("d", function (d) {
                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,
                                dr = Math.sqrt(dx * dx + dy * dy);
                            return "M" +
                                d.source.x + "," +
                                d.source.y + "," +
                                d.target.x + "," +
                                d.target.y;
                        });


                    // nodes.weight = lines.filter(function(l) {
                    //     return l.source.index == d.index || l.target.index == d.index
                    // }).size();

                    // var lines = svg.selectAll("path.node-link")
                    //     .data(links).enter().append("path")
                    //     .style("fill", "none")
                    //     .style("stroke", "black")
                    //     .attr("class", "node-link")
                    //     .attr("d", function(d) {
                    //         var dx = d.target.x - d.source.x,
                    //             dy = d.target.y - d.source.y,
                    //             dr = Math.sqrt(dx * dx + dy * dy);
                    //         return "M" +
                    //             d.source.x + "," +
                    //             d.source.y + "A" +
                    //             dr + "," + dr + " 0 0,1 " +
                    //             d.target.x + "," +
                    //             d.target.y;
                    //     });

                    var gnodes = svg4.selectAll('g.gnode')
                        .data(nodes).enter().append('g')
                        .attr("transform", function (d) {
                            return "translate(" + d.x + "," + d.y + ")"
                        })
                        .classed('gnode', true);

                    // gnodes.forEach(function (n, i) {
                    //     n.weight = lines.filter(function (l) {
                    //         return l.source.idx == n.idx || l.target.idx == n.idx
                    //     }).size();
                    //
                    // });
                    var node = gnodes.append("circle")
                        //.attr("r", function(d) {
                            // d.sizes = lines.filter(function(l) {
                            //     return l.source.index == d.index || l.target.index == d.index
                            // }).size();
                            // var minRadius = 5;
                            // return minRadius + (d.sizes * 2);
                        //     return colorScale(d.weight);
                        // })
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        .style("fill", function (d) {
                            if (d.group == 0) {
                                return colorScale(d.value);
                            }
                            else {
                                if (d.group == 1) {
                                    return("#ed0909");
                                }
                                if (d.group == 2) {
                                    return("#0af702");
                                }
                                if (d.group == 3) {
                                    return("#FF00FF");
                                }
                                if (d.group == 4) {
                                    return("#808000");
                                }
                                if (d.group == 5) {
                                    return("#000080");
                                }
                                if (d.group == 6) {
                                    return("#800080");
                                }
                                if (d.group == 7) {
                                    return("#00ffff");
                                }
                                if (d.group == 8) {
                                    return("#F5F5DC");
                                }
                                if (d.group == 9) {
                                    return("#A52A2A");
                                }
                                if (d.group == 10) {
                                    return("#8B0000");
                                }
                                if (d.group == 11) {
                                    return("#FF8C00");
                                }
                            }
                            //return colNodeScale(d.group);
                        })
                        // .style("fill", function (d) {
                        //     return colNodeScale(d.group);
                        // })
                        .style("stroke", "#333")
                        .style("stroke-width", "2px")
                        .style("stroke-dasharray",
                            function (d) {
                                if (d.connected == "No") {
                                    ////console.log("not connected");
                                    return (5, 5);

                                }
                                else if(d.connected == "Yes") {
                                    ////console.log("connected");
                                    return (3, 0);
                                }
                            })
                        //.attr("class", "node")
                        .on("mouseenter", function (d) {
                            is_connected(d, 0.1)
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            d3.select(this).transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight + 3);
                            })
                        })
                        .on("mouseleave", function (d) {
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            is_connected(d, 1);
                        })
                        .call(force.drag);
                    // var bbox = textElement.getBBox();
                    // var width = bbox.width;
                    // var height = bbox.height;
                    var labels = gnodes.append("text")
                        .style("font", String(fontValue) + "px Arial")
                        //.style("font", "14px Times New Roman")
                        .attr("dx", function (d) {
                            return textPlacePlusMinus(d.group);
                        })
                        .attr("dy", 4)
                        .attr("text-anchor", function (d) {
                            return textPlaceStartEnd(d.group);
                        })
                        .text(function (d) {
                            return d.full_name
                        })

                    var svgText = svg4.append("text");
                    svgText.attr("x",10).attr("y",globalHPlus50-50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);



                    var legend2 = svg4.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());
                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg4.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg4.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg4.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();

                };

                //parallelView4();

                // d3.select('#parallelView4').on('click', function () {
                //     parallelView4()
                // });

                function circosView4(){
                    svg4.remove();

                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    scoreScale.domain(d3.extent(links, function (d) {
                        return d.score;
                    }));
                    colNodeScale.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));
                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = w,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;


                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;


                    svg4 = d3.select("#chart4")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);
                    svg4.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");


                    // This is for grouping nodes


                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h]);

// evenly spaces nodes along arc
                    var circleCoord = function (node, index, num_nodes) {
                        var circumference = circle.node().getTotalLength();
                        var pointAtLength = function (l) {
                            return circle.node().getPointAtLength(l)
                        };
                        var sectionLength = (circumference) / num_nodes;
                        var position = sectionLength * index + sectionLength / 2;
                        return pointAtLength(circumference - position)
                    }

                    var is_connected = function (d, opacity) {
                        lines.transition().style("stroke-opacity", function (o) {
                            return o.source === d || o.target === d ? 1 : opacity;
                        });
                    }

                    var dim = w - (widthValue - circleValue);
                    var circle = svg4.append("path")
                        .attr("d", "M " + String((widthValue - circleValue)/2) + ", " + (dim / 2 + (widthValue - circleValue)/2) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                        .style("fill", "white");

                    // var dim = w - 900
                    // var circle = svg4.append("path")
                    //     .attr("d", "M 450, " + (dim / 2 + 450) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                    //     .style("fill", "white");

                    force.start();

                    nodes.forEach(function (n, i) {
                        var coord = circleCoord(n, i, nodes.length)
                        n.x = coord.x
                        n.y = coord.y
                    });


                    // use this one for straight line links...
                    // var lines = svg.selectAll("line.node-link")
                    //     .data(links).enter().append("line")
                    //     .attr("class", "node-link")
                    //     .attr("x1", function(d) { return d.source.x; })
                    //     .attr("y1", function(d) { return d.source.y; })
                    //     .attr("x2", function(d) { return d.target.x; })
                    //     .attr("y2", function(d) { return d.target.y; });

                    var lines = svg4.selectAll("path.node-link")
                        .data(links).enter().append("path")
                        .style("fill", "none")
                        .style("stroke", "#726363")
                        .attr("class", "node-link")
                        .style("stroke-width", function (d) {return d.score/2; })
                        .attr("d", function (d) {

                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,
                                dr = Math.sqrt(dx * dx + dy * dy),
                                a1 = dx,
                                a2 = dy,
                                c1 = w / 2 - d.source.x,
                                c2 = h / 2 - d.source.y,
                                d1 = w / 2 - d.target.x,
                                d2 = h / 2 - d.target.y,

                                drx = dr / 1.5,
                                dry = dr / 1.5,
                                xRotation = 0, // degrees
                                largeArc = 0, // 1 or 0

                                sweep = 1, // 1 or 0
                                x2 = d.target.x,
                                y2 = d.target.y;


                            // if( (a1*c2 - a2*c1) > 0)
                            // {
                            //     sweep = 0
                            // }
                            // else
                            // {sweep = 1}
                            if ((c1 * d2 - c2 * d1) > 0) {
                                sweep = 0
                            }
                            else {
                                sweep = 1
                            }


                            return "M" + d.source.x + "," + d.source.y + "A" + drx + "," + dry + " " + xRotation + "," + largeArc + "," + sweep + " " + x2 + "," + y2;
                        })

                        //
                        // .attr("d", function (d) {
                        //     var dx = d.target.x - d.source.x,
                        //         dy = d.target.y - d.source.y,
                        //         dr = Math.sqrt(dx * dx + dy * dy);
                        //     return "M" +
                        //         d.source.x + "," +
                        //         d.source.y + "," +
                        //         d.target.x + "," +
                        //         d.target.y;
                        //
                        // });


                    var gnodes = svg4.selectAll('g.gnode')
                        .data(nodes).enter().append('g')
                        .attr("transform", function (d) {
                            return "translate(" + d.x + "," + d.y + ")"
                        })
                        .classed('gnode', true);


                    // node.append("circle")
                    //     .attr("r", function (d) { return xScale(d.weight); })
                    //     .style("fill", function(d) { return colNodeScale(d.group); });

                    var node = gnodes.append("circle")
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        .style("fill", function (d) {
                            if (d.group == 0) {
                                return colorScale(d.value);
                            }
                            else {

                                if (d.group == 1) {
                                    return("#ed0909");
                                }
                                if (d.group == 2) {
                                    return("#0af702");
                                }
                                if (d.group == 3) {
                                    return("#FF00FF");
                                }
                                if (d.group == 4) {
                                    return("#808000");
                                }
                                if (d.group == 5) {
                                    return("#000080");
                                }
                                if (d.group == 6) {
                                    return("#800080");
                                }
                                if (d.group == 7) {
                                    return("#00ffff");
                                }
                                if (d.group == 8) {
                                    return("#F5F5DC");
                                }
                                if (d.group == 9) {
                                    return("#A52A2A");
                                }
                                if (d.group == 10) {
                                    return("#8B0000");
                                }
                                if (d.group == 11) {
                                    return("#FF8C00");
                                }

                            }
                            //return colNodeScale(d.group);
                        })
                        // .style("fill", function (d) {
                        //     return colNodeScale(d.group);
                        // })
                        .style("stroke", "#333")
                        .style("stroke-width", "2px")
                        .style("stroke-dasharray",
                            function (d) {
                                if (d.connected == "No") {
                                    ////console.log("not connected");
                                    return (5, 5);

                                }
                                else if(d.connected == "Yes") {
                                    ////console.log("connected");
                                    return (3, 0);
                                }
                            })

                        //.attr("class", "node")
                        .on("mouseenter", function (d) {
                            is_connected(d, 0.1)
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            d3.select(this).transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight + 3);
                            })
                        })
                        .on("mouseleave", function (d) {
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            is_connected(d, 1);
                        })
                        .call(force.drag);

                    var labels = gnodes.append("text")
                        .attr("dx", 4)
                        .attr("dy", 4)
                        //.style("font", "14px Times New Roman")
                        .style("font", String(fontValue) + "px Arial")
                        .attr("text-anchor", function (d) {
                            return d.x < w / 2 ? "end" : "start";
                        })
                        .attr("transform", function (d) {
                            return d.x < w / 2 ? "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(-20)" : "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(20)";
                        })
                        //.attr("transform", function(d) { return  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")"})
                        //.attr("transform", function(d) { return (d.x-w/2)/(d.y-w/2) < 0 ?  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")" : "rotate(180)"; })
                        .text(function (d) {
                            return d.full_name
                        })

                    var drag = force.drag()
                        .on("dragstart", dragstart);
                    //.on("dragstart", dragstartAll);


                    //For not moving after drag
                    function dragstart(d) {
                        d3.select(this).classed("fixed", d.fixed = true);

                        for (i = 0; i < nodes.length; i++) {
                            nodes[i].fixed = true;
                        }
                    }


                    var svgText = svg4.append("text");
                    svgText.attr("x",10).attr("y",globalHPlus50-50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);



                    var legend2 = svg4.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());
                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg4.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg4.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg4.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();



                };

                function defaultView4() {


                    svg4.remove();

                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    colNodeScale.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    // colorScale.domain(d3.extent(nodes, function (d) {
                    //     return d.value;
                    // }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));
                    scoreScale.domain(d3.extent(links, function (d) {
                        return d.score;
                    }));
                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = w,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;

//These variables are global variables
                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;

                    svg4 = d3.select("#chart4")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);
                    svg4.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");


                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h])
                        .linkDistance(150)
                        .charge(-500)
                        //.linkStrength(0.9)
                        //.friction(0.9)
                        //.chargeDistance(300)
                        .gravity(0.25)
                        //.theta(0.8)
                        //.alpha(0.1)
                        .on("tick", tick)
                        .start();

                    // for (var i = n*n; i > 0; --i) force.tick();
                    // force.stop();

                    //.stop();


                    var path = svg4.append("svg:g").selectAll("path")
                    //.data(links)
                        .data(force.links())
                        .enter().append("svg:path")
                        .style("stroke-width", function (d) {return d.score/2; })
                        .style('stroke', "black")
                        //.style("stroke", function (d) {return colScale(d.value); })
                        .attr("class", function (d) {
                            return "link ";
                        });


                    var node = svg4.append("svg:g").selectAll("g.node")
                        .data(force.nodes())
                        .enter().append("svg:g")
                        // .style("stroke-width", 3)
                        // .style('stroke', "black")
                        //.attr("class", "node")
                        .call(force.drag);

                    // nodes.forEach(function(v) {
                    //     var nd;
                    //     var cx = v.coord[0];
                    //     var cy = v.coord[1];
                    //
                    //     switch (v.group) {
                    //         case 1:
                    //             nd = svg.append("circle");
                    //             break;
                    //         case 2:
                    //             nd = svg.append("rect");
                    //             break;
                    //     }
                    // });


                    var colorsForAbundance = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];
                    var colorScale = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colorsForAbundance);


                    node.append("circle")
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        .style("fill", function (d) {
                            if (d.group == 0) {
                                if (d.value < -2.0) {
                                    return "#00A6FF";
                                }
                                if (d.value <= -1.6 && d.value > -2) {
                                    return "#1097E0";
                                }
                                if (d.value <= -1.2 && d.value > -1.6) {
                                    return "#2885B7";
                                }
                                if (d.value <= -0.8 && d.value > -1.2) {
                                    return "#35799E";
                                }
                                if (d.value <= -0.4 && d.value > -1.8) {
                                    return "#4C7991";
                                }
                                if (d.value <= -0.01 && d.value > -0.4) {
                                    return "#6D828D";
                                }
                                if (d.value <= 0.01 && d.value > -0.01) {
                                    return "#8C8C8C";
                                }
                                if (d.value <= 0.4 && d.value > 0.01) {
                                    return "#8E8E5C";
                                }
                                if (d.value <= 0.8 && d.value > 0.4) {
                                    return "#92923C";
                                }
                                if (d.value <= 1.2 && d.value > 0.8) {
                                    return "#A5A52E";
                                }
                                if (d.value <= 1.6 && d.value > 1.2) {
                                    return "#BDBD24";
                                }
                                if (d.value <= 2.0 && d.value > 1.6) {
                                    return "#DDDD15";
                                }
                                if (d.value > 2.0) {
                                    return "#FFFF00";
                                }
                                ////console.log(d.value);
                                //return colorScale(d.value);
                             //   return d3.scale.threshold()
                             //       .domain(d.value)
                             //       .range(colorsForAbundance);

                            }
                            else {
                                if (d.group == 1) {
                                    return("#ed0909");
                                }
                                if (d.group == 2) {
                                    return("#0af702");
                                }
                                if (d.group == 3) {
                                    return("#FF00FF");
                                }
                                if (d.group == 4) {
                                    return("#808000");
                                }
                                if (d.group == 5) {
                                    return("#000080");
                                }
                                if (d.group == 6) {
                                    return("#800080");
                                }
                                if (d.group == 7) {
                                    return("#00ffff");
                                }
                                if (d.group == 8) {
                                    return("#F5F5DC");
                                }
                                if (d.group == 9) {
                                    return("#A52A2A");
                                }
                                if (d.group == 10) {
                                    return("#8B0000");
                                }
                                if (d.group == 11) {
                                    return("#FF8C00");
                                }

                            }
                            //return colNodeScale(d.group);
                        })
                        // .style("fill", function (d) {
                        //     return colNodeScale(d.group);
                        // })
                        .style("stroke", "#333")
                        .style("stroke-dasharray",
                            function (d) {
                                if (d.connected == "No") {
                                    ////console.log("not connected");
                                    return (5, 5);

                                }
                                else if(d.connected == "Yes") {
                                    ////console.log("connected");
                                    return (3, 0);
                                }
                            })
                        .style("stroke-width", "2px");
                    //.on("dblclick", dblclick);



                    // node.append("circle")
                    //     .attr("r", function (d) {
                    //         return xScale(d.weight);
                    //     })
                    //     .style("fill", function (d) {
                    //         if (d.group == 1) {
                    //             return colorScale(d.value);
                    //         }
                    //         else {
                    //             return colNodeScale(d.group);
                    //         }
                    //         //return colNodeScale(d.group);
                    //     })
                    //     .style("stroke", "#333")
                    //     .style("stroke-width", "2px");



                    function openLink() {
                        return function (d) {
                            var url = "";
                            if (d.slug != "") {
                                url = d.slug
                            } //else if(d.type == 2) {
                            //url = "clients/" + d.slug
                            //} else if(d.type == 3) {
                            //url = "agencies/" + d.slug
                            //}
                            window.open("//" + url)
                        }
                    };
                    node.append("svg:image")
                    //****************************************
                    //.attr("class", function(d){ return d.name })
                    //****************************************
                    //.attr("xlink:href", function(d){ return d.img_hrefD})
                        .attr("x", "-36px")
                        .attr("y", "-36px")
                        .attr("width", "70px")
                        .attr("height", "70px")
                    //.on("dblclick", openLink());

                    // .on("mouseover", function (d) { if(d.entity == "company")
                    // {
                    //     d3.select(this).attr("width", "90px")
                    //         .attr("x", "-46px")
                    //         .attr("y", "-36.5px")
                    //         .attr("xlink:href", function(d){ return d.img_hrefL});
                    // }
                    // })
                    // .on("mouseout", function (d) { if(d.entity == "company")
                    // {
                    //     d3.select(this).attr("width", "70px")
                    //         .attr("x", "-36px")
                    //         .attr("y", "-36px")
                    //         .attr("xlink:href", function(d){ return d.img_hrefD});
                    // }
                    // });


                    //.text(function(d) { return d.name })
                    node.append("svg:text")
                    //****************************************
                        .attr("class", function (d) {
                            return d.full_name
                        })
                        //****************************************
                        .attr("x", 16)
                        .attr("y", ".31em")
                        //.attr("class", "shadow")
                        //.style("font-size","10px")
                        // .attr("dx", 0)
                        // .attr("dy", ".35em")
                        //.style("font-size","12px")
                        //****************************************
                        //text.shadow {
                        .style("stroke", "#fff")
                        .style("stroke-width", "4px")
                        //}
                        //.attr("class", "shadow")
                        .style("font", String(fontValue) + "px Arial")
                        //.style("font", "14px Times New Roman")
                        //****************************************
                        //.attr("text-anchor", "middle")
                        //****************************************
                        .text(function (d) {
                            return d.full_name
                        });
                    //****************************************


                    //This one is for the actual text
                    node.append("svg:text")
                    //****************************************
                        .attr("class", function (d) {
                            return d.full_name
                        })
                        //****************************************
                        .attr("x", 16)
                        .attr("y", ".31em")
                        //.attr("class", "shadow")
                        //.style("font-size","10px")
                        // .attr("dx", 0)
                        // .attr("dy", ".35em")
                        //.style("font-size","12px")
                        //****************************************
                        //.style("font", "14px Times New Roman")
                        .style("font", String(fontValue) + "px Arial")
                        //****************************************
                        //.attr("text-anchor", "middle")
                        //****************************************
                        .text(function (d) {
                            return d.full_name
                        });
                    //****************************************


                    node.on("mouseover", function (d) {
                        // d3.select(this).select("text")
                        //     .transition()
                        //     .duration(300)
                        //     .text(function (d) {
                        //         return d.full_name;
                        //     })
                        // //.style("font-size", "15px")
                        // .style("font", "14px Times New Roman");
                        //
                        // d3.select(this).select("text")
                        //     .transition()
                        //     .duration(300)
                        //     .text(function (d) {
                        //         return d.full_name;
                        //     })
                        //     //.style("font-size", "15px")
                        //     //.attr("class", "shadow")
                        //     .style("font", "14px Times New Roman");
                        // d3.select(this).select("text")
                        //     .transition()
                        //     .duration(300)
                        //     .text(function (d) {
                        //         return d.full_name;
                        //     })
                        //
                        //     .style("fill",'black')
                        //     .style("font", "14px Times New Roman");

                        //d3.selectAll("text").remove();
                        //d3.select(this).style("stroke-width", 6);

                        //d3.select(this).select("text").style("stroke", "blue");

                        var nodeNeighbors = links.filter(function (link) {
                            // Filter the list of links to only those links that have our target
                            // node as a source or target
                            return link.source.index === d.index || link.target.index === d.index;
                        })
                            .map(function (link) {
                                // Map the list of links to a simple array of the neighboring indices - this is
                                // technically not required but makes the code below simpler because we can use
                                // indexOf instead of iterating and searching ourselves.
                                return link.source.index === d.index ? link.target.index : link.source.index;
                            });

                        d3.selectAll('circle').filter(function (node) {
                            // I filter the selection of all circles to only those that hold a node with an
                            // index in my listg of neighbors
                            return nodeNeighbors.indexOf(node.index) > -1;
                        })
                            .style('stroke', 'blue');

                        //d3.selectAll('text').filter(d).style('fill', 'blue');
                        //****************************
                        // d3.selectAll('text').filter(function(node) {
                        //     // I filter the selection of all circles to only those that hold a node with an
                        //     // index in my listg of neighbors
                        //     return nodeNeighbors.indexOf(node.index) > -1;
                        // }).style('fill', 'blue')
                        //     //.style("font-size", "16px")
                        //     //.style("font-weight", "bold");
                        // //****************************
                        path.style('stroke', function (l) {
                            if (d === l.source || d === l.target)
                                return "blue";
                            else
                                return "grey";
                        })

                        path.style('stroke-width', function (l) {
                            if (d === l.source || d === l.target)
                                return 2;
                            else
                                return 1;
                        })

                    })
                        .on("mouseout", function (d) {
                            d3.select(this).select("text")
                                .transition()
                                .duration(300)
                                .text(function (d) {

                                    return d.full_name;
                                });
                            // d3.select(this).select("text")
                            //     //*******************************
                            //     .style("font", "14px Times New Roman")
                            //     //*******************************
                            //     .style("font-size", "14px")
                            //     .style("fill",'black')
                            //     .style("font-weight", "normal");

                            // d3.select(this).select("text")
                            // //*******************************
                            //     .style("font", "14px Times New Roman")
                            //     //*******************************
                            //     .style("font-size", "14px")
                            //     .style("fill",'black')
                            //     .style("font-weight", "normal");
                            //d3.select(this).style("stroke", "black");
                            //d3.select(this).style("stroke-width", 1);
                            //d3.select(this).style("stroke", "#333");
                            path.style('stroke', "grey");
                            path.style('stroke-width', 1);
                            //circle.style('stroke', "grey");
                            //node.style("stroke-width", 3);
                            //node.style("stroke", "#333");
                            //d3.selectAll('text').style('fill', 'black')
                            // d3.selectAll('text').style('fill', 'black')
                            //     .style("font-weight", "normal");
                            //d3.selectAll("text").style("font-weight", "normal");
                            node.selectAll("circle").style("stroke-width", 3)
                                .style('stroke', "black");
                            //.style("font-size", "12px");
                            //}
                        });


                    function pythag(r, b, coord) {
                        r += nodeBaseRad;

                        // force use of b coord that exists in circle to avoid sqrt(x<0)
                        b = Math.min(w - r - strokeWidth, Math.max(r + strokeWidth, b));

                        var b2 = Math.pow((b - radius), 2),
                            a = Math.sqrt(hyp2 - b2);

                        function openLink() {
                            return function (d) {
                                var url = "";
                                if (d.slug != "") {
                                    url = d.slug
                                } //else if(d.type == 2) {
                                //url = "clients/" + d.slug
                                //} else if(d.type == 3) {
                                //url = "agencies/" + d.slug
                                //}
                                window.open("//" + url)
                            }
                        }

                        // radius - sqrt(hyp^2 - b^2) < coord < sqrt(hyp^2 - b^2) + radius
                        coord = Math.max(radius - a + r + strokeWidth,
                            Math.min(a + radius - r - strokeWidth, coord));

                        return coord;
                    }

                    function tick(e) {
                        path.attr("d", function (d) {
                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,

                                dr = Math.sqrt(dx * dx + dy * dy);
                            ////console.log(d.source.x);
                            // //console.log(d.target.x);
                            return "M" + d.source.x + "," + d.source.y + "," + d.target.x + "," + d.target.y;
                            //return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
                        });

                        node.attr('x', function (d) {
                            return d.x = pythag(Math.random() * 12, d.y, d.x);
                        })
                            .attr('y', function (d) {
                                return d.y = pythag(Math.random() * 12, d.x, d.y);
                            })
                            .attr("transform", function (d) {
                                return "translate(" + d.x + "," + d.y + ")"
                            });

                        //d3.select(this).classed("fixed", d.fixed = true);
                        // circle.attr("transform", function(d) {
                        //     return "translate(" + d.x + "," + d.y + ")";
                        // });
                        //************************************
                        // text.attr("transform", function(d) {
                        //     return "translate(" + d.x + "," + d.y + ")";
                        // });
                        //************************************
                    }

                    //For not moving after drag
                    var drag = force.drag()
                        .on("dragstart", dragstart);
                    //.on("dragstart", dragstartAll);

                    //For not moving after drag
                    function dblclick(d) {
                        d3.select(this).classed("fixed", d.fixed = false);

                    }

                    //For not moving after drag
                    function dragstart(d) {
                        d3.select(this).classed("fixed", d.fixed = true);

                        for (i = 0; i < nodes.length; i++) {
                            nodes[i].fixed = true;
                        }
                    }


                    var svgText = svg4.append("text");
                    svgText.attr("x",10).attr("y",globalHPlus50-50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);




                    var legend2 = svg4.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());
                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg4.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg4.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg4.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();

                    // For legend
                    // var colNodeScaleSeparateInfo = d3.scale.ordinal()
                    //     .range(["#767776", "#f91104"])
                    //     .domain(["Query Gene Set", "Pathways / Kinases Perturbation"]);
                    //
                    //
                    // var legend = svg.selectAll(".legend")
                    //     .data(colNodeScaleSeparateInfo.domain())
                    //     .enter().append("g")
                    //     .attr("class", "legend")
                    //     .attr("transform", function (d, i) {
                    //         return "translate(0," + (i) * 25 + ")";
                    //     });
                    //
                    // legend.append("rect")
                    //     .attr("x", w - 25)
                    //     .attr("width", 25)
                    //     .attr("height", 25)
                    //     .style("fill", colNodeScaleSeparateInfo);
                    //
                    // legend.append("text")
                    //     .attr("x", w - 35)
                    //     .attr("y", 12.5)
                    //     .attr("dy", ".35em")
                    //     .style("text-anchor", "end")
                    //     .text(function (d) {
                    //         return d;
                    //     });
                    //
                    //
                    // d3.select("#download").on("click", function () {
                    //     d3.select(this)
                    //         .attr("href", 'data:application/octet-stream;base64,' + btoa(d3.select("#chart").html()))
                    //         .attr("download", "pathway_network.svg")
                    // })

                };

                //defaultSVGPtm();
                //SharedService.setVar('svg', svg);






                d3.select('#force4').on('click', function () {
                    defaultView4();
                    $scope.graphType4ptm = 0;
                });
                d3.select('#parallelView4').on('click', function () {
                    parallelView4();
                    $scope.graphType4ptm = 1;
                });
                d3.select('#circosView4').on('click', function (){
                    circosView4();
                    $scope.graphType4ptm = 2;
                });
                d3.select('#circularView4').on('click', function (){
                    circularView4();
                    $scope.graphType4ptm = 3;
                });


                if(graphType == 0){
                    defaultView4();
                }
                else if(graphType == 1){
                    parallelView4();
                }
                else if(graphType == 2){
                    circosView4();
                }
                else if(graphType == 3){
                    circularView4();
                }



                d3.select("#download-svg4").on("click", function ()  {
                    var name = 'PiNET-SIGNOR-Graph.svg';
                    var svgEl = svg4.node();
                    svgEl.setAttribute("xmlns", "http://www.w3.org/2000/svg");
                    var svgData = svgEl.outerHTML;
                    var preface = '<?xml version="1.0" standalone="no"?>\r\n';
                    var svgBlob = new Blob([preface, svgData], {type:"image/svg+xml;charset=utf-8"});
                    var svgUrl = URL.createObjectURL(svgBlob);
                    var downloadLink = document.createElement("a");
                    downloadLink.href = svgUrl;
                    downloadLink.download = name;
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                })




//             d3.select('#drug1').on('click', function () {
//                 svg.remove();
//
//                 //xPosition.domain(d3.extent(nodes, function (d) { return d.text; }));
//                 xScale.domain(d3.extent(nodes, function (d) {
//                     return d.weight;
//                 }));
//                 colNodeScale.domain(d3.extent(nodes, function (d) {
//                     return d.group;
//                 }));
//                 colScale.domain(d3.extent(links, function (d) {
//                     return d.weight;
//                 }));
//                 textPlacePlusMinus.domain(d3.extent(nodes, function (d) {
//                     return d.group;
//                 }));
//                 textPlaceStartEnd.domain(d3.extent(nodes, function (d) {
//                     return d.group;
//                 }));
//
//                 var drug_data = {
//                     "nodes": [{"full_name": "PRKCG", "weight": 0, "idx": 0, "group": 1},
//                         {"full_name": "YWHAZ", "weight": 0, "idx": 1, "group": 1},
//                         {"full_name": "ALB", "weight": 0, "idx": 2, "group": 1},
//                         {"full_name": "NSF", "weight": 0, "idx": 3, "group": 1},
//                         {"full_name": "FGA", "weight": 0, "idx": 4, "group": 1},
//                         {"full_name": "VCAN", "weight": 0, "idx": 5, "group": 1},
//                         {"full_name": "AK5", "weight": 0, "idx": 6, "group": 1},
//                         {"full_name": "CAMK2A", "weight": 0, "idx": 7, "group": 1},
//                         {"full_name": "LANCL1", "weight": 0, "idx": 8, "group": 1},
//                         {"full_name": "PRKCB", "weight": 0, "idx": 9, "group": 1},
//                         {"full_name": "CAMK2B", "weight": 0, "idx": 10, "group": 1},
//                         {"full_name": "TUBA1A", "weight": 0, "idx": 11, "group": 1},
//                         {"full_name": "CKB", "weight": 0, "idx": 12, "group": 1},
//                         {"full_name": "TUBB2A", "weight": 0, "idx": 13, "group": 1},
//                         {"full_name": "ACTB", "weight": 0, "idx": 14, "group": 1},
//                         {"full_name": "CAMK2D", "weight": 0, "idx": 15, "group": 1},
//                         {"full_name": "FGG", "weight": 0, "idx": 16, "group": 1},
//                         {"full_name": "APOE", "weight": 0, "idx": 17, "group": 1},
//                         {"full_name": "fluphenazine", "weight": 0, "idx": 18, "group": 2},
//                         {"full_name": "mesoridazine", "weight": 0, "idx": 19, "group": 2},
//                         {"full_name": "thioproperazine", "weight": 0, "idx": 20, "group": 2},
//                         {"full_name": "thioridazine", "weight": 0, "idx": 21, "group": 2},
//                         {"full_name": "trifluoperazine", "weight": 0, "idx": 22, "group": 2}],
//                     "edges": [{"source": 0, "target": 18}, {"source": 0, "target": 21}, {"source": 0, "target": 22},
//                         {"source": 3, "target": 19}, {"source": 3, "target": 20}, {
//                             "source": 3,
//                             "target": 21
//                         }, {"source": 3, "target": 22},
//                         {"source": 4, "target": 19}, {"source": 4, "target": 20}, {
//                             "source": 4,
//                             "target": 21
//                         }, {"source": 4, "target": 22},
//                         {"source": 5, "target": 18}, {"source": 5, "target": 19}, {
//                             "source": 5,
//                             "target": 21
//                         }, {"source": 5, "target": 22},
//                         {"source": 7, "target": 18}, {"source": 7, "target": 21}, {"source": 7, "target": 22},
//                         {"source": 9, "target": 18}, {"source": 9, "target": 21}, {"source": 9, "target": 22},
//                         {"source": 10, "target": 19}, {"source": 10, "target": 20},
//                         {"source": 11, "target": 18}, {"source": 11, "target": 21}, {"source": 11, "target": 22},
//                         {"source": 12, "target": 19}, {"source": 12, "target": 21}, {"source": 12, "target": 22},
//                         {"source": 13, "target": 18}, {"source": 13, "target": 21}, {"source": 13, "target": 22},
//                         {"source": 15, "target": 18}, {"source": 15, "target": 22},
//                         {"source": 17, "target": 22}]
//                 };
//
//                 var margin = 75,
//                     w = 750 - 2 * margin,
//                     h = w,
//                     radius = w / 2,
//                     strokeWidth = 4,
//                     hyp2 = Math.pow(radius, 2),
//                     nodeBaseRad = 5;
//
//
//                 nodes = drug_data.nodes;
//                 links = drug_data.edges;
//                 svg = d3.select("#chart")
//                     .append("svg")
//                     .attr("style", "outline: thin solid yellow;")
//                     .attr("width", w)
//                     .attr("height", h);
//
//                 svg.append("rect")
//                     .attr("width", "100%")
//                     .attr("height", "100%")
//                     .attr("fill", "white");
//
//
//                 var force = d3.layout.force()
//                     .nodes(nodes)
//                     .links(links)
//                     .size([w, h]);
//
//
//                 var parallelCoordx = function (group) {
//
//                     if (group == 1) {
//                         return w * 2 / 3;
//                     }
//                     else {
//                         return w / 2.2;
//                     }
//                 }
//
//                 var parallelCoordy = function (index, num_nodes) {
//                     var dist = h / (num_nodes + 1);
//
//                     return (index + 1) * dist;
//                 }
//
//                 var is_connected = function (d, opacity) {
//                     lines.transition().style("stroke-opacity", function (o) {
//                         return o.source === d || o.target === d ? 1 : opacity;
//                     });
//                 }
//
//                 //var dim = w-80
//                 // var circle = svg.append("path")
//                 //     .attr("d", "M 40, "+(dim/2+40)+" a "+dim/2+","+dim/2+" 0 1,0 "+dim+",0 a "+dim/2+","+dim/2+" 0 1,0 "+dim*-1+",0")
//                 //     .style("fill", "#f5f5f5");
//
//                 force.start();
//
//
//                 // //console.log(nodes.length);
//                 var groupId = [];
//                 var maxId = 0;
//                 for (var i = 0; i < nodes.length; i++) {
//                     var item = nodes[i];
//
//                     if (!groupId[item.group]) {
//                         groupId[item.group] = [];
//                     }
//
//                     groupId[item.group].push({name: item.name});
//                     // //console.log(item.group);
//                     // //console.log(groupId[item.group]);
//                     if (maxId < item.group) {
//                         maxId = item.group;
//                     }
//                 }
//                 // //console.log(maxId);
//                 // //console.log(groupId[1].length);
//                 // //console.log(groupId[2].length);
//
//                 n1 = 0;
//                 n2 = 0;
//
//                 nodes.forEach(function (n, i) {
//                     var item = nodes[i];
//
//                     if (n.group == 1) {
//                         n.x = parallelCoordx(n.group)
//                         n.y = parallelCoordy(n1, groupId[1].length)
//                         n1 = n1 + 1;
//                     }
//                     if (n.group == 2) {
//                         n.x = parallelCoordx(n.group)
//                         n.y = parallelCoordy(n2, groupId[2].length)
//                         n2 = n2 + 1;
//                     }
//
//                 });
//
//
//                 var lines = svg.selectAll("path.node-link")
//                     .data(links).enter().append("path")
//                     .style("fill", "none")
//                     .style("stroke", "#726363")
//                     .attr("class", "node-link")
//                     .attr("d", function (d) {
//                         var dx = d.target.x - d.source.x,
//                             dy = d.target.y - d.source.y,
//                             dr = Math.sqrt(dx * dx + dy * dy);
//                         return "M" +
//                             d.source.x + "," +
//                             d.source.y + "," +
//                             d.target.x + "," +
//                             d.target.y;
//                     });
//
//
//                 var gnodes = svg.selectAll('g.gnode')
//                     .data(nodes).enter().append('g')
//                     .attr("transform", function (d) {
//                         return "translate(" + d.x + "," + d.y + ")"
//                     })
//                     .classed('gnode', true);
//
//
// //to include molecule figure substitute this
//                 var node = gnodes.append("circle")
//                     .attr("r", function (d) {
//                         return xScale(d.weight);
//                     })
//                     .style("fill", function (d) {
//                         return colNodeScale(d.group);
//                     })
//                     .style("stroke", "#333")
//                     .style("stroke-width", "2px")
//                     //.attr("class", "node")
//                     .on("mouseenter", function (d) {
//                         is_connected(d, 0.1)
//                         node.transition().duration(100).attr("r", function (d) {
//                             return xScale(d.weight);
//                         })
//                         d3.select(this).transition().duration(100).attr("r", function (d) {
//                             return xScale(d.weight + 10);
//                         })
//                     })
//                     .on("mouseleave", function (d) {
//                         node.transition().duration(100).attr("r", function (d) {
//                             return xScale(d.weight);
//                         })
//                         is_connected(d, 1);
//                     })
//                     .call(force.drag);
//
//
//                 // gnodes.append("image")
//                 //     .attr("xlink:href", function(d) { return d.group < 2 ? "images/molecule-icon.png" : "images/pathway.png"; })
//                 //     .attr("x", -8)
//                 //     .attr("y", -8)
//                 //     .attr("width", 16)
//                 //     .attr("height", 16);
//
//
//                 var labels = gnodes.append("text")
//
//                     .attr("dx", function (d) {
//                         return textPlacePlusMinus(d.group);
//                     })
//                     .attr("dy", 4)
//                     .attr("text-anchor", function (d) {
//                         return textPlaceStartEnd(d.group);
//                     })
//                     .text(function (d) {
//                         return d.full_name
//                     })
//
//             });
//
//             d3.select('#customizedParallelView1').on('click', function () {
//                 svg.remove();
//
//
//                 var margin = {top: 75, right: 75, bottom: 75, left: 75}, cus
//                 width = 1550 - margin.left - margin.right,
//                     height = 1550 - margin.top - margin.bottom;
//
//                 var x = d3.scale.ordinal().rangePoints([0, width], 1),
//                     y = {},
//                     dragging = {};
//
//                 var line = d3.svg.line(),
//                     axis = d3.svg.axis().orient("left"),
//                     background,
//                     foreground;
//
//
//                 svg = d3.select("#chart").append("svg")
//                     .attr("width", width + margin.left + margin.right)
//                     .attr("style", "outline: thin solid yellow;")
//                     .attr("height", height + margin.top + margin.bottom)
//                     .append("g")
//                     .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
//
//                 var margin = 75,
//                     w = 1550 - 2 * margin,
//                     h = w,
//                     radius = w / 2,
//                     strokeWidth = 4,
//                     hyp2 = Math.pow(radius, 2),
//                     nodeBaseRad = 5;
//
//                 var data = parallelLayout;
//
//
//                 x.domain(dimensions = d3.keys(data[0]).filter(function (d) {
//
//                     if (d === "name") return false;
//
//                     else {
//                         y[d] = d3.scale.ordinal()
//                             .domain(data.map(function (p) {
//                                 return p[d];
//                             }))
//                             .rangePoints([height, 0]);
//
//                     }
//                     //else {
//                     //    y[d] = d3.scale.linear()
//                     //      .domain(d3.extent(data, function(p) { return +p[d]; }))
//                     //      .range([h, 0]);
//                     //}
//
//                     return true;
//                 }));
//
//                 background = svg.append("g")
//                     .style("fill", "none")
//                     .style("stroke", "#ddd")
//                     .style("shape-rendering", "crispEdges")
//
//                     .selectAll("path")
//                     .data(data)
//                     .enter().append("path")
//                     .attr("d", path);
//
//                 // Add blue foreground lines for focus.
//                 foreground = svg.append("g")
//                     .style("fill", "none")
//                     .style("stroke", "steelblue")
//                     //.style("shape-rendering", "crispEdges")
//                     .selectAll("path")
//                     .data(data)
//                     .enter().append("path")
//                     .attr("d", path);
//
// // Add a group element for each dimension.
//                 var g = svg.selectAll(".dimension")
//                     .data(dimensions)
//                     .enter().append("g")
//                     .attr("class", "dimension")
//                     .attr("transform", function (d) {
//                         return "translate(" + x(d) + ")";
//                     })
//                     .call(d3.behavior.drag()
//                         .origin(function (d) {
//                             return {x: x(d)};
//                         })
//                         .on("dragstart", function (d) {
//                             dragging[d] = x(d);
//                             background.attr("visibility", "hidden");
//                         })
//                         .on("drag", function (d) {
//                             dragging[d] = Math.min(width, Math.max(0, d3.event.x));
//                             foreground.attr("d", path);
//                             dimensions.sort(function (a, b) {
//                                 return position(a) - position(b);
//                             });
//                             x.domain(dimensions);
//                             g.attr("transform", function (d) {
//                                 return "translate(" + position(d) + ")";
//                             })
//                         })
//                         .on("dragend", function (d) {
//                             delete dragging[d];
//                             transition(d3.select(this)).attr("transform", "translate(" + x(d) + ")");
//                             transition(foreground).attr("d", path);
//                             background
//                                 .attr("d", path)
//                                 .transition()
//                                 .delay(500)
//                                 .duration(0)
//                                 .attr("visibility", null);
//                         }));
//
//                 // Add an axis and title.
//                 g.append("g")
//                     .style("fill", "none")
//                     .style("stroke", "black")
//                     //.style("stroke-width","#000")
//                     //.style("fill", "none")
//                     .style("stroke-width", "1")
//                     .style("shape-rendering", "crispEdges")
//                     //.style("shape-rendering","crispEdges")
//                     // fill: none;
//                     // stroke: #000;
//                     // shape-rendering: crispEdges;
//                     //.attr("class", "axis")
//                     .each(function (d) {
//                         d3.select(this).call(axis.scale(y[d]));
//                     })
//                     .append("text")
//                     .style("font", "13px Times New Roman")
//                     .style("text-anchor", "middle")
//                     .attr("y", -9)
//                     .text(function (d) {
//                         return d;
//                     });
//
//                 // Add and store a brush for each axis.
//                 g.append("g")
//
//                 // fill-opacity: .3;
//                 // stroke: #fff;
//                 // shape-rendering: crispEdges;
//                 //.attr("class", "brush")
//                     .each(function (d) {
//                         d3.select(this).call(y[d].brush = d3.svg.brush().y(y[d]).on("brushstart", brushstart).on("brush", brush));
//                     })
//                     .selectAll("rect")
//                     .attr("x", -8)
//                     .style("fill-opacity", ".3")
//                     .style("stroke", "#fff")
//                     .style("shape-rendering", "crispEdges")
//                     .attr("width", 16);
//
// //Added from here========================================
//
//
//                 var projection = svg.selectAll(".foreground path")
//                     .on("mouseover", mouseover)
//                     .on("mouseout", mouseout);
//
//                 function mouseover(d) {
//                     //svg.classed("active", false);
//                     projection.classed("inactive", function (p) {
//                         return p !== d;
//                     });
//                     projection.classed("active", function (p) {
//                         return p === d;
//                     });
//                     //projection.filter(function(p) { return p === d; }).each(moveToFront);
//                 }
//
//                 function mouseout(d) {
//
//                     //projection.classed("inactive", function(p) { return p !== d; });
//                     projection.classed("active");
//
//                 }
//
//                 function position(d) {
//                     var v = dragging[d];
//                     return v == null ? x(d) : v;
//                 }
//
//                 function transition(g) {
//                     return g.transition().duration(500);
//                 }
//
//                 function path(d) {
//                     return line(dimensions.map(function (p) {
//                         return [position(p), y[p](d[p])];
//                     }));
//                 }
//
//                 function brushstart() {
//                     d3.event.sourceEvent.stopPropagation();
//                 }
//
// // Handles a brush event, toggling the display of foreground lines.
//                 function brush() {
//                     var actives = dimensions.filter(function (p) {
//                             return !y[p].brush.empty();
//                         }),
//                         extents = actives.map(function (p) {
//                             return y[p].brush.extent();
//                         });
//                     foreground.style("display", function (d) {
//                         return actives.every(function (p, i) {
//
//                             return extents[i][0] <= y[p](d[p]) && y[p](d[p]) <= extents[i][1];
// //This one is for numeric
//                             //return extents[i][0] <= d[p] && d[p] <= extents[i][1];
//                         }) ? null : "none";
//                     });
//                 }
//
//
//             });
//
//             d3.select('#customizedCircularView1').on('click', function () {
//
//                 svg.remove();
//                 var diameter = 1200;
//                 svg = d3.select("#chart").append("svg")
//                     .attr("width", diameter)
//                     .attr("height", diameter)
//                     .attr("style", "outline: thin solid yellow;")
//                     .append("g")
//                     .attr("transform", "translate(" + diameter / 2 + "," + diameter / 2 + ")");
//
//                 var outer = d3.map();
//                 var inner = [];
//                 var links = [];
//                 var outerId = [0];
//                 var data = circularLayout;
//                 //console.log(data);
//                 data.forEach(function (d) {
//
//                     if (d == null)
//                         return;
//
//                     i = {id: 'i' + inner.length, name: d[0], related_links: []};
//                     i.related_nodes = [i.id];
//                     inner.push(i);
//
//                     if (!Array.isArray(d[1]))
//                         d[1] = [d[1]];
//
//                     d[1].forEach(function (d1) {
//
//                         o = outer.get(d1);
//
//                         if (o == null) {
//                             o = {name: d1, id: 'o' + outerId[0], related_links: []};
//                             o.related_nodes = [o.id];
//                             outerId[0] = outerId[0] + 1;
//
//                             outer.set(d1, o);
//                         }
//
//                         // create the links
//                         l = {id: 'l-' + i.id + '-' + o.id, inner: i, outer: o}
//                         links.push(l);
//
//                         // and the relationships
//                         i.related_nodes.push(o.id);
//                         i.related_links.push(l.id);
//                         o.related_nodes.push(i.id);
//                         o.related_links.push(l.id);
//                     });
//                 });
//                 data = {
//                     inner: inner,
//                     outer: outer.values(),
//                     links: links
//                 }
// // sort the data -- TODO: have multiple sort options
//                 outer = data.outer;
//                 data.outer = Array(outer.length);
//                 var i1 = 0;
//                 var i2 = outer.length - 1;
//                 for (var i = 0; i < data.outer.length; ++i) {
//                     if (i % 2 == 1)
//                         data.outer[i2--] = outer[i];
//                     else
//                         data.outer[i1++] = outer[i];
//                 }
//                 //console.log(data.outer.reduce(function (a, b) {
//                         return a + b.related_links.length;
//                     }, 0) / data.outer.length);
// // from d3 colorbrewer:
// // This product includes color specifications and designs developed by Cynthia Brewer (http://colorbrewer.org/).
//                 //var colors = ["#a50026","#d73027","#f46d43","#fdae61","#fee090","#ffffbf","#e0f3f8","#abd9e9","#74add1","#4575b4","#313695"]
//                 // var color = d3.scale.linear()
//                 //     .domain([60, 220])
//                 //     .range([colors.length-1, 0])
//                 //     .clamp(true);
//
//
//                 var rect_width = 100;
//                 var rect_height = 20;
//                 var link_width = "1px";
//                 var il = data.inner.length;
//                 var ol = data.outer.length;
//                 var inner_y = d3.scale.linear()
//                     .domain([0, il])
//                     .range([-(il * rect_height) / 2, (il * rect_height) / 2]);
//                 mid = (data.outer.length / 2.0)
//                 var outer_x = d3.scale.linear()
//                     .domain([0, mid, mid, data.outer.length])
//                     .range([15, 170, 190, 355]);
//                 var outer_y = d3.scale.linear()
//                     .domain([0, data.outer.length])
//                     .range([0, diameter / 2 - 150]);
// // setup positioning
//                 data.outer = data.outer.map(function (d, i) {
//                     d.x = outer_x(i);
//                     d.y = diameter / 3;
//                     return d;
//                 });
//                 data.inner = data.inner.map(function (d, i) {
//                     d.x = -(rect_width / 2);
//                     d.y = inner_y(i);
//                     return d;
//                 });
//                 function get_color(name) {
//                     // var c = Math.round(color(name));
//                     // if (isNaN(c))
//                     //     return '#dddddd';	// fallback color
//                     //
//                     // return colors[c];
//
//
//                     return '#a39c9c';
//                 }
//
// // Can't just use d3.svg.diagonal because one edge is in normal space, the
// // other edge is in radial space. Since we can't just ask d3 to do projection
// // of a single point, do it ourselves the same way d3 would do it.
//                 function projectX(x) {
//                     return ((x - 90) / 180 * Math.PI) - (Math.PI / 2);
//                 }
//
//                 var diagonal = d3.svg.diagonal()
//                     .source(function (d) {
//                         return {
//                             "x": d.outer.y * Math.cos(projectX(d.outer.x)),
//                             "y": -d.outer.y * Math.sin(projectX(d.outer.x))
//                         };
//                     })
//                     .target(function (d) {
//                         return {
//                             "x": d.inner.y + rect_height / 2,
//                             "y": d.outer.x > 180 ? d.inner.x : d.inner.x + rect_width
//                         };
//                     })
//                     .projection(function (d) {
//                         return [d.y, d.x];
//                     });
//
//                 // svg = d3.select("#chart")
//                 //     .append("svg")
//                 //     .attr("style", "outline: thin solid yellow;")
//                 //     .attr("width", w)
//                 //     .attr("height", h);
//
//
// // links
//                 var link = svg.append('g')
//                 //.attr('class', 'links')
//                     .selectAll(".link")
//                     .data(data.links)
//                     .enter().append('path')
//                     .style('fill', 'none')
//                     .attr('id', function (d) {
//                         return d.id
//                     })
//                     .attr("d", diagonal)
//                     .attr('stroke', function (d) {
//                         return get_color(d.inner.name);
//                     })
//                     .attr('stroke-width', link_width);
// // outer nodes
//                 var onode = svg.append('g').selectAll(".outer_node")
//                     .data(data.outer)
//                     .enter().append("g")
//                     .style("stroke", "#315B7E")
//                     .style("stroke-width", "2px")
//
//                     // .attr("class", "outer_node")
//                     .attr("transform", function (d) {
//                         return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")";
//                     })
//                     .on("mouseover", mouseover)
//                     .on("mouseout", mouseout);
//
//                 onode.append("circle")
//                     .attr('id', function (d) {
//                         return d.id
//                     })
//                     .attr("r", 4.5);
//
//                 onode.append("circle")
//                     .attr('r', 20)
//                     .attr('visibility', 'hidden');
//
//                 onode.append("text")
//                     .attr('id', function (d) {
//                         return d.id + '-txt';
//                     })
//                     .attr("dy", ".31em")
//                     .style("stroke", "black")
//                     .style("font-weight", "normal")
//                     .style("font", "13px Times New Roman")
//                     .attr("text-anchor", function (d) {
//                         return d.x < 180 ? "start" : "end";
//                     })
//                     .attr("transform", function (d) {
//                         return d.x < 180 ? "translate(8)" : "rotate(180)translate(-8)";
//                     })
//                     .text(function (d) {
//                         return d.name;
//                     });
//
// // inner nodes
//
//                 var inode = svg.append('g').selectAll(".inner_node")
//                     .data(data.inner)
//                     .enter().append("g")
//                     .style("stroke", "#315B7E")
//                     .style("stroke-width", "2px")
//
//                     //.attr("class", "inner_node")
//                     .attr("transform", function (d, i) {
//                         return "translate(" + d.x + "," + d.y + ")"
//                     })
//                     .on("mouseover", mouseover)
//                     .on("mouseout", mouseout);
//
//                 inode.append('rect')
//                     .attr('width', rect_width)
//                     .attr('height', rect_height)
//                     .attr('id', function (d) {
//                         return d.id;
//                     })
//                     .attr('fill', function (d) {
//                         return get_color(d.name);
//                     });
//
//                 inode.append("text")
//                     .attr('id', function (d) {
//                         return d.id + '-txt';
//                     })
//                     .attr('text-anchor', 'middle')
//                     .style("stroke", "#315B7E")
//                     .style("font-weight", "normal")
//                     .style("font", "13px Times New Roman")
//                     .attr("transform", "translate(" + rect_width / 2 + ", " + rect_height * .75 + ")")
//                     .text(function (d) {
//                         return d.name;
//                     });
// // need to specify x/y/etc
//                 d3.select(self.frameElement).style("height", diameter - 150 + "px");
//                 function mouseover(d) {
//                     // bring to front
//                     d3.selectAll('.links .link').sort(function (a, b) {
//                         return d.related_links.indexOf(a.id);
//                     });
//
//                     for (var i = 0; i < d.related_nodes.length; i++) {
//                         d3.select('#' + d.related_nodes[i]).classed('highlight', true);
//                         d3.select('#' + d.related_nodes[i] + '-txt').attr("font-weight", 'bold');
//                     }
//
//                     for (var i = 0; i < d.related_links.length; i++)
//                         d3.select('#' + d.related_links[i]).attr('stroke-width', '5px');
//                 }
//
//                 function mouseout(d) {
//                     for (var i = 0; i < d.related_nodes.length; i++) {
//                         d3.select('#' + d.related_nodes[i]).classed('highlight', false);
//                         d3.select('#' + d.related_nodes[i] + '-txt').attr("font-weight", 'normal');
//                     }
//
//                     for (var i = 0; i < d.related_links.length; i++)
//                         d3.select('#' + d.related_links[i]).attr('stroke-width', link_width);
//                 }
//
//             });
                // Set-up the export button
                d3.select('#download-png4').on('click', function () {
                    var svgString = getSVGString(svg4.node());

                    svgString2Image(svgString, 4 * globalW, 4 * globalHPlus50, 'png', save); // passes Blob and filesize String to the callback

                    function save(dataBlob, filesize) {
                        saveAs(dataBlob, 'Pinet-iPTMnet-Graph.png'); // FileSaver.js function
                    }
                });
                d3.select('#saveButton').on('click', function () {
                    var svgString = getSVGString(svg4.node());

                    svgString2Image(svgString, 4 * 1550, 4 * 1550, 'png', save); // passes Blob and filesize String to the callback

                    function save(dataBlob, filesize) {
                        saveAs(dataBlob, 'PiNET-iPTMnet-Graph.png'); // FileSaver.js function
                    }
                });

// Below are the functions that handle actual exporting:
// getSVGString ( svgNode ) and svgString2Image( svgString, width, height, format, callback )
                function getSVGString(svgNode) {
                    svgNode.setAttribute('xlink', 'http://www.w3.org/1999/xlink');
                    var cssStyleText = getCSSStyles(svgNode);
                    appendCSS(cssStyleText, svgNode);

                    var serializer = new XMLSerializer();
                    var svgString = serializer.serializeToString(svgNode);
                    svgString = svgString.replace(/(\w+)?:?xlink=/g, 'xmlns:xlink='); // Fix root xlink without namespace
                    svgString = svgString.replace(/NS\d+:href/g, 'xlink:href'); // Safari NS namespace fix

                    return svgString;

                    function getCSSStyles(parentElement) {
                        var selectorTextArr = [];

                        // Add Parent element Id and Classes to the list
                        selectorTextArr.push('#' + parentElement.id);
                        for (var c = 0; c < parentElement.classList.length; c++)
                            if (!contains('.' + parentElement.classList[c], selectorTextArr))
                                selectorTextArr.push('.' + parentElement.classList[c]);

                        // Add Children element Ids and Classes to the list
                        var nodes = parentElement.getElementsByTagName("*");
                        for (var i = 0; i < nodes.length; i++) {
                            var id = nodes[i].id;
                            if (!contains('#' + id, selectorTextArr))
                                selectorTextArr.push('#' + id);

                            var classes = nodes[i].classList;
                            for (var c = 0; c < classes.length; c++)
                                if (!contains('.' + classes[c], selectorTextArr))
                                    selectorTextArr.push('.' + classes[c]);
                        }

                        // Extract CSS Rules
                        var extractedCSSText = "";
                        for (var i = 0; i < document.styleSheets.length; i++) {
                            var s = document.styleSheets[i];

                            try {
                                if (!s.cssRules) continue;
                            } catch (e) {
                                if (e.name !== 'SecurityError') throw e; // for Firefox
                                continue;
                            }

                            var cssRules = s.cssRules;
                            for (var r = 0; r < cssRules.length; r++) {
                                if (contains(cssRules[r].selectorText, selectorTextArr))
                                    extractedCSSText += cssRules[r].cssText;
                            }
                        }


                        return extractedCSSText;

                        function contains(str, arr) {
                            return arr.indexOf(str) === -1 ? false : true;
                        }

                    }

                    function appendCSS(cssText, element) {
                        var styleElement = document.createElement("style");
                        styleElement.setAttribute("type", "text/css");
                        styleElement.innerHTML = cssText;
                        var refNode = element.hasChildNodes() ? element.children[0] : null;
                        element.insertBefore(styleElement, refNode);
                    }
                }


                function svgString2Image(svgString, width, height, format, callback) {
                    var format = format ? format : 'png';

                    var imgsrc = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgString))); // Convert SVG string to data URL

                    var canvas = document.createElement("canvas");
                    var context = canvas.getContext("2d");

                    canvas.width = width;
                    canvas.height = height;

                    var image = new Image();
                    image.onload = function () {
                        context.clearRect(0, 0, width, height);
                        context.drawImage(image, 0, 0, width, height);

                        canvas.toBlob(function (blob) {
                            var filesize = Math.round(blob.length / 1024) + ' KB';
                            if (callback) callback(blob, filesize);
                        });


                    };

                    image.src = imgsrc;
                }


                // d3.select("#download").on("click", function(){
                //     var html = d3.select("svg")
                //         .attr("version", 1.1)
                //         .attr("xmlns", "http://www.w3.org/2000/svg")
                //         .node().parentNode.innerHTML;
                //
                //     ////console.log(html);
                //     var imgsrc = 'data:image/svg+xml;base64,'+ btoa(html);
                //     var img = '<img src="'+imgsrc+'">';
                //     d3.select("#svgdataurl").html(img);
                //
                //
                //     var canvas = document.querySelector("canvas"),
                //         context = canvas.getContext("2d");
                //
                //     var image = new Image;
                //     image.src = imgsrc;
                //     image.onload = function() {
                //         context.drawImage(image, 0, 0);
                //
                //         var canvasdata = canvas.toDataURL("image/png");
                //
                //         var pngimg = '<img src="'+canvasdata+'">';
                //         d3.select("#pngdataurl").html(pngimg);
                //
                //         var a = document.createElement("a");
                //         a.download = "sample.png";
                //         a.href = canvasdata;
                //         a.click();
                //     };
                //
                // });


            }


            // //console.log(network.parallel);
            // //console.log(network.circular);
            // update(network.nodes, network.edges, network.parallel, network.circular);
            //console.log(network.nodes);
            //console.log(ptmToAbundance);
            for (var iterNetNode = 0; iterNetNode < network.nodes.length; iterNetNode++)
            {
                var iterNetNodeKey = network.nodes[iterNetNode]["name"];
                if (iterNetNodeKey in ptmToAbundance)
                {
                    //console.log(iterNetNodeKey);
                    if (ptmToAbundance[iterNetNodeKey] == "NA")
                    {
                        network.nodes[iterNetNode]["value"] = 0.0;
                    }
                    else {
                        network.nodes[iterNetNode]["value"] = ptmToAbundance[iterNetNodeKey];
                    }
                }
            }
            //console.log(self.computeWeightForupdatePtm);
            if(self.computeWeightForUpdatePtm) {
                //console.log("---  inside computeWeightForUpdatePtm");
                for (var iterNetNode = 0; iterNetNode < network.edges.length; iterNetNode++) {
                    //var iterNetNodeKey = network.nodes[iterNetNode]["name"];
                    var idx1 = network.edges[iterNetNode]["source"];
                    var idx2 = network.edges[iterNetNode]["target"];
                    network.nodes[idx1]["weight"] += 1;
                    network.nodes[idx2]["weight"] += 1;

                }
                self.computeWeightForUpdatePtm = false;
                SharedService.setVar('computeWeightForUpdatePtm',self.computeWeightForUpdatePtm);
            }
            //console.log(network);
            updatePtm(network.nodes, network.edges, graphType, circleSliderValue, nodeSliderValue, fontSliderValue, widthSliderValue);


            self.showPtmGraph = true;
        }
    }







    $scope.graphType4phos = 1;
    $scope.circleSliderValue4phos = 1100;
    $scope.nodeSliderValue4phos = 15;
    $scope.fontSliderValue4phos = 14;
    $scope.widthSliderValue4phos = 1500;
    $(document).on('input', '#circle_slider4phos', function() {
        $('#circle_slider_value4phos').html( $(this).val() );
        ////console.log($(this).val());
        $scope.circleSliderValue4phos = $(this).val();

        $scope.$apply();
        $scope.makePhosphoGraph(self.phosphoNetwork, self.ptmProteinToAbundanceMap, $scope.graphType4phos, $scope.circleSliderValue4phos, $scope.nodeSliderValue4phos, $scope.fontSliderValue4phos, $scope.widthSliderValue4phos);

    });

    $(document).on('input', '#node_slider4phos', function() {
        $('#node_slider_value4phos').html( $(this).val() );
        ////console.log($(this).val());
        $scope.nodeSliderValue4phos = $(this).val();

        $scope.$apply();

        $scope.makePhosphoGraph(self.phosphoNetwork, self.ptmProteinToAbundanceMap, $scope.graphType4phos, $scope.circleSliderValue4phos, $scope.nodeSliderValue4phos, $scope.fontSliderValue4phos, $scope.widthSliderValue4phos);

    });

    $(document).on('input', '#font_slider4phos', function() {
        $('#font_slider_value4phos').html( $(this).val() );
        ////console.log($(this).val());
        $scope.fontSliderValue4phos = $(this).val();

        $scope.$apply();

        $scope.makePhosphoGraph(self.phosphoNetwork, self.ptmProteinToAbundanceMap, $scope.graphType4phos, $scope.circleSliderValue4phos, $scope.nodeSliderValue4phos, $scope.fontSliderValue4phos, $scope.widthSliderValue4phos);

    });

    $(document).on('input', '#width_slider4phos', function() {
        $('#width_slider_value4phos').html( $(this).val() );
        ////console.log($(this).val());
        $scope.widthSliderValue4phos = $(this).val();

        $scope.$apply();

        $scope.makePhosphoGraph(self.phosphoNetwork, self.ptmProteinToAbundanceMap, $scope.graphType4phos, $scope.circleSliderValue4phos, $scope.nodeSliderValue4phos, $scope.fontSliderValue4phos, $scope.widthSliderValue4phos);

    });


    $scope.hidePhosphoGraph = function () {
        self.showPhosphoGraphTmp = true;
        self.showPhosphoGraph = false;
    }

    $scope.makePhosphoGraph = function (phosphoNetwork, ptmToAbundance, graphType, circleSliderValue, nodeSliderValue, fontSliderValue, widthSliderValue) {

        if(self.showPhosphoGraphTmp){
            self.showPhosphoGraphTmp = false;
            self.showPhosphoGraph = true;
        }
        else {
            console.log("in makePhosphoGraph");
            self.showPhosphoGraphTmp = true;
            self.showPhosphoGraph = false;
            //console.log("in makePhosphoGraph");

            d3.select("#chart3").select("svg").remove();
            if (typeof svg3 === 'undefined') {
                var svg3 = d3.selectAll("#chart3").append("svg");
            }
            //var svg3 = d3.selectAll("#chart3").append("svg");


            var force;



            var colNodeScaleSeparate = d3.scale.ordinal()
                .range(["#987024", "#ed0909", "#0af702"])
                //.range(["#987024", "#982482", "#0af702"])
                .domain([0, 1, 2]);
//#f9a3f5
            // var colNodeScaleSeparate = d3.scale.ordinal()
            //     .range(["#767776", "#f91104", "#0af702"])
            //     .domain([0,1,2]);

            var colNodeScale = d3.scale.linear().range(["#987024", "#ed0909"]);
            var colScale = d3.scale.linear().range(["#987024", "#ed0909"]);
            var edgeWeightScale = d3.scale.linear().range([1, 3]);
            var xScale = d3.scale.linear().range([nodeSliderValue/3.0, nodeSliderValue]);
            //var xScale = d3.scale.linear().range([5, 15]);
            var textPlacePlusMinus = d3.scale.ordinal()
                .range([18, -18])
                .domain([1, 2]);
            var textPlaceStartEnd = d3.scale.ordinal().range(["start", "end"])
                .domain([1, 2]);
            //d3.selectAll("svg > *").remove();

            var colorsForAbundance = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
            var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];
            var colorScale = d3.scale.threshold()
                .domain(domain_data)
                .range(colorsForAbundance);




            function updatePhospho(nodes, links, graphType, circleValue, nodeValue, fontValue, widthValue) {
                //
                //var svg;
                circleValue = Math.min(circleValue, widthValue - 300);

                // $('force1').click();
                //document.getElementById('force1').click();

                // //console.log(circularLayout);
                function defaultView3() {


                    svg3.remove();

                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    colNodeScale.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));
                    edgeWeightScale.domain(d3.extent(links, function (d) {
                        return d.score;
                    }));
                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = w,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;

//These variables are global variables
                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;

                    svg3 = d3.select("#chart3")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);
                    svg3.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");


                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h])
                        .linkDistance(150)
                        .charge(-500)
                        //.linkStrength(0.9)
                        //.friction(0.9)
                        //.chargeDistance(300)
                        .gravity(0.25)
                        //.theta(0.8)
                        //.alpha(0.1)
                        .on("tick", tick)
                        .start();

                    // for (var i = n*n; i > 0; --i) force.tick();
                    // force.stop();

                    //.stop();


                    var path = svg3.append("svg:g").selectAll("path")
                    //.data(links)
                        .data(force.links())
                        .enter().append("svg:path")
                        .style("stroke-width", 1)
                        .style('stroke', "black")
                        .style("stroke-width", function (d) {
                            return edgeWeightScale(d.score) + "px";
                        })
                        .attr("stroke-dasharray", function (d) {
                            if (d.score < 100) {
                                return "5,5"; //these classes are defined in custom.css
                            } else {
                                return "5,0";//these classes are defined in custom.css
                            }
                        })
                        //.style("stroke", function (d) {return colScale(d.value); })
                        .attr("class", function (d) {
                            return "link ";
                        });


                    var node = svg3.append("svg:g").selectAll("g.node")
                        .data(force.nodes())
                        .enter().append("svg:g")
                        // .style("stroke-width", 3)
                        // .style('stroke', "black")
                        //.attr("class", "node")
                        .call(force.drag);

                    // nodes.forEach(function(v) {
                    //     var nd;
                    //     var cx = v.coord[0];
                    //     var cy = v.coord[1];
                    //
                    //     switch (v.group) {
                    //         case 1:
                    //             nd = svg.append("circle");
                    //             break;
                    //         case 2:
                    //             nd = svg.append("rect");
                    //             break;
                    //     }
                    // });

                    node.append("circle")
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        .style("fill", function (d) {
                            if (d.group == 1) {
                                return colorScale(d.value);
                            }
                            else {
                                return colNodeScale(d.group);
                            }
                            //return colNodeScale(d.group);
                        })
                        // .style("fill", function (d) {
                        //     return colNodeScale(d.group);
                        // })
                        .style("stroke", "#333")
                        .style("stroke-width", "2px");
                    //.on("dblclick", dblclick);


                    function openLink() {
                        return function (d) {
                            var url = "";
                            if (d.slug != "") {
                                url = d.slug
                            } //else if(d.type == 2) {
                            //url = "clients/" + d.slug
                            //} else if(d.type == 3) {
                            //url = "agencies/" + d.slug
                            //}
                            window.open("//" + url)
                        }
                    };
                    node.append("svg:image")
                    //****************************************
                    //.attr("class", function(d){ return d.name })
                    //****************************************
                    //.attr("xlink:href", function(d){ return d.img_hrefD})
                        .attr("x", "-36px")
                        .attr("y", "-36px")
                        .attr("width", "70px")
                        .attr("height", "70px")
                    //.on("dblclick", openLink());

                    // .on("mouseover", function (d) { if(d.entity == "company")
                    // {
                    //     d3.select(this).attr("width", "90px")
                    //         .attr("x", "-46px")
                    //         .attr("y", "-36.5px")
                    //         .attr("xlink:href", function(d){ return d.img_hrefL});
                    // }
                    // })
                    // .on("mouseout", function (d) { if(d.entity == "company")
                    // {
                    //     d3.select(this).attr("width", "70px")
                    //         .attr("x", "-36px")
                    //         .attr("y", "-36px")
                    //         .attr("xlink:href", function(d){ return d.img_hrefD});
                    // }
                    // });


                    //.text(function(d) { return d.name })
                    node.append("svg:text")
                    //****************************************
                        .attr("class", function (d) {
                            return d.full_name
                        })
                        //****************************************
                        .attr("x", 16)
                        .attr("y", ".31em")
                        //.attr("class", "shadow")
                        //.style("font-size","10px")
                        // .attr("dx", 0)
                        // .attr("dy", ".35em")
                        //.style("font-size","12px")
                        //****************************************
                        //text.shadow {
                        .style("stroke", "#fff")
                        .style("stroke-width", "4px")
                        //}
                        //.attr("class", "shadow")
                        .style("font", String(fontValue) + "px Arial")
                        //.style("font", "14px Times New Roman")
                        //****************************************
                        //.attr("text-anchor", "middle")
                        //****************************************
                        .text(function (d) {
                            return d.full_name
                        });
                    //****************************************


                    //This one is for the actual text
                    node.append("svg:text")
                    //****************************************
                        .attr("class", function (d) {
                            return d.full_name
                        })
                        //****************************************
                        .attr("x", 16)
                        .attr("y", ".31em")
                        //.attr("class", "shadow")
                        //.style("font-size","10px")
                        // .attr("dx", 0)
                        // .attr("dy", ".35em")
                        //.style("font-size","12px")
                        //****************************************
                        //.style("font", "14px Times New Roman")
                        .style("font", String(fontValue) + "px Arial")
                        //****************************************
                        //.attr("text-anchor", "middle")
                        //****************************************
                        .text(function (d) {
                            return d.full_name
                        });
                    //****************************************


                    node.on("mouseover", function (d) {
                        // d3.select(this).select("text")
                        //     .transition()
                        //     .duration(300)
                        //     .text(function (d) {
                        //         return d.full_name;
                        //     })
                        // //.style("font-size", "15px")
                        // .style("font", "14px Times New Roman");
                        //
                        // d3.select(this).select("text")
                        //     .transition()
                        //     .duration(300)
                        //     .text(function (d) {
                        //         return d.full_name;
                        //     })
                        //     //.style("font-size", "15px")
                        //     //.attr("class", "shadow")
                        //     .style("font", "14px Times New Roman");
                        // d3.select(this).select("text")
                        //     .transition()
                        //     .duration(300)
                        //     .text(function (d) {
                        //         return d.full_name;
                        //     })
                        //
                        //     .style("fill",'black')
                        //     .style("font", "14px Times New Roman");

                        //d3.selectAll("text").remove();
                        //d3.select(this).style("stroke-width", 6);

                        //d3.select(this).select("text").style("stroke", "blue");

                        var nodeNeighbors = links.filter(function (link) {
                            // Filter the list of links to only those links that have our target
                            // node as a source or target
                            return link.source.index === d.index || link.target.index === d.index;
                        })
                            .map(function (link) {
                                // Map the list of links to a simple array of the neighboring indices - this is
                                // technically not required but makes the code below simpler because we can use
                                // indexOf instead of iterating and searching ourselves.
                                return link.source.index === d.index ? link.target.index : link.source.index;
                            });

                        d3.selectAll('circle').filter(function (node) {
                            // I filter the selection of all circles to only those that hold a node with an
                            // index in my listg of neighbors
                            return nodeNeighbors.indexOf(node.index) > -1;
                        })
                            .style('stroke', 'blue');

                        //d3.selectAll('text').filter(d).style('fill', 'blue');
                        //****************************
                        // d3.selectAll('text').filter(function(node) {
                        //     // I filter the selection of all circles to only those that hold a node with an
                        //     // index in my listg of neighbors
                        //     return nodeNeighbors.indexOf(node.index) > -1;
                        // }).style('fill', 'blue')
                        //     //.style("font-size", "16px")
                        //     //.style("font-weight", "bold");
                        // //****************************
                        path.style('stroke', function (l) {
                            if (d === l.source || d === l.target)
                                return "blue";
                            else
                                return "grey";
                        })

                        path.style('stroke-width', function (l) {
                            if (d === l.source || d === l.target)
                                return 2;
                            else
                                return 1;
                        })

                    })
                        .on("mouseout", function (d) {
                            d3.select(this).select("text")
                                .transition()
                                .duration(300)
                                .text(function (d) {

                                    return d.full_name;
                                });
                            // d3.select(this).select("text")
                            //     //*******************************
                            //     .style("font", "14px Times New Roman")
                            //     //*******************************
                            //     .style("font-size", "14px")
                            //     .style("fill",'black')
                            //     .style("font-weight", "normal");

                            // d3.select(this).select("text")
                            // //*******************************
                            //     .style("font", "14px Times New Roman")
                            //     //*******************************
                            //     .style("font-size", "14px")
                            //     .style("fill",'black')
                            //     .style("font-weight", "normal");
                            //d3.select(this).style("stroke", "black");
                            //d3.select(this).style("stroke-width", 1);
                            //d3.select(this).style("stroke", "#333");
                            path.style('stroke', "grey");
                            path.style('stroke-width', 1);
                            //circle.style('stroke', "grey");
                            //node.style("stroke-width", 3);
                            //node.style("stroke", "#333");
                            //d3.selectAll('text').style('fill', 'black')
                            // d3.selectAll('text').style('fill', 'black')
                            //     .style("font-weight", "normal");
                            //d3.selectAll("text").style("font-weight", "normal");
                            node.selectAll("circle").style("stroke-width", 3)
                                .style('stroke', "black");
                            //.style("font-size", "12px");
                            //}
                        });


                    function pythag(r, b, coord) {
                        r += nodeBaseRad;

                        // force use of b coord that exists in circle to avoid sqrt(x<0)
                        b = Math.min(w - r - strokeWidth, Math.max(r + strokeWidth, b));

                        var b2 = Math.pow((b - radius), 2),
                            a = Math.sqrt(hyp2 - b2);

                        function openLink() {
                            return function (d) {
                                var url = "";
                                if (d.slug != "") {
                                    url = d.slug
                                } //else if(d.type == 2) {
                                //url = "clients/" + d.slug
                                //} else if(d.type == 3) {
                                //url = "agencies/" + d.slug
                                //}
                                window.open("//" + url)
                            }
                        }

                        // radius - sqrt(hyp^2 - b^2) < coord < sqrt(hyp^2 - b^2) + radius
                        coord = Math.max(radius - a + r + strokeWidth,
                            Math.min(a + radius - r - strokeWidth, coord));

                        return coord;
                    }

                    function tick(e) {
                        path.attr("d", function (d) {
                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,

                                dr = Math.sqrt(dx * dx + dy * dy);
                            ////console.log(d.source.x);
                            // //console.log(d.target.x);
                            return "M" + d.source.x + "," + d.source.y + "," + d.target.x + "," + d.target.y;
                            //return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
                        });

                        node.attr('x', function (d) {
                            return d.x = pythag(Math.random() * 12, d.y, d.x);
                        })
                            .attr('y', function (d) {
                                return d.y = pythag(Math.random() * 12, d.x, d.y);
                            })
                            .attr("transform", function (d) {
                                return "translate(" + d.x + "," + d.y + ")"
                            });

                        //d3.select(this).classed("fixed", d.fixed = true);
                        // circle.attr("transform", function(d) {
                        //     return "translate(" + d.x + "," + d.y + ")";
                        // });
                        //************************************
                        // text.attr("transform", function(d) {
                        //     return "translate(" + d.x + "," + d.y + ")";
                        // });
                        //************************************
                    }

                    //For not moving after drag
                    var drag = force.drag()
                        .on("dragstart", dragstart);
                    //.on("dragstart", dragstartAll);

                    //For not moving after drag
                    function dblclick(d) {
                        d3.select(this).classed("fixed", d.fixed = false);

                    }

                    //For not moving after drag
                    function dragstart(d) {
                        d3.select(this).classed("fixed", d.fixed = true);

                        for (i = 0; i < nodes.length; i++) {
                            nodes[i].fixed = true;
                        }
                    }


                    var svgText = svg3.append("text");
                    svgText.attr("x", 10).attr("y", globalHPlus50 - 50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);



                    var legend2 = svg3.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());
                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg3.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg3.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg3.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();

                    // For legend
                    // var colNodeScaleSeparateInfo = d3.scale.ordinal()
                    //     .range(["#767776", "#f91104"])
                    //     .domain(["Query Gene Set", "Pathways / Kinases Perturbation"]);
                    //
                    //
                    // var legend = svg3.selectAll(".legend")
                    //     .data(colNodeScaleSeparateInfo.domain())
                    //     .enter().append("g")
                    //     .attr("class", "legend")
                    //     .attr("transform", function (d, i) {
                    //         return "translate(0," + (i) * 25 + ")";
                    //     });
                    //
                    // legend.append("rect")
                    //     .attr("x", w - 25)
                    //     .attr("width", 25)
                    //     .attr("height", 25)
                    //     .style("fill", colNodeScaleSeparateInfo);
                    //
                    // legend.append("text")
                    //     .attr("x", w - 35)
                    //     .attr("y", 12.5)
                    //     .attr("dy", ".35em")
                    //     .style("text-anchor", "end")
                    //     .text(function (d) {
                    //         return d;
                    //     });
                    //
                    //
                    // d3.select("#download").on("click", function () {
                    //     d3.select(this)
                    //         .attr("href", 'data:application/octet-stream;base64,' + btoa(d3.select("#chart").html()))
                    //         .attr("download", "pathway_network.svg")
                    // })

                };

                //defaultSVG();



                function circularView3(){
                    svg3.remove();

                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    colNodeScale.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));
                    edgeWeightScale.domain(d3.extent(links, function (d) {
                        return d.score;
                    }));
                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = w,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;

//These variables are global variables
                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;

                    svg3 = d3.select("#chart3")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);
                    svg3.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");


                    // This is for grouping nodes


                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h]);

// evenly spaces nodes along arc
                    var circleCoord = function (node, index, num_nodes) {
                        var circumference = circle.node().getTotalLength();
                        var pointAtLength = function (l) {
                            return circle.node().getPointAtLength(l)
                        };
                        var sectionLength = (circumference) / num_nodes;
                        var position = sectionLength * index + sectionLength / 2;
                        return pointAtLength(circumference - position)
                    }

                    var is_connected = function (d, opacity) {
                        lines.transition().style("stroke-opacity", function (o) {
                            return o.source === d || o.target === d ? 1 : opacity;
                        });
                    }

                    var dim = w - (widthValue - circleValue);
                    var circle = svg3.append("path")
                        .attr("d", "M " + String((widthValue - circleValue)/2) + ", " + (dim / 2 + (widthValue - circleValue)/2) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                        .style("fill", "white");

                    // var dim = w - 900
                    // var circle = svg3.append("path")
                    //     .attr("d", "M 450, " + (dim / 2 + 450) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                    //     .style("fill", "white");

                    force.start();

                    nodes.forEach(function (n, i) {
                        var coord = circleCoord(n, i, nodes.length)
                        n.x = coord.x
                        n.y = coord.y
                    });


                    // use this one for straight line links...
                    // var lines = svg.selectAll("line.node-link")
                    //     .data(links).enter().append("line")
                    //     .attr("class", "node-link")
                    //     .attr("x1", function(d) { return d.source.x; })
                    //     .attr("y1", function(d) { return d.source.y; })
                    //     .attr("x2", function(d) { return d.target.x; })
                    //     .attr("y2", function(d) { return d.target.y; });

                    var lines = svg3.selectAll("path.node-link")
                        .data(links).enter().append("path")
                        .style("fill", "none")
                        .style("stroke", "#726363")
                        .attr("class", "node-link")
                        .style("stroke-width", function (d) {
                            return edgeWeightScale(d.score) + "px";
                        })

                        .attr("stroke-dasharray", function (d) {
                            if (d.score < 100) {
                                return "5,5"; //these classes are defined in custom.css
                            } else {
                                return "5,0";//these classes are defined in custom.css
                            }
                        })
                        .attr("d", function (d) {
                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,
                                dr = Math.sqrt(dx * dx + dy * dy);
                            return "M" +
                                d.source.x + "," +
                                d.source.y + "," +
                                d.target.x + "," +
                                d.target.y;

                        });


                    var gnodes = svg3.selectAll('g.gnode')
                        .data(nodes).enter().append('g')
                        .attr("transform", function (d) {
                            return "translate(" + d.x + "," + d.y + ")"
                        })
                        .classed('gnode', true);


                    // node.append("circle")
                    //     .attr("r", function (d) { return xScale(d.weight); })
                    //     .style("fill", function(d) { return colNodeScale(d.group); });

                    var node = gnodes.append("circle")
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        .style("fill", function (d) {
                            if (d.group == 1) {
                                return colorScale(d.value);
                            }
                            else {
                                return colNodeScale(d.group);
                            }
                            //return colNodeScale(d.group);
                        })
                        // .style("fill", function (d) {
                        //     return colNodeScale(d.group);
                        // })
                        .style("stroke", "#333")
                        .style("stroke-width", "2px")
                        //.attr("class", "node")
                        .on("mouseenter", function (d) {
                            is_connected(d, 0.1)
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            d3.select(this).transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight + 10);
                            })
                        })
                        .on("mouseleave", function (d) {
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            is_connected(d, 1);
                        })
                        .call(force.drag);

                    var labels = gnodes.append("text")
                        .attr("dx", 4)
                        .attr("dy", 4)
                        .style("font", String(fontValue) + "px Arial")
                        //.style("font", "14px Times New Roman")
                        .attr("text-anchor", function (d) {
                            return d.x < w / 2 ? "end" : "start";
                        })
                        .attr("transform", function (d) {
                            return d.x < w / 2 ? "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(-20)" : "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(20)";
                        })
                        //.attr("transform", function(d) { return  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")"})
                        //.attr("transform", function(d) { return (d.x-w/2)/(d.y-w/2) < 0 ?  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")" : "rotate(180)"; })
                        .text(function (d) {
                            return d.full_name
                        })

                    var drag = force.drag()
                        .on("dragstart", dragstart);
                    //.on("dragstart", dragstartAll);


                    //For not moving after drag
                    function dragstart(d) {
                        d3.select(this).classed("fixed", d.fixed = true);

                        for (i = 0; i < nodes.length; i++) {
                            nodes[i].fixed = true;
                        }
                    }

                    var svgText = svg3.append("text");
                    svgText.attr("x", 10).attr("y", globalHPlus50 - 50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);



                    var legend2 = svg3.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());
                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg3.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg3.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg3.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();


                };

                function circosView3(){
                    svg3.remove();

                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    colNodeScale.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));
                    edgeWeightScale.domain(d3.extent(links, function (d) {
                        return d.score;
                    }));
                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = w,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;

//These variables are global variables
                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;

                    svg3 = d3.select("#chart3")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);
                    svg3.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");


                    // This is for grouping nodes


                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h]);

// evenly spaces nodes along arc
                    var circleCoord = function (node, index, num_nodes) {
                        var circumference = circle.node().getTotalLength();
                        var pointAtLength = function (l) {
                            return circle.node().getPointAtLength(l)
                        };
                        var sectionLength = (circumference) / num_nodes;
                        var position = sectionLength * index + sectionLength / 2;
                        return pointAtLength(circumference - position)
                    }

                    var is_connected = function (d, opacity) {
                        lines.transition().style("stroke-opacity", function (o) {
                            return o.source === d || o.target === d ? 1 : opacity;
                        });
                    }

                    var dim = w - (widthValue - circleValue);
                    var circle = svg3.append("path")
                        .attr("d", "M " + String((widthValue - circleValue)/2) + ", " + (dim / 2 + (widthValue - circleValue)/2) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                        .style("fill", "white");

                    // var dim = w - 900
                    // var circle = svg3.append("path")
                    //     .attr("d", "M 450, " + (dim / 2 + 450) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                    //     .style("fill", "white");

                    force.start();

                    nodes.forEach(function (n, i) {
                        var coord = circleCoord(n, i, nodes.length)
                        n.x = coord.x
                        n.y = coord.y
                    });


                    // use this one for straight line links...
                    // var lines = svg.selectAll("line.node-link")
                    //     .data(links).enter().append("line")
                    //     .attr("class", "node-link")
                    //     .attr("x1", function(d) { return d.source.x; })
                    //     .attr("y1", function(d) { return d.source.y; })
                    //     .attr("x2", function(d) { return d.target.x; })
                    //     .attr("y2", function(d) { return d.target.y; });

                    var lines = svg3.selectAll("path.node-link")
                        .data(links).enter().append("path")
                        .style("fill", "none")
                        .style("stroke", "#726363")
                        .attr("class", "node-link")
                        .style("stroke-width", function (d) {
                            return edgeWeightScale(d.score) + "px";
                        })
                        .attr("stroke-dasharray", function (d) {
                            if (d.score < 100) {
                                return "5,5"; //these classes are defined in custom.css
                            } else {
                                return "5,0";//these classes are defined in custom.css
                            }
                        })
                        .attr("d", function (d) {

                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,
                                dr = Math.sqrt(dx * dx + dy * dy),
                                a1 = dx,
                                a2 = dy,
                                c1 = w / 2 - d.source.x,
                                c2 = h / 2 - d.source.y,
                                d1 = w / 2 - d.target.x,
                                d2 = h / 2 - d.target.y,

                                drx = dr / 1.5,
                                dry = dr / 1.5,
                                xRotation = 0, // degrees
                                largeArc = 0, // 1 or 0

                                sweep = 1, // 1 or 0
                                x2 = d.target.x,
                                y2 = d.target.y;


                            // if( (a1*c2 - a2*c1) > 0)
                            // {
                            //     sweep = 0
                            // }
                            // else
                            // {sweep = 1}
                            if ((c1 * d2 - c2 * d1) > 0) {
                                sweep = 0
                            }
                            else {
                                sweep = 1
                            }


                            return "M" + d.source.x + "," + d.source.y + "A" + drx + "," + dry + " " + xRotation + "," + largeArc + "," + sweep + " " + x2 + "," + y2;
                        });
                        // .attr("d", function (d) {
                        //     var dx = d.target.x - d.source.x,
                        //         dy = d.target.y - d.source.y,
                        //         dr = Math.sqrt(dx * dx + dy * dy);
                        //     return "M" +
                        //         d.source.x + "," +
                        //         d.source.y + "," +
                        //         d.target.x + "," +
                        //         d.target.y;
                        //
                        // });


                    var gnodes = svg3.selectAll('g.gnode')
                        .data(nodes).enter().append('g')
                        .attr("transform", function (d) {
                            return "translate(" + d.x + "," + d.y + ")"
                        })
                        .classed('gnode', true);


                    // node.append("circle")
                    //     .attr("r", function (d) { return xScale(d.weight); })
                    //     .style("fill", function(d) { return colNodeScale(d.group); });

                    var node = gnodes.append("circle")
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        .style("fill", function (d) {
                            if (d.group == 1) {
                                return colorScale(d.value);
                            }
                            else {
                                return colNodeScale(d.group);
                            }
                            //return colNodeScale(d.group);
                        })
                        // .style("fill", function (d) {
                        //     return colNodeScale(d.group);
                        // })
                        .style("stroke", "#333")
                        .style("stroke-width", "2px")
                        //.attr("class", "node")
                        .on("mouseenter", function (d) {
                            is_connected(d, 0.1)
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            d3.select(this).transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight + 10);
                            })
                        })
                        .on("mouseleave", function (d) {
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            is_connected(d, 1);
                        })
                        .call(force.drag);

                    var labels = gnodes.append("text")
                        .attr("dx", 4)
                        .attr("dy", 4)
                        .style("font", String(fontValue) + "px Arial")
                        //.style("font", "14px Times New Roman")
                        .attr("text-anchor", function (d) {
                            return d.x < w / 2 ? "end" : "start";
                        })
                        .attr("transform", function (d) {
                            return d.x < w / 2 ? "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(-20)" : "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(20)";
                        })
                        //.attr("transform", function(d) { return  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")"})
                        //.attr("transform", function(d) { return (d.x-w/2)/(d.y-w/2) < 0 ?  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")" : "rotate(180)"; })
                        .text(function (d) {
                            return d.full_name
                        })

                    var drag = force.drag()
                        .on("dragstart", dragstart);
                    //.on("dragstart", dragstartAll);


                    //For not moving after drag
                    function dragstart(d) {
                        d3.select(this).classed("fixed", d.fixed = true);

                        for (i = 0; i < nodes.length; i++) {
                            nodes[i].fixed = true;
                        }
                    }

                    var svgText = svg3.append("text");
                    svgText.attr("x", 10).attr("y", globalHPlus50 - 50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);



                    var legend2 = svg3.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());
                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg3.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg3.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg3.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();


                }


                function parallelView3() {
                    svg3.remove();

                    //xPosition.domain(d3.extent(nodes, function (d) { return d.text; }));
                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    colNodeScale.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));
                    textPlacePlusMinus.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    textPlaceStartEnd.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    edgeWeightScale.domain(d3.extent(links, function (d) {
                        return d.score;
                    }));


                    n1 = 0;
                    n2 = 0;


                    nodes.forEach(function (n, i) {


                        if (n.group == 1) {

                            n1 = n1 + 1;
                        }
                        if (n.group == 2) {

                            n2 = n2 + 1;
                        }

                    });

                    //console.log(n1);
                    //console.log(n1 * 12);
                    //console.log(n2);
                    //console.log(n2 * 12);
                    var parallelH = Math.max(n1 * 12, n2 * 12, 500);
                    //var parallelH = Math.max(n1 * 12, n2 * 12);

                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = parallelH,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;

                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;


                    svg3 = d3.select("#chart3")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);

                    svg3.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");


                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h]);


                    var parallelCoordx = function (group) {

                        if (group == 1) {
                            return w * 1.5 / 3.;
                        }
                        else {
                            return w / 3.;
                        }
                    }

                    var parallelCoordy = function (index, num_nodes) {
                        var dist = h / (num_nodes + 1);

                        return (index + 1) * dist;
                    }

                    var is_connected = function (d, opacity) {
                        lines.transition().style("stroke-opacity", function (o) {
                            return o.source === d || o.target === d ? 1 : opacity;
                        });
                    }

                    //var dim = w-80
                    // var circle = svg.append("path")
                    //     .attr("d", "M 40, "+(dim/2+40)+" a "+dim/2+","+dim/2+" 0 1,0 "+dim+",0 a "+dim/2+","+dim/2+" 0 1,0 "+dim*-1+",0")
                    //     .style("fill", "#f5f5f5");

                    force.start();


                    // //console.log(nodes.length);
                    var groupId = [];
                    var maxId = 0;
                    for (var i = 0; i < nodes.length; i++) {
                        var item = nodes[i];

                        if (!groupId[item.group]) {
                            groupId[item.group] = [];
                        }

                        groupId[item.group].push({name: item.name});
                        // //console.log(item.group);
                        // //console.log(groupId[item.group]);
                        if (maxId < item.group) {
                            maxId = item.group;
                        }
                    }
                    // //console.log(maxId);
                    // //console.log(groupId[1].length);
                    // //console.log(groupId[2].length);

                    n1 = 0;
                    n2 = 0;

                    nodes.forEach(function (n, i) {
                        var item = nodes[i];

                        if (n.group == 1) {
                            n.x = parallelCoordx(n.group)
                            n.y = parallelCoordy(n1, groupId[1].length)
                            n1 = n1 + 1;
                        }
                        if (n.group == 2) {
                            n.x = parallelCoordx(n.group)
                            n.y = parallelCoordy(n2, groupId[2].length)
                            n2 = n2 + 1;
                        }

                    });


                    // use this one for straight line links...
                    // var lines = svg.selectAll("line.node-link")
                    //   .data(links).enter().append("line")
                    //     .attr("class", "node-link")
                    //   .attr("x1", function(d) { return d.source.x; })
                    //   .attr("y1", function(d) { return d.source.y; })
                    //   .attr("x2", function(d) { return d.target.x; })
                    //   .attr("y2", function(d) { return d.target.y; });

                    var lines = svg3.selectAll("path.node-link")
                        .data(links).enter().append("path")
                        .style("fill", "none")
                        .style("stroke", "#726363")
                        .attr("class", "node-link")
                        .style("stroke-width", function (d) {
                            return edgeWeightScale(d.score) + "px";
                        })
                        .attr("stroke-dasharray", function (d) {
                            if (d.score < 100) {
                                return "5,5"; //these classes are defined in custom.css
                            } else {
                                return "5,0";//these classes are defined in custom.css
                            }
                        })
                        .attr("d", function (d) {
                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,
                                dr = Math.sqrt(dx * dx + dy * dy);
                            return "M" +
                                d.source.x + "," +
                                d.source.y + "," +
                                d.target.x + "," +
                                d.target.y;
                        });

                    // var lines = svg.selectAll("path.node-link")
                    //     .data(links).enter().append("path")
                    //     .style("fill", "none")
                    //     .style("stroke", "black")
                    //     .attr("class", "node-link")
                    //     .attr("d", function(d) {
                    //         var dx = d.target.x - d.source.x,
                    //             dy = d.target.y - d.source.y,
                    //             dr = Math.sqrt(dx * dx + dy * dy);
                    //         return "M" +
                    //             d.source.x + "," +
                    //             d.source.y + "A" +
                    //             dr + "," + dr + " 0 0,1 " +
                    //             d.target.x + "," +
                    //             d.target.y;
                    //     });

                    var gnodes = svg3.selectAll('g.gnode')
                        .data(nodes).enter().append('g')
                        .attr("transform", function (d) {
                            return "translate(" + d.x + "," + d.y + ")"
                        })
                        .classed('gnode', true);

                    var node = gnodes.append("circle")
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        .style("fill", function (d) {
                            if (d.group == 1) {
                                return colorScale(d.value);
                            }
                            else {
                                return colNodeScale(d.group);
                            }
                            //return colNodeScale(d.group);
                        })
                        // .style("fill", function (d) {
                        //     return colNodeScale(d.group);
                        // })
                        .style("stroke", "#333")
                        .style("stroke-width", "2px")
                        //.attr("class", "node")
                        .on("mouseenter", function (d) {
                            is_connected(d, 0.1)
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            d3.select(this).transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight + 10);
                            })
                        })
                        .on("mouseleave", function (d) {
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            is_connected(d, 1);
                        })
                        .call(force.drag);
                    // var bbox = textElement.getBBox();
                    // var width = bbox.width;
                    // var height = bbox.height;
                    var labels = gnodes.append("text")
                        .style("font", String(fontValue) + "px Arial")
                        //.style("font", "14px Times New Roman")
                        .attr("dx", function (d) {
                            return textPlacePlusMinus(d.group);
                        })
                        .attr("dy", 4)
                        .attr("text-anchor", function (d) {
                            return textPlaceStartEnd(d.group);
                        })
                        .text(function (d) {
                            return d.full_name
                        })

                    var svgText = svg3.append("text");
                    svgText.attr("x", 10).attr("y", globalHPlus50 - 50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);


                    var legend2 = svg3.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());
                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg3.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg3.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg3.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();

                    var legend2 = svg3.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());
                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg3.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg3.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg3.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();




                };




                d3.select('#force3').on('click', function () {
                    defaultView3();
                    $scope.graphType4phos = 0;
                });
                d3.select('#parallelView3').on('click', function () {
                    parallelView3();
                    $scope.graphType4phos = 1;
                });
                d3.select('#circosView3').on('click', function (){
                    circosView3();
                    $scope.graphType4phos = 2;
                });
                d3.select('#circularView3').on('click', function (){
                    circularView3();
                    $scope.graphType4phos = 3;
                });


                if(graphType == 0){
                    defaultView3();
                }
                else if(graphType == 1){
                    parallelView3();
                }
                else if(graphType == 2){
                    circosView3();
                }
                else if(graphType == 3){
                    circularView3();
                }



                d3.select("#download-svg3").on("click", function ()  {
                    var name = 'PiNET-PhosphoSite-Kinase-Graph.svg';
                    var svgEl = svg3.node();
                    svgEl.setAttribute("xmlns", "http://www.w3.org/2000/svg");
                    var svgData = svgEl.outerHTML;
                    var preface = '<?xml version="1.0" standalone="no"?>\r\n';
                    var svgBlob = new Blob([preface, svgData], {type:"image/svg+xml;charset=utf-8"});
                    var svgUrl = URL.createObjectURL(svgBlob);
                    var downloadLink = document.createElement("a");
                    downloadLink.href = svgUrl;
                    downloadLink.download = name;
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                })





                d3.select('#download-png3').on('click', function () {
                    var svgString = getSVGString(svg3.node());

                    svgString2Image(svgString, 4 * globalW, 4 * globalHPlus50, 'png', save); // passes Blob and filesize String to the callback

                    function save(dataBlob, filesize) {
                        saveAs(dataBlob, 'Pinet-PhosphoSite-Kinase-Graph.png'); // FileSaver.js function
                    }
                });
                // d3.select('#saveButton').on('click', function () {
                //     var svgString = getSVGString(svg3.node());
                //
                //     svgString2Image(svgString, 4 * 1550, 4 * 1550, 'png', save); // passes Blob and filesize String to the callback
                //
                //     function save(dataBlob, filesize) {
                //         saveAs(dataBlob, 'PiNET-grapg.png'); // FileSaver.js function
                //     }
                // });

// Below are the functions that handle actual exporting:
// getSVGString ( svgNode ) and svgString2Image( svgString, width, height, format, callback )
                function getSVGString(svgNode) {
                    svgNode.setAttribute('xlink', 'http://www.w3.org/1999/xlink');
                    var cssStyleText = getCSSStyles(svgNode);
                    appendCSS(cssStyleText, svgNode);

                    var serializer = new XMLSerializer();
                    var svgString = serializer.serializeToString(svgNode);
                    svgString = svgString.replace(/(\w+)?:?xlink=/g, 'xmlns:xlink='); // Fix root xlink without namespace
                    svgString = svgString.replace(/NS\d+:href/g, 'xlink:href'); // Safari NS namespace fix

                    return svgString;

                    function getCSSStyles(parentElement) {
                        var selectorTextArr = [];

                        // Add Parent element Id and Classes to the list
                        selectorTextArr.push('#' + parentElement.id);
                        for (var c = 0; c < parentElement.classList.length; c++)
                            if (!contains('.' + parentElement.classList[c], selectorTextArr))
                                selectorTextArr.push('.' + parentElement.classList[c]);

                        // Add Children element Ids and Classes to the list
                        var nodes = parentElement.getElementsByTagName("*");
                        for (var i = 0; i < nodes.length; i++) {
                            var id = nodes[i].id;
                            if (!contains('#' + id, selectorTextArr))
                                selectorTextArr.push('#' + id);

                            var classes = nodes[i].classList;
                            for (var c = 0; c < classes.length; c++)
                                if (!contains('.' + classes[c], selectorTextArr))
                                    selectorTextArr.push('.' + classes[c]);
                        }

                        // Extract CSS Rules
                        var extractedCSSText = "";
                        for (var i = 0; i < document.styleSheets.length; i++) {
                            var s = document.styleSheets[i];

                            try {
                                if (!s.cssRules) continue;
                            } catch (e) {
                                if (e.name !== 'SecurityError') throw e; // for Firefox
                                continue;
                            }

                            var cssRules = s.cssRules;
                            for (var r = 0; r < cssRules.length; r++) {
                                if (contains(cssRules[r].selectorText, selectorTextArr))
                                    extractedCSSText += cssRules[r].cssText;
                            }
                        }


                        return extractedCSSText;

                        function contains(str, arr) {
                            return arr.indexOf(str) === -1 ? false : true;
                        }

                    }

                    function appendCSS(cssText, element) {
                        var styleElement = document.createElement("style");
                        styleElement.setAttribute("type", "text/css");
                        styleElement.innerHTML = cssText;
                        var refNode = element.hasChildNodes() ? element.children[0] : null;
                        element.insertBefore(styleElement, refNode);
                    }
                }


                function svgString2Image(svgString, width, height, format, callback) {
                    var format = format ? format : 'png';

                    var imgsrc = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgString))); // Convert SVG string to data URL

                    var canvas = document.createElement("canvas");
                    var context = canvas.getContext("2d");

                    canvas.width = width;
                    canvas.height = height;

                    var image = new Image();
                    image.onload = function () {
                        context.clearRect(0, 0, width, height);
                        context.drawImage(image, 0, 0, width, height);

                        canvas.toBlob(function (blob) {
                            var filesize = Math.round(blob.length / 1024) + ' KB';
                            if (callback) callback(blob, filesize);
                        });


                    };

                    image.src = imgsrc;
                }


                // d3.select("#download").on("click", function(){
                //     var html = d3.select("svg")
                //         .attr("version", 1.1)
                //         .attr("xmlns", "http://www.w3.org/2000/svg")
                //         .node().parentNode.innerHTML;
                //
                //     ////console.log(html);
                //     var imgsrc = 'data:image/svg+xml;base64,'+ btoa(html);
                //     var img = '<img src="'+imgsrc+'">';
                //     d3.select("#svgdataurl").html(img);
                //
                //
                //     var canvas = document.querySelector("canvas"),
                //         context = canvas.getContext("2d");
                //
                //     var image = new Image;
                //     image.src = imgsrc;
                //     image.onload = function() {
                //         context.drawImage(image, 0, 0);
                //
                //         var canvasdata = canvas.toDataURL("image/png");
                //
                //         var pngimg = '<img src="'+canvasdata+'">';
                //         d3.select("#pngdataurl").html(pngimg);
                //
                //         var a = document.createElement("a");
                //         a.download = "sample.png";
                //         a.href = canvasdata;
                //         a.click();
                //     };
                //
                // });


            }

     
            $scope.phosphoOptions = [
                {value: "Known_Kinase_TargetGene"},
                {value: "Predicted_Blosum50_Kinase_TargetGene"},
                {value: "Predicted_Probability_Kinase_TargetGene"}
            ];
            SharedService.setVar('phosphoOptions', $scope.phosphoOptions);
            $scope.selectedphosphoPathways = $scope.phosphoOptions[1];
            SharedService.setVar('selectedphosphoPathways', $scope.selectedphosphoPathways);
            var pNetwork = phosphoNetwork['Predicted_Blosum50_Kinase_TargetGene'];

            for (var iterNetNode = 0; iterNetNode < pNetwork.nodes.length; iterNetNode++) {
                var iterNetNodeKey = pNetwork.nodes[iterNetNode]["name"]
                if (iterNetNodeKey in ptmToAbundance) {
                    //console.log(iterNetNodeKey);
                    if (ptmToAbundance[iterNetNodeKey] == "NA") {
                        pNetwork.nodes[iterNetNode]["value"] = 0.0;
                    }
                    else {
                        pNetwork.nodes[iterNetNode]["value"] = ptmToAbundance[iterNetNodeKey];
                    }
                }
            }
            if (self.computeWeightForUpdatePhospho){
                for (var iterNetNode = 0; iterNetNode < pNetwork.edges.length; iterNetNode++) {
                    //var iterNetNodeKey = network.nodes[iterNetNode]["name"];
                    var idx1 = pNetwork.edges[iterNetNode]["source"];
                    var idx2 = pNetwork.edges[iterNetNode]["target"];
                    pNetwork.nodes[idx1]["weight"] += 1;
                    pNetwork.nodes[idx2]["weight"] += 1;

                }
                self.computeWeightForUpdatePhospho = false;
                SharedService.setVar('computeWeightForUpdatePhospho',self.computeWeightForUpdatePhospho);
            }

            updatePhospho(pNetwork.nodes, pNetwork.edges, graphType, circleSliderValue, nodeSliderValue, fontSliderValue, widthSliderValue);
            $scope.changedPhosphoValue = function (item) {
                //var net = item.value;
                //console.log(item);
                //console.log(item.value);
                var net = item.value.toString();
                //console.log(net);

                var pNetwork = phosphoNetwork[net];
                for (var iterNetNode = 0; iterNetNode < pNetwork.nodes.length; iterNetNode++)
                {
                    //pNetwork.nodes[iterNetNode]["weight"] = 0;
                    var iterNetNodeKey = pNetwork.nodes[iterNetNode]["name"]
                    if (iterNetNodeKey in ptmToAbundance)
                    {
                        //console.log(iterNetNodeKey);
                        if (ptmToAbundance[iterNetNodeKey] == "NA")
                        {
                            pNetwork.nodes[iterNetNode]["value"] = 0.0;
                        }
                        else {
                            pNetwork.nodes[iterNetNode]["value"] = ptmToAbundance[iterNetNodeKey];
                        }
                    }
                }
                // for (var iterNetNode = 0; iterNetNode < pNetwork.edges.length; iterNetNode++)
                // {
                //     //var iterNetNodeKey = network.nodes[iterNetNode]["name"];
                //     //console.log(pNetwork);
                //     //console.log(pNetwork.edges);
                //     //console.log(pNetwork.edges[iterNetNode]);
                //     //console.log(pNetwork.edges[iterNetNode]["source"]);
                //     //console.log(pNetwork.edges[iterNetNode]["target"]);
                //     var idx1 = pNetwork.edges[iterNetNode]["source"];
                //     var idx2 = pNetwork.edges[iterNetNode]["target"];
                //     //console.log(iterNetNode);
                //     //console.log(idx1);
                //     //console.log(idx1);
                //     //console.log(pNetwork.nodes[idx1]);
                //     pNetwork.nodes[idx1]["weight"] += 1;
                //     pNetwork.nodes[idx2]["weight"] += 1;
                //
                // }

                //console.log('network');
                //console.log(pNetwork);
                updatePhospho(pNetwork.nodes, pNetwork.edges, graphType, circleSliderValue, nodeSliderValue, fontSliderValue, widthSliderValue);
                //$scope.itemList.push(item.value);
            }


            self.showPhosphoGraph = true;

            //console.log("self.showPhosphoGraph");
            //console.log(self.showPhosphoGraph);
            // self.waitingPathway = false;
            // self.showOutputPathway = true;
        }
    }

    self.changeToP100Genes = function () {
        self.genes = "DYRK1A 0.461099\n\
RPS6KA3 1.24165\n\
HN1 0.39179\n\
ZC3HC1 -0.81353\n\
NCOR2 -0.061737\n\
OCIAD1 -0.09643\n\
PDPK1 0.097759\n\
ABI1 0.588017\n\
WDR20 -0.15000\n\
MAP4 -2.95647\n\
FAM129B 0.019645\n\
TMSB4X 0.88214\n\
TMSB4X 0.9800\n\
AP1GBP1 -1.149179\n\
ZC3H14 0.93623\n\
LARP5 0.5108248\n\
MAP3K7 0.105289\n\
BRD4 0.7733867\n\
KIF4A -3.384948\n\
C22orf9 -2.96875\n\
FOSL2 0.408887\n\
JUND 0.2169463\n\
RPL12 -0.98894\n\
NUP214 -0.59864\n\
TMPO -2.223487\n\
BAT2 -0.011437\n\
FASN 0.768389\n\
FASN 0.518356\n\
FAM76B -0.20854\n\
AHNAK -0.15571\n\
PAK2 1.08313\n\
RPS6KA1 -1.064138\n\
RPS6KA1 -3.20086\n\
NUFIP2 0.428257\n\
RBBP6 0.079337\n\
CASC3 0.53475\n\
KIAA1704 0.75655\n\
CCNYL1 0.193549\n\
RNF169 -0.041419\n\
ZNF740 0.81348\n\
DDX54 0.913738\n\
ATRIP -0.05033\n\
DPF2 0.82016\n\
SMARCC1 -0.07167\n\
KHSRP 0.593808\n\
SH3KBP1 -1.831307\n\
C13orf8 -0.235423\n\
PPP1R10 0.52387\n\
TPX2 -1.28708\n\
RSF1 0.558409\n\
WAC 0.498148\n\
UBE2O -1.19459\n\
WDR26 0.29473\n\
ANLN 0.296644\n\
NANS 0.51163\n\
TERF2IP 0.184049\n\
LRWD1 0.630525\n\
LIMA1 0.316775\n\
LIMA1 0.649939\n\
GPATCH8 0.769031\n\
MAP3K2 0.2409052\n\
THRAP3 -0.33558\n\
BAT2D1 1.081598\n\
BAT2D1 0.54329\n\
CDC2 0.57929\n\
TMPO 1.024626\n\
PLEC1 -1.3094\n\
SRRT 0.417544\n\
SRRM2 0.17558\n\
RBM17 0.51067\n\
PFKP 0.632339\n\
SRRM1 1.47925\n\
ULK1 -1.06842\n\
BRAF 0.286164\n\
FOSL2 0.47064\n\
EIF4A3 -0.82673\n\
C17orf85 0.6774\n\
ATAD2 -0.324736\n\
ATXN2L 0.69807\n\
VPRBP 0.13999\n\
MARK2 -0.578569\n\
EIF4A3 -1.601547\n\
UHRF1BP1L -0.6075\n\
IQGAP3 -1.13349\n\
ZNF672 0.410076\n\
NFATC2IP 0.40125\n\
CLTA -0.1596\n\
HAT1 0.271686\n\
DHX16 0.44265\n\
RPS6 -0.4977\n\
RBM14 -0.79107\n\
ALS2 0.329239\n\
NOC2L 0.131214\n\
SLC38A1 0.2219\n\
NOLC1 -0.3440\n\
PLEC1 -0.309069";

        SharedService.setVar('genes',self.genes);
    }


    self.changeToP100PTMs = function () {
        self.inputMassPtmProteins = "Q13627{[Y+79.966]@321} 0.4611\n\
P51812{[pS]@369} 1.24165\n\
Q9UK76{[pS]@87} 0.3918\n\
Q86WB0{[pS]@321} -0.8135\n\
Q9Y618{[pS]@956} -0.0617\n\
Q9NX40{[pS]@108} -0.09643\n\
O15530{[pS]@241} 0.09776\n\
Q8IZP0{[pS]@183} 0.5880\n\
Q8TBZ3{[pS]@434} -0.15000\n\
P27816{[pS]@1073} -2.95647\n\
Q96TA1{[pS]@691} 0.01964\n\
P62328{[S+122]@2}{[M+16]@7} 0.8821\n\
P62328{[S+122]@2} 0.9800\n\
Q9UMZ2{[pS]@1075} -1.14918\n\
Q6PJT7{[pS]@515} 0.93623\n\
Q92615{[pS]@601} 0.51082\n\
O43318{[pS]@439} 0.105289\n\
O60885{[pS]@1117} 0.77338\n\
O95239{[pS]@801} -3.38494\n\
Q6ICG6{[pS]@362} -2.96875\n\
P15408{[pS]@200} 0.40888\n\
P17535{[pS]@100} 0.216946\n\
P30050{[pS]@38} -0.988941\n\
P35658{[pS]@1023} -0.59863\n\
P42167{[pS]@306} -2.22348\n\
P48634{[pS]@1219} -0.011437\n\
P49327{[pS]@207}{[M+16]@205}{[C+57]@212} 0.768389\n\
P49327{[pS]@207}{[C+57]@212} 0.51835\n\
Q5HYJ3{[pS]@193} -0.20854\n\
Q09666{[pS]@3426} -0.15571\n\
Q13177{[S+122]@2} 1.083130\n\
Q15418{[pS]@221}{[M+16]@229}{[C+57]@223} -1.0641\n\
Q15418{[pS]@221}{[C+57]@223} -3.2008\n\
Q7Z417{[pS]@652} 0.428257\n\
Q7Z6E9{[pS]@1179} 0.079337\n\
O15234{[pS]@265} 0.53475\n\
Q8IXQ4{[pS]@105} 0.75655\n\
Q8N7R7{[pS]@344} 0.1935\n\
Q8NCN4{[pS]@403} -0.041419\n\
Q8NDX6{[pS]@44} 0.81348\n\
Q8TDD1{[pS]@75}{[C+57]@73} 0.91374\n\
Q8WXE1{[pS]@224} -0.05033\n\
Q92785{[pS]@142} 0.82016\n\
Q92922{[pS]@310} -0.07167\n\
Q92945{[pS]@480} 0.593808\n\
Q96B97{[pS]@230} -1.8313\n\
Q96JM3{[pS]@405} -0.23542\n\
Q96QC0{[pS]@313} 0.523876\n\
Q9ULW0{[pS]@738} -1.287086\n\
Q96T23{[pS]@473} 0.558409\n\
Q9BTA9{[pS]@64} 0.4981\n\
Q9C0C9{[pS]@515} -1.19459\n\
Q9H7D7{[pS]@121} 0.29472\n\
Q9NQW6{[pS]@295} 0.29664\n\
Q9NR45{[pS]@275}{[C+57]@283}{[C+57]@287} 0.51163\n\
Q9NYB0{[pS]@203} 0.184049\n\
Q9UFC0{[pS]@212} 0.63052\n\
Q9UHB6{[pS]@362} 0.31677\n\
Q9UHB6{[pS]@490} 0.64994\n\
Q9UKJ3{[pS]@1035} 0.769032\n\
Q9Y2U5{[pS]@163} 0.2409052\n\
Q9Y2W1{[pS]@253} -0.33558\n\
Q9Y520{[pT]@2673} 1.081598\n\
Q9Y520{[pS]@1544} 0.54329\n\
P06493{[pT]@161} 0.57929\n\
P42167{[pT]@160} 1.0246259\n\
Q15149{[pT]@4030} -1.30946\n\
Q9BXP5{[pT]@544} 0.4175439\n\
Q9UQ35{[pT]@1492} 0.17558\n\
Q96I25{[pS]@222} 0.510677\n\
Q01813{[pS]@386} 0.63234\n\
Q8IYB3{[pS]@402} 1.479257\n\
O75385{[pS]@556} -1.06842\n\
P15056{[pS]@446} 0.286164\n\
P15408{[pS]@200}{[M+16]@209} 0.4706487\n\
P38919{[pS]@12}{[M+16]@7}{[A+42.010]@2} -0.826734\n\
Q53F19{[pS]@500} 0.6774\n\
Q6PL18{[pS]@327} -0.3247365\n\
Q8WWM7{[pS]@339} 0.69807\n\
Q9Y4B6{[pS]@1000} 0.13999\n\
Q7KZI7{[pT]@596} -0.578569\n\
P38919{[pS]@12}{[A+42.010]@2} -1.601547\n\
A0JNW5{[pS]@935} -0.60759\n\
Q86VI3{[pS]@1424} -1.133499\n\
Q499Z4{[pS]@189} 0.4100764\n\
Q8NCF5{[pS]@204} 0.4012565\n\
P09496{[pS]@105} -0.159615\n\
O14929{[pS]@361} 0.2716867\n\
O60231{[pS]@103} 0.442654\n\
P62753{[pS]@235} -0.497748\n\
Q96PK6{[pS]@618} -0.791066\n\
Q96Q42{[pS]@483} 0.3292391\n\
Q9Y3T9{[pS]@56} 0.131213\n\
Q9H2H9{[pS]@52} 0.22196\n\
Q14978{[pT]@610} -0.34400\n\
Q15149{M+16@4031}{[pT]@4030} -0.30907";

        // "Q9Y463[Y+79.966@273],Q13627[Y+79.966@321],P51812[pS@369],Q9UK76[pS@87],Q86WB0[pS@321],Q9Y618[pS@956],A0JNW5[pS@935],Q9NX40[pS@108],Q6A1A2[pS@214],O15530[pS@241],Q8IZP0[pS@183],Q8TBZ3[pS@434],P27816[pS@1073],Q96I25[pS@222],Q86VI3[pS@1424],Q96TA1[pS@691],P62328[S+122@2],P62328[S+122@2][M+16@7],P09496[pS@105],Q9UMZ2[pS@1075],Q6PJT7[pS@515],Q01813[pS@386],Q92615[pS@601],O14929[pS@361],O43318[pS@439],Q8IYB3[pS@402],O60885[pS@1117],O75385[pS@556],O95239[pS@801],Q6ICG6[pS@362],O60231[pS@103],P15056[pS@446],P15408[pS@200],P15408[pS@200][M+16@209],P05412[pS@73],P17535[pS@100],P30050[pS@38],P35658[pS@1023],P38919[pS@12][A+42@2],P38919[pS@12][M+16@7][A+42@2],P42167[pS@306],P48634[pS@1219],P49327[pS@207][C+57@212],P49327[pS@207][M+16@205][C+57@212],Q5HYJ3[pS@193],P62753[pS@235],Q09666[pS@3426],Q13177[S+122@2],P51812[pS@227][C+57@229],Q15418[pS@221][C+57@223],Q9UK32[pS@232][C+57@234],P51812[pS@227][M+16@235][C+57@229],Q15418[pS@221][M+16@229][C+57@223],Q9UK32[pS@232][M+16@240][C+57@234],Q499Z4[pS@189],Q53F19[pS@500],Q6PL18[pS@327],Q7Z417[pS@652],Q7Z6E9[pS@1179],O15234[pS@265],Q8IXQ4[pS@105],Q8N7R7[pS@344],Q8NCF5[pS@204],Q8NCN4[pS@403],Q8NDX6[pS@44],Q8TDD1[pS@75][C+57@73],Q8WWM7[pS@339],Q8WXE1[pS@224],Q92785[pS@142],Q92922[pS@310],Q92945[pS@480],Q96B97[pS@230],Q96JM3[pS@405],Q96PK6[pS@618],Q96Q42[pS@483],Q96QC0[pS@313],Q9ULW0[pS@738],Q96T23[pS@473],Q9BTA9[pS@64],Q92560[pS@460],Q9C0C9[pS@515],Q9H7D7[pS@121],Q9NQW6[pS@295],Q9NR45[pS@275][C+57@283],Q9NYB0[pS@203],Q9UFC0[pS@212],Q9UHB6[pS@362],Q9UHB6[pS@490],Q9UKJ3[pS@1035],Q9BXP5[pT@544],Q9Y2U5[pS@163],Q9Y2W1[pS@253],Q9Y3T9[pS@56],Q9Y4B6[pS@1000],Q9Y520[pT@2673],Q7KZI7[pT@596],Q9H2H9[pS@52],Q9Y520[pS@1544],P06493[pT@161],P42167[pT@160],P42166[pT@160],Q14978[pT@610],Q15149[pT@4030],Q15149[M+16@4031][pT@4030],Q9UQ35[pT@1492]";

        SharedService.setVar('inputMassPtmProteins',self.inputMassPtmProteins);
    }

}]);

appModule.controller("PathwayCtrl", ['$scope', '$http', '$location', '$window', '$timeout', '$routeParams', '$filter', 'filterFilter', 'SharedService', 'NgTableParams', '$uibModal', function ($scope, $http, $location, $window, $timeout, $routeParams, $filter, filterFilter, SharedService, NgTableParams, $uibModal) {
    //console.log("--------------- Restarting pathway 2 perturbation! ---------------");
    var self = this;
    self.modificationPattern = /[^A-Z]/g;
    self.modificationPatternWithLetter = /[A-Z]\[\+[\d\.]+]/g;
    self.modificationPatternSecondFormat = /\[[a-z]+[A-Z]+\]/g;
    self.modificationPatternForAllPTMs = /[^[\]]+(?=])/g;
    self.modificationPatternForAllProteins = /(?:^|])([^[\]]+)/g;
    self.rowSplitPattern = /[,;\n]/;
    self.rowSplitPatternGenes = /[,;\n]/;
    self.cleanFormattedModifications = /\[/;
    self.patt1 = /[A-Z]/g;
    self.patt2 = /[a-z]/g;
    self.patt3 = /\d+/g
    self.patt4 = /[+\d\.]+/g;
    self.patt5 = /^[0-9]+([,.][0-9]+)?$/g;
    self.patt6 = /^[\d.]/g;

    self.modificationForGenes = /\b\w*[^\[]\w*\b/g;
    self.modificationForptmProteins = /\b\w*[\[]\w*\b/g;

    self.modificationMap = {'a': 42.03, 'm': 14.02, 'p': 79.97};
    self.modificationMapReverse = {41: 'a', 42: 'a', 43: 'a', 13: 'm', 14: 'm', 15: 'm', 79: 'p', 80: 'p', 81: 'p'};
    self.proteinMap = {};
    self.hugoProteinMap = {};
    self.geneAndAbundance = [];
    self.computeWeightForUpdateEnrichment = SharedService.getVar('computeWeightForUpdateEnrichment');
    self.computeWeightForUpdate = SharedService.getVar('computeWeightForUpdate');
    self.computeWeightForUpdateKinase = SharedService.getVar('computeWeightForUpdateKinase');

    SharedService.getSiteVisit().then(function(successResponse){
        self.siteVisit = successResponse;
        //console.log(self.siteVisit);
    });

    self.showSplash = SharedService.getVar('showSplash');
    self.firstVisit = SharedService.getVar('firstVisit');
    self.uniprotFoundNum = SharedService.getVar('uniprotFoundNum');
    //self.textAreaFormatMD = SharedService.getVar('textAreaFormatMD');
    //self.textAreaFormatSN = SharedService.getVar('textAreaFormatSN');
    //self.textArea = SharedService.getVar('textArea');
    // self.waiting = SharedService.getVar('waiting');
    // self.showOutput = SharedService.getVar('showOutput');
    self.genes = SharedService.getVar('genes').toString();
    //console.log('in protein2pathway, genes are:');
    //console.log(self.genes);
    self.organismForm = SharedService.getVar('organismForm');

    self.inputMassPtmProteins = SharedService.getVar('inputMassPtmProteins').toString();
    self.inputShorthandPtmProteins = SharedService.getVar('inputShorthandPtmProteins').toString();
    //console.log('in protein2pathway, inputMassPtmProteins are:');
    //console.log(self.inputMassPtmProteins);
    //self.inputShorthandPtmProteins = SharedService.getVar('inputShorthandPtmProteins');
    self.uniprotJsonObjectAllForProtein2Pathways = SharedService.getVar('uniprotJsonObjectAllForProtein2Pathways');
    //self.genesForProtein2Pathways =  SharedService.getVar('genesForProtein2Pathways');
    self.uniprotJsonObjectAllForProtein2Pathways = SharedService.getVar('uniprotJsonObjectAllForProtein2Pathways');
    //self.massPtmProteinsForProtein2Pathways = SharedService.getVar('massPtmProteinsForProtein2Pathways');
    //self.shorthandPtmProteinsForProtein2Pathways = SharedService.getVar('shorthandPtmProteinsForProtein2Pathways');
    self.waitingForPeptideToProtein = SharedService.getVar('waitingForPeptideToProtein');


    self.showOutputPtm = SharedService.getVar('showOutputPtm');
    self.showOutputPathway = SharedService.getVar('showOutputPathway');
    self.peptideToModificationList = SharedService.getVar('peptideToModificationList');
    self.showPhosphoGeneNetworkProcessed = SharedService.getVar('showPhosphoGeneNetworkProcessed');
    self.showPhosphoGeneNetwork = SharedService.getVar('showPhosphoGeneNetwork');

    self.blosum50Table = SharedService.getVar('blosum50Table');
    self.PTM_table = SharedService.getVar('PTM_table');
    self.enrichmentNetwork = SharedService.getVar('enrichmentNetwork');
    self.ptmNetwork = SharedService.getVar('ptmNetwork');
    self.network = SharedService.getVar('network');
    self.phosphoNetwork = SharedService.getVar('phosphoNetwork');
    self.kinaseNetwork = SharedService.getVar('kinaseNetwork');
    self.kinaseTable = SharedService.getVar('kinaseTable');
    $scope.showGeneNetworkProcessed = SharedService.getVar('showGeneNetworkProcessed');
    $scope.showGeneIlincsProcessed = SharedService.getVar('showGeneIlincsProcessed');
    $scope.showGeneEnrichmentProcessed = SharedService.getVar('showGeneEnrichmentProcessed');
    self.showGeneNetwork = SharedService.getVar('showGeneNetwork');
    $scope.showKinaseNetworkProcessed = SharedService.getVar('showKinaseNetworkProcessed');
    self.ptmToModifierPtmOrGene = SharedService.getVar('ptmToModifierPtmOrGene');
    self.proteinToPathwayPathwayOrGene = SharedService.getVar('proteinToPathwayPathwayOrGene');
    self.showPhosphoGraph = false;
    self.showKinaseGraph = false;
    self.showPathwayGraph = false;
    self.showPtmGraph = false;
    self.showEnrichmentGraph = false;

    self.showPhosphoGraphTmp = false;
    self.showKinaseGraphTmp = false;
    self.showPathwayGraphTmp = false;
    self.showPtmGraphTmp = false;
    self.showEnrichmentGraphTmp = false;

    self.showGeneSubmit = false;
    self.showPtmSubmit = false;
    $scope.phosphoOptions = SharedService.getVar('phosphoOptions');

    $scope.selectedphosphoPathways = SharedService.getVar('selectedphosphoPathways');

    $scope.selectedphosphoPathways = SharedService.getVar('selectedphosphoPathways');

    self.ilincsPerturbationsTable = SharedService.getVar('ilincsPerturbationsTable');
    self.ilincsCmapTable = SharedService.getVar('ilincsCmapTable');
    self.ilincsKnockdownTable = SharedService.getVar('ilincsKnockdownTable');
    self.ilincsSignatureUrl = SharedService.getVar('ilincsSignatureUrl');
    self.showGeneEnrichmentChangeProcessed = true;
    // self.showOutputPtm = false;
    // self.showOutputPathway = false;
    //     self.showGeneNetwork = false;
    //var svg = SharedService.getVar('svg');
    self.signatureTab = SharedService.getVar("signatureTab");
    //SharedService.setVar('showModal', false);
    //self.resultTab = SharedService.getVar("resultTab");


    self.ex1orex2Pathway = SharedService.getVar("ex1orex2Pathway");
    //self.showOutputex1orex2 = SharedService.getVar("showOutputex1orex2");

    $('input[name=tabset2p][id=' + self.ex1orex2Pathway + ']').prop('checked', true);
    $("input[name='tabset2p']").click(function () {
        self.ex1orex2Pathway = this.id;
        console.log(self.ex1orex2Pathway);

        SharedService.setVar("ex1orex2Pathway", self.ex1orex2Pathway);
        $scope.$apply();

    });

    $('input[name=tabsPP][id=' + self.signatureTab + ']').prop('checked',true);
    $("input[name='tabsPP']").click(function () {
        self.signatureTab = this.id;
        SharedService.setVar("signatureTab", self.signatureTab);

    });


    self.proteinToPathwayResultTab = SharedService.getVar("proteinToPathwayResultTab");
    //self.resultTab = SharedService.getVar("resultTab");

    $('input[name=tabs][id=' + self.proteinToPathwayResultTab + ']').prop('checked',true);
    $("input[name='tabs']").click(function () {
        self.proteinToPathwayResultTab = this.id;
        SharedService.setVar("proteinToPathwayResultTab", self.proteinToPathwayResultTab);

    });


    $(document).ready(function () {
        $("#div1").scroll(function () {
            $("#div2").scrollTop($("#div1").scrollTop());
            $("#div2").scrollLeft($("#div1").scrollLeft());
            $("#div1-2").scrollTop($("#div1").scrollTop());
            $("#div1-2").scrollLeft($("#div1").scrollLeft());
        });
        $("#div1-2").scroll(function () {
            $("#div2").scrollTop($("#div1-2").scrollTop());
            $("#div2").scrollLeft($("#div1-2").scrollLeft());
            $("#div1").scrollTop($("#div1-2").scrollTop());
            $("#div1").scrollLeft($("#div1-2").scrollLeft());
        });
        $("#div2").scroll(function () {
            $("#div1").scrollTop($("#div2").scrollTop());
            $("#div1").scrollLeft($("#div2").scrollLeft());
            $("#div1-2").scrollTop($("#div2").scrollTop());
            $("#div1-2").scrollLeft($("#div2").scrollLeft());
        });

    });

    $(document).ready(function () {
        $("#div3").scroll(function () {
            $("#div4").scrollTop($("#div3").scrollTop());
            $("#div4").scrollLeft($("#div3").scrollLeft());
        });
        $("#div4").scroll(function () {
            $("#div3").scrollTop($("#div4").scrollTop());
            $("#div3").scrollLeft($("#div4").scrollLeft());
        });

    });


    $(document).ready(function () {
        $("#div5").scroll(function () {
            $("#div6").scrollTop($("#div5").scrollTop());
            $("#div6").scrollLeft($("#div5").scrollLeft());
        });
        $("#div6").scroll(function () {
            $("#div5").scrollTop($("#div6").scrollTop());
            $("#div5").scrollLeft($("#div6").scrollLeft());
        });

    });


    $(document).ready(function () {
        $("#div7").scroll(function () {
            $("#div8").scrollTop($("#div7").scrollTop());
            $("#div8").scrollLeft($("#div7").scrollLeft());
        });
        $("#div8").scroll(function () {
            $("#div7").scrollTop($("#div8").scrollTop());
            $("#div7").scrollLeft($("#div8").scrollLeft());
        });

    });

    $(document).ready(function () {
        $("#div9").scroll(function () {
            $("#div10").scrollTop($("#div9").scrollTop());
            $("#div10").scrollLeft($("#div9").scrollLeft());
            $("#div10-1").scrollTop($("#div9").scrollTop());
            $("#div10-1").scrollLeft($("#div9").scrollLeft());
        });
        $("#div10").scroll(function () {
            $("#div9").scrollTop($("#div10").scrollTop());
            $("#div9").scrollLeft($("#div10").scrollLeft());
            $("#div10-1").scrollTop($("#div10").scrollTop());
            $("#div10-1").scrollLeft($("#div10").scrollLeft());
        });
        $("#div10-1").scroll(function () {
            $("#div9").scrollTop($("#div10-1").scrollTop());
            $("#div9").scrollLeft($("#div10-1").scrollLeft());
            $("#div10").scrollTop($("#div10-1").scrollTop());
            $("#div10").scrollLeft($("#div10-1").scrollLeft());
        });
    });

    $(document).ready(function () {
        $("#div11").scroll(function () {
            $("#div12").scrollTop($("#div11").scrollTop());
            $("#div12").scrollLeft($("#div11").scrollLeft());
            $("#div12-1").scrollTop($("#div11").scrollTop());
            $("#div12-1").scrollLeft($("#div11").scrollLeft());
        });
        $("#div12").scroll(function () {
            $("#div11").scrollTop($("#div12").scrollTop());
            $("#div11").scrollLeft($("#div12").scrollLeft());
            $("#div12-1").scrollTop($("#div12").scrollTop());
            $("#div12-1").scrollLeft($("#div12").scrollLeft());
        });
        $("#div12-1").scroll(function () {
            $("#div11").scrollTop($("#div12-1").scrollTop());
            $("#div11").scrollLeft($("#div12-1").scrollLeft());
            $("#div12").scrollTop($("#div12-1").scrollTop());
            $("#div12").scrollLeft($("#div12-1").scrollLeft());
        });

    });


    $scope.openIframeModal = function (linkID, type) {


        var modalInstance = $uibModal.open({
            animation: $scope.animationsEnabled,
            // templateUrl: 'myModalContent.html',
            templateUrl: 'myModalContent.html',
            controller: 'iFrameModalInstanceCtrl',
            size: 'xxl',
            windowClass: 'app-modal-window',
            resolve: {
                linkID: function () {
                    return linkID;
                },
                type: function () {
                    return type;
                }
            }
        });
    }


    function convertToCSV(objArray) {
        var array = typeof objArray != 'object' ? JSON.parse(objArray) : objArray;
        var str = '';

        for (var i = 0; i < array.length; i++) {
            var line = '';
            for (var index in array[i]) {
                if (line != '') line += ','

                line += array[i][index];
            }

            str += line + '\r\n';
        }

        return str;
    }

    function exportCSVFile(headers, items, fileTitle) {
        console.log(items);
        if (headers) {
            items.unshift(headers);
        }
        console.log(items);
        // Convert Object to JSON
        var jsonObject = JSON.stringify(items);
        console.log(jsonObject);
        var csv = convertToCSV(jsonObject);

        var exportedFilenmae = fileTitle + '.csv' || 'export.csv';

        var blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        if (navigator.msSaveBlob) { // IE 10+
            navigator.msSaveBlob(blob, exportedFilenmae);
        } else {
            var link = document.createElement("a");
            if (link.download !== undefined) { // feature detection
                // Browsers that support HTML5 download attribute
                var url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", exportedFilenmae);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }
    }

    $scope.exportCsvGeneral = function(data,name){
        var objKeys = Object.keys(data[0]);
        var headers = {};
        for (var i = 0; i < objKeys.length; i++){
            headers[objKeys[i]] = objKeys[i];
        }
        exportCSVFile(headers, data, name);

    }


    $scope.exportKinaseTable = function(){

        self.kinaseForDownload = [];
        self.kinaseTable.map(function (e) {
            var gene = e.gene;
            var upstream = e.upstream;
            var downstream = e.downstream;
            var geneInfoElem = {};


            //symbol	hgnc_id	prev_symbol	name	uniprot_ids	gene_family_name	gene_family_id
            geneInfoElem["gene"] = gene.replace(",", ";");
            geneInfoElem["upstream"] = upstream.join(" | ");
            geneInfoElem["downstream"] = downstream.join(" | ");


            // console.log(prev_symbol);
            // console.log(uniprot_ids);
            // ontologyMappingsElem["mostSimilar"] = mostSimilarElem;
            // ontologyMappingsElem["family"] = familyElem;

            self.kinaseForDownload.push(geneInfoElem);


        });
        $scope.exportCsvGeneral(self.kinaseForDownload,'pinet-Kinase-Network');
        //exportCSVFile(headers, data, name);

    }

    $scope.exportEnrichmentTable = function(){

        self.enrichmentForDownload = [];
        $scope.enrichmentTable.map(function (e) {
            var pathway = e.pathway;
            var genes = e.genes;
            var pValue = e.pValue;
            var geneInfoElem = {};


            //symbol	hgnc_id	prev_symbol	name	uniprot_ids	gene_family_name	gene_family_id
            geneInfoElem["pathway"] = pathway.replace(",", ";");
            geneInfoElem["genes"] = genes.join(" | ");
            geneInfoElem["pValue"] = pValue;


            // console.log(prev_symbol);
            // console.log(uniprot_ids);
            // ontologyMappingsElem["mostSimilar"] = mostSimilarElem;
            // ontologyMappingsElem["family"] = familyElem;

            self.enrichmentForDownload.push(geneInfoElem);


        });
        $scope.exportCsvGeneral(self.enrichmentForDownload,'pinet-Enrichr-' + $scope.enrichmentItem);
        //exportCSVFile(headers, data, name);

    }

    $scope.exportDataGeneInfo = function () {
        console.log(self.inputGeneInfo);
        self.geneInfosForDownload = [];


        self.inputGeneInfo.map(function (e) {

            var symbol = e.symbol;
            var hgnc_id = e.hgnc_id;
            var prev_symbol = e.prev_symbol;
            var name = e.name;
            var uniprot_ids = e.uniprot_ids;
            var gene_family_name = e.gene_family_name;


            var geneInfoElem = {};
            console.log(uniprot_ids);

            //symbol	hgnc_id	prev_symbol	name	uniprot_ids	gene_family_name	gene_family_id
            geneInfoElem["symbol"] = symbol;
            geneInfoElem["hgnc_id"] = hgnc_id;
            geneInfoElem["prev_symbol"] = prev_symbol.join(" | ");
            geneInfoElem["name"] = name;
            geneInfoElem["uniprot_ids"] = uniprot_ids.join(" | ");
            geneInfoElem["gene_family_name"] = gene_family_name;

            console.log(prev_symbol);
            console.log(uniprot_ids);
            // ontologyMappingsElem["mostSimilar"] = mostSimilarElem;
            // ontologyMappingsElem["family"] = familyElem;

            self.geneInfosForDownload.push(geneInfoElem);

        });
        //console.log(self.ontologyMappingsForDownload);
        $scope.exportCsvGeneral(self.geneInfosForDownload,'pinet-GeneInfos');

        //alasql('SELECT * INTO XLSX("PSI-MOD-ontologyMappings.xlsx",{headers:true}) FROM ?', [self.ontologyMappingsForDownload]);

    };


    // $scope.exportDataGeneInfo = function () {
    //     //console.log(self.inputGeneInfo);
    //     alasql('SELECT * INTO XLSX("geneInfo.xlsx",{headers:true}) FROM ?', [self.inputGeneInfo]);
    // };

    self.listOfGenesOrptmProteins = [];
    if ($routeParams.tab == 'geneList' || $routeParams.tab == 'pathwayList') {
        self.proteinToPathwayPathwayOrGene = $routeParams.tab;
    }
    self.listOfGenesOrptmProteins = $routeParams.list;
    if ($routeParams.organism == '9606' || $routeParams.organism == '10090' || $routeParams.organism == '10116') {
        self.organismForm = $routeParams.organism;
    }
    if (typeof self.listOfGenesOrptmProteins !== 'undefined' && self.listOfGenesOrptmProteins.length > 0 )
    {
        self.genes = self.listOfGenesOrptmProteins;
    }


    //console.log("---------");
    //console.log($routeParams.tab);
    //console.log("---------");
    //console.log("---------");
    //console.log($routeParams.list);
    //console.log("---------");

    //self.organismFormProteinToPathway = SharedService.getVar('organismFormProteinToPathway');

    $('input[name=r3][value=' + self.organismForm + ']').prop('checked',true);

    $('input[name=tabset][id=' + self.ptmToModifierPtmOrGene + ']').prop('checked',true);

    if (!$("input[name='tabset']").is(":checked")) {
        //console.log("checked no");
        $("#ptmProteinList").prop("checked", true);
        SharedService.setVar("tabForProtein2Pathways", 'ptmProteinList');


    }
    if (!$("input[name='r3']").is(":checked")) {
        //console.log("checked no");
        $("#homosapiens").prop("checked", true);
    }

    $("input[name='tabset']").click(function () {
        self.ptmToModifierPtmOrGene = this.id;
        SharedService.setVar("ptmToModifierPtmOrGene", self.ptmToModifierPtmOrGene);
        //$location.url("/ptmToModifier?tab="+self.ptmToModifierPtmOrGene);
        self.url = $location.url();
        //console.log(self.url);
        //$window.sessionStorage.setItem("tabForProtein2Pathways", self.ptmToModifierPtmOrGene);
        //console.log(self.ptmToModifierPtmOrGene);
    });

    $scope.$on('$locationChangeStart' , 'SharedService', function(event, SharedService) {
        // call your method here

        if($location.url().contains('ptmToModifier') || $location.url().contains('peptideToProtein') || $location.url().contains('proteinToPathway') || $location.url().contains('help') || $location.url().contains('upload') || $location.url().contains('modification')) {
            SharedService.setVar('showSplash',false);
            self.showSplash = SharedService.getVar(showSplash);
            //console.log($location.url());
            //console.log($location.url());
            //console.log("self.showSplash");
            //console.log(self.showSplash);
            //console.log($location.url());
            self.firstVisit = false;
            SharedService.setVar('firstVisit', false);
            //$scope.$apply();
        }
        else
        {
            //console.log($location.url());
            if (self.firstVisit == false) {

                SharedService.setVar('showSplash',false);
                self.showSplash = SharedService.getVar(showSplash);
                //$location.url("/ptmToModifier?tab="+self.ptmToModifierPtmOrGene);
                $location.url("/ptmToModifier");
                self.url = $location.url();
                //console.log($location.url());
            }
            //console.log("self.showSplash");
            //console.log(self.showSplash);
            //console.log("self.firstVisit");
            //console.log(self.firstVisit);
            //$scope.$apply();
        }
    });

    $scope.goToPeptideToProtein = function () {
        $location.url("/peptideToProtein");
        self.url = $location.url();
        //console.log($location.url());
    };

    $scope.goToPtmToModifier = function () {
        $location.url("/ptmToModifier");
        //$location.url("/ptmToModifier?tab="+self.ptmToModifierPtmOrGene);
        self.url = $location.url();
        //console.log(self.url);
    };

    $scope.goToAbout = function () {
        $location.url("/help");
        self.url = $location.url();
    };



    $scope.goToProteinToPathway = function () {
        $location.url("/proteinToPathway");
        self.url = $location.url();
    };

    $scope.$watch(function () {
        return self.inputMassPtmProteins
    }, function (newValue, oldValue) {


        if (self.inputMassPtmProteins.length > 0) {
            self.ptmProteinToAbundanceMap = {};

            self.proteinAbundance = self.inputMassPtmProteins
                .split(self.rowSplitPattern)
                .map(function (e) {
                    if (e) {
                        // var str = e.split(/[\s,]+/).join();
                        // //console.log(str);
                        // var str2 = str.replace(/[\s,]+/g, ',');
                        // //console.log(str2);
                        var str2 = e.replace(/,/g, '').replace(/^\s\s*/, '').replace(/\s\s*$/, '').replace(/[\s,]+/g, ',');
                        ////console.log(str2);
                        if (str2.indexOf(',') > -1) {
                            str2 = str2.split(',').slice(1);

                            return str2[0];
                        }
                        else {

                            return "NA";
                        };

                    }


                });

            ////console.log(self.proteinAbundance);


            self.parsedPTMs = self.inputMassPtmProteins
                .split(self.rowSplitPatternGenes)
                .map(function (e) {
                    ////console.log(e.match(self.modificationPatternForAllPTMs));
                    return e.match(self.modificationPatternForAllPTMs);

                });


            self.parsedPTMProteins = self.inputMassPtmProteins
                .split(self.rowSplitPatternGenes)
                .map(function (e) {

                    var str2 = e.replace(/,/g, '').replace(/^\s\s*/, '').replace(/\s\s*$/, '').replace(/[\s,]+/g, ',');
                    ////console.log(str2);
                    if (str2.indexOf(',') > -1) {
                        str2 = str2.split(',').slice(0);

                        return str2[0].match(self.modificationPatternForAllProteins);
                    }
                    else{
                        return e.match(self.modificationPatternForAllProteins);
                    }

                    // if (e.indexOf('[') > -1) {
                    //     return e
                    // }
                    //return e.toUpperCase().match(self.modificationForptmProteins);;
                });

            self.inputMassPtmProteinsModified = self.inputMassPtmProteins
                .split(self.rowSplitPatternGenes)
                .map(function (e) {

                    var str2 = e.replace(/,/g, '').replace(/^\s\s*/, '').replace(/\s\s*$/, '').replace(/[\s,]+/g, ',');
                    ////console.log(str2);
                    if (str2.indexOf(',') > -1) {
                        str2 = str2.split(',').slice(0);

                        return str2[0];
                    }
                    else{
                        return e;
                    }

                    // if (e.indexOf('[') > -1) {
                    //     return e
                    // }
                    //return e.toUpperCase().match(self.modificationForptmProteins);;
                });



            for (var i = 0; i < self.inputMassPtmProteinsModified.length; i++) {
                self.ptmProteinToAbundanceMap[self.inputMassPtmProteinsModified[i]] = self.proteinAbundance[i];
                //Do something
            }
            //console.log("ptmProteinToAbundanceMap");
            //console.log(self.ptmProteinToAbundanceMap);

            self.parsedPTMProteins.clean(undefined);


        }
        if (self.parsedPTMProteins.length == 0) {
            self.showPhosphoGeneNetwork = false;
            SharedService.setVar('showPhosphoGeneNetwork', self.showPhosphoGeneNetwork);
            //console.log("self.showPhosphoGeneNetwork = false;");
        }
        // .filter(function (el) {
        //         return (el !== null);
        //     });
        //Because We need this for api query
        self.inputMassPtmProteinsModifiedForQuery = self.inputMassPtmProteinsModified.toString();
        //console.log(self.parsedGenes);
        //console.log(self.parsedPTMProteins);
        //console.log(self.inputMassPtmProteinsModified);
        //console.log(self.parsedPTMs);
        //console.log(self.showPhosphoGeneNetwork);
        //console.log(self.showGeneNetwork);
        self.showPtmSubmit = true;
        SharedService.setVar('inputMassPtmProteins',self.inputMassPtmProteins);

    });


    var timeout;

    $scope.$watch(function () {
        return self.genes
    }, function (newValue, oldValue) {
        //console.log("in scope gene!---------------------------------------");
        //localStorage.setItem("genes", self.genes);
        //console.log("Setting genes -----");
        self.showGeneSubmit = false;
        self.showOutputPathway = false;
        // var localselfGenes = localStorage.getItem("genesForProtein2Pathways");
        // //console.log(localselfGenes);
        // $scope.showGeneNetworkProcessed = false;
        // $scope.showKinaseNetworkProcessed = false;
        // self.showGeneNetwork = true;
        //
        // SharedService.setVar('showGeneNetwork', self.showGeneNetwork);
        // SharedService.setVar('showGeneNetworkProcessed', $scope.showGeneNetworkProcessed);
        // SharedService.setVar('showKinaseNetworkProcessed', $scope.showKinaseNetworkProcessed);
        if (self.genes.length > 0) {
            self.geneToAbundanceMap = {};
            self.geneAndAbundance = [];
            self.parsedGenes = self.genes
                .split(self.rowSplitPattern)
                .map(function (e) {
                    if (e) {

                        var str2 = e.replace(/,/g, '').replace(/\//g, '').replace(/^\s\s*/, '').replace(/\s\s*$/, '').replace(/[\s,]+/g, ',');
                        ////console.log(str2);
                        if (str2.indexOf(',') > -1) {
                            str2 = str2.split(',').slice(0);

                            return str2[0];
                        }
                        else {
                            return str2;
                        }
                        ;
                    }


                });


            // .split(self.rowSplitPatternGenes)
            // .map(function (e) {
            //     if (e.indexOf('[') == -1) {
            //         return e
            //     }
            // });
            self.parsedGenes.clean(undefined);
            //console.log(self.parsedGenes);
            self.geneAbundance = self.genes
                .split(self.rowSplitPattern)
                .map(function (e) {
                    if (e) {
                        // var str = e.split(/[\s,]+/).join();
                        // //console.log(str);
                        // var str2 = str.replace(/[\s,]+/g, ',');
                        // //console.log(str2);
                        var str2 = e.replace(/,/g, '').replace(/\//g, '').replace(/^\s\s*/, '').replace(/\s\s*$/, '').replace(/[\s,]+/g, ',');
                        ////console.log(str2);
                        if (str2.indexOf(',') > -1) {
                            str2 = str2.split(',').slice(1);

                            return str2[0];
                        }
                        else {
                            return "NA";
                        };
                    }


                });

            for (var i = 0; i < self.parsedGenes.length; i++) {
                self.geneAndAbundance.push(self.parsedGenes[i]);
                var geneAbundance = self.geneAbundance[i];
                self.geneToAbundanceMap[self.parsedGenes[i]] = geneAbundance;
                self.geneAndAbundance.push(geneAbundance);
                //Do something
            }
            //console.log("geneToAbundanceMap");
            //console.log(self.geneToAbundanceMap);
            //console.log(self.geneAbundance);
        }

        if (self.parsedGenes.length == 0) {
            self.showGeneNetwork = false;
            SharedService.setVar('showGeneNetwork', self.showGeneNetwork);
            //console.log("self.showGeneNetwork = false;");
        }
        // .filter(function (el) {
        //         return (el !== null);
        //     });
        // .filter(function (el) {
        //     ////console.log(peptide.indexOf(el.modification));
        //     return (peptide.indexOf(el.modification) > -1);
        // })
        // if (self.genes.length > 0) {
        //     self.parsedPTMProteins = self.genes
        //         .split(self.rowSplitPatternGenes)
        //         .map(function (e) {
        //             if (e.indexOf('[') > -1) {
        //                 return e
        //             }
        //             //return e.toUpperCase().match(self.modificationForptmProteins);;
        //         });
        //     self.parsedPTMProteins.clean(undefined);
        // }
        // if (self.parsedPTMProteins.length == 0) {
        //     self.showPhosphoGeneNetwork = false;
        //     //console.log("self.showPhosphoGeneNetwork = false;");
        // }
        // .filter(function (el) {
        //         return (el !== null);
        //     });
        //console.log(self.parsedGenes);
        // //console.log(self.parsedPTMProteins);
        // //console.log(self.showPhosphoGeneNetwork);
        //console.log(self.showGeneNetwork);
        SharedService.setVar('genes', self.genes);
    });


    $scope.$watch(function () {
        return self.parsedGenes

    }, function (nV, oV) {
        //console.log("in scope parsed gene!+++++++++++++++++++++++++++++++++++++");
        //self.showOutputPathway = false;
        self.flagFoundNPCG = false;
        self.waitingPathway = true;
        //self.showOutputPathway = false;
        //console.log("self.showOutputPathway");
        //console.log(self.showOutputPathway);
        //console.log(self.parsedGenes);

        // This is for slicing the input genes because it makes problems if we have long list of genes in the http.get

        if (timeout) {
            $timeout.cancel(timeout);
        };
        $timeout(function () {
            self.genePlaces = [];
            self.inputGeneInfo = [];
            self.nonValidGenes = [];
            // self.network = {};
            // self.kinaseNetwork = {};
            self.numberOfAllInputGenes = 0;
            self.numberOfAllValidGenes = 0;
            //console.log("self.parsedGenes.length");
            //console.log(self.parsedGenes.length);
            var genePartitioned = function splitarray(input, spacing) {
                var output = [];

                for (var i = 0; i < input.length; i += spacing) {
                    output[output.length] = input.slice(i, i + spacing);
                }

                return output;
            }(self.parsedGenes, self.parsedGenes.length)

            //console.log(genePartitioned);
            //console.log(genePartitioned.length);
            // var flag = true;
            // while (flag){
            //     var queryGeneList = [];
            //     self.parsedGenes
            //
            // }
            if (genePartitioned.length > 0) {
                for (i = 0; i < genePartitioned.length; i++) {

                    $http.get("api/pcg/checkgenes/" + genePartitioned[i])
                        .success(function (genePositions) {
                            //console.log("genePositions");
                            //console.log(genePositions);
                            self.genePlaces = genePositions;
                            for (var geneIter = 0; geneIter < self.genePlaces.length; geneIter++) {
                                self.numberOfAllInputGenes = self.numberOfAllInputGenes + 1;
                                if (self.genePlaces[geneIter] != -1) {
                                    self.numberOfAllValidGenes = self.numberOfAllValidGenes + 1;
                                }
                                else {
                                    self.flagFoundNPCG = true;
                                    self.nonValidGenes.push(self.parsedGenes[geneIter]);
                                    //console.log("self.nonValidGenes");
                                    //console.log(self.nonValidGenes);
                                }
                            }
                            // self.genePlaces.forEach(function (e) {
                            //     self.numberOfAllInputGenes = self.numberOfAllInputGenes + 1;
                            //     if (e != -1) {
                            //         self.numberOfAllValidGenes = self.numberOfAllValidGenes + 1;
                            //     }
                            //     else
                            //     {
                            //         self.nonValidGenes.push(self.parsedGenes[])
                            //     }
                            //     ;
                            // });
                            //self.inputGeneInfo = [];
                            $http.get("api/pcg/geneinfo/" + self.genePlaces)
                                .success(function (geneInfos) {
                                    self.inputGeneInfo = [];
                                    //console.log(geneInfos);
                                    for (var geneInfoIter = 0; geneInfoIter < geneInfos.length; geneInfoIter++) {
                                        self.inputGeneInfo.push(geneInfos[geneInfoIter]);
                                    }
                                    self.inputGeneInfoTable = new NgTableParams({
                                        count: 5
                                    }, {
                                        total: self.inputGeneInfo.length,  dataset: self.inputGeneInfo,counts: [5, 10, 25]});
                                    //SharedService.set("inputGeneInfoTable",self.inputGeneInfoTable);
                                    //console.log(self.inputGeneInfo);
                                    self.showGeneSubmit = true;
                                })
                                .error(function () {
                                    //console.log("Error in obtaining gene info from api/pcg/geneinfo/");
                                    self.showGeneSubmit = true;
                                });
                        })
                        .error(function () {
                            //console.log("Error in obtaining gene place from api/pcg/checkgenes/");
                            self.geneNameError = true;
                        });
                }
            }

        }, 1100);

    });


    //var svgCola = d3cola.selectAll("#chart4").append("svg");

    // var svg3 = d3.selectAll("#chart3").append("svg");


    self.onSubmitPathway = function () {

        self.computeWeightForUpdateEnrichment = true;
        self.computeWeightForUpdate = true;
        self.computeWeightForUpdateKinase = true;
        $scope.showGeneNetworkProcessed = false;
        $scope.showGeneIlincsProcessed = false;
        $scope.showGeneEnrichmentProcessed = false;
        $scope.showKinaseNetworkProcessed = false;
        $scope.showIlincsProcessed = false;
        self.showPathwayGraph = false;
        self.showEnrichmentGraph = false;
        self.showKinaseGraph = false;
        self.showGeneNetwork = true;
        self.showOutputPathway = false;
        self.showPhosphoGraphTmp = false;
        self.showKinaseGraphTmp = false;
        self.showPathwayGraphTmp = false;
        self.showPtmGraphTmp = false;
        self.showEnrichmentGraphTmp = false;
        SharedService.setVar('showGeneNetwork', self.showGeneNetwork);
        SharedService.setVar('showGeneEnrichmentProcessed', $scope.showGeneEnrichmentProcessed);
        SharedService.setVar('showGeneNetworkProcessed', $scope.showGeneNetworkProcessed);
        SharedService.setVar('showGeneOlincsProcessed', $scope.showGeneOlincsProcessed);
        SharedService.setVar('showKinaseNetworkProcessed', $scope.showKinaseNetworkProcessed);
        self.secondPageQuery = true;
        self.pathwayWaiting = true;
        //console.log("!self.secondPageQuery");
        //console.log(!self.secondPageQuery);
        //self.inputPtmProteins = self.geneIdListMassCombined;
        // //console.log(self.geneIdListShorthandCombined);
        //console.log(" ----------------  ");
        //console.log(" onSubmitPathway  ");


        $http.get("api/increment/" + 3)
            .success(function (siteVisit) {

                self.siteVisit = siteVisit;

            })
            .error(function (data, status) {

                self.siteVisit = {"all": "", "peptide": "", "gene": "", "ptm": ""}

            });

        //console.log("self.geneAndAbundance");
        //console.log(self.geneAndAbundance);
        //console.log(self.geneAbundance);
        if (self.parsedGenes.length > 0) {
            var sizeOfNonNans = 0;
            $scope.geneIlincsError = false;
            $scope.genePathwayError = false;
            var arrayLength = self.geneAbundance.length;
            for (var i = 0; i < arrayLength; i++) {

                if(!(isNaN(self.geneAbundance[i])))
                {
                    sizeOfNonNans += 1;
                }
                //console.log(self.geneAbundance[i]);
                //Do something
            }
            //console.log(sizeOfNonNans);
            //var spinner = new Spinner(opts).spin(target);
            if (sizeOfNonNans > 3){
                //console.log(sizeOfNonNans);
                $scope.geneIlincsError = false;
                $http.get("api/ilincs/signature/" + self.geneAndAbundance)
                    .success(function (apiIlincs) {
                        //console.log("api/ilincs/signature/ success!")
                        $scope.showGeneIlincsProcessed = true;
                        //console.log("$scope.showGeneIlincsProcessed");
                        //console.log($scope.showGeneIlincsProcessed);
                        SharedService.setVar('showGeneIlincsProcessed', $scope.showGeneIlincsProcessed);
                        //spinner.stop();
                        self.ilincs = apiIlincs;
                        //SharedService.setVar('network', self.network);

                        //console.log(self.ilincs);
                        self.ilincsSignatureUrl = apiIlincs["url"];
                        SharedService.setVar('ilincsSignatureUrl', self.ilincsSignatureUrl);
                        self.ilincsCmap = apiIlincs["cMAP"];
                        self.ilincsPerturbations = apiIlincs["perturbations"];
                        self.ilincsKnockdown = apiIlincs["knockdown"];

                        // self.ilincsKnockdownTable
                        self.ilincsKnockdownTable = new NgTableParams({
                            count: 5
                        }, {
                            total: self.ilincsKnockdown.length,  dataset: self.ilincsKnockdown,counts: [5, 10, 25]});

                        self.ilincsCmapTable= new NgTableParams({
                        count: 5
                        }, {
                        total: self.ilincsCmap.length,  dataset: self.ilincsCmap,counts: [5, 10, 25]});

                        self.ilincsPerturbationsTable = new NgTableParams({
                            count: 5
                        }, {
                            total: self.ilincsPerturbations.length,  dataset: self.ilincsPerturbations,counts: [5, 10, 25]});

                        SharedService.setVar('ilincsPerturbationsTable', self.ilincsPerturbationsTable);
                        SharedService.setVar('ilincsCmapTable', self.ilincsCmapTable);
                        SharedService.setVar('ilincsKnockdownTable', self.ilincsKnockdownTable);

                        self.pathwayWaiting = false;



                        ////console.log(self.network);

                    })
                    .error(function (apiIlincsError) {
                        //console.log("Error in obtaining network from api/ilincs/signature/");
                        //console.log(apiIlincsError);
                        self.ilincs = {"cMAP":[],"perturbations":[],"knockdown":[]};
                            self.ilincsCmap = self.ilincs["cMAP"];
                            self.ilincsPerturbations = self.ilincs["perturbations"];
                            self.ilincsKnockdown = self.ilincs["knockdown"];

                            // self.ilincsKnockdownTable
                            self.ilincsKnockdownTable = new NgTableParams({
                                count: 5
                            }, {
                                total: self.ilincsKnockdown.length,  dataset: self.ilincsKnockdown,counts: [5, 10, 25]});

                            self.ilincsCmapTable= new NgTableParams({
                                count: 5
                            }, {
                                total: self.ilincsCmap.length,  dataset: self.ilincsCmap,counts: [5, 10, 25]});

                            self.ilincsPerturbationsTable = new NgTableParams({
                                count: 5
                            }, {
                                total: self.ilincsPerturbations.length,  dataset: self.ilincsPerturbations,counts: [5, 10, 25]});

                            SharedService.setVar('ilincsPerturbationsTable', self.ilincsPerturbationsTable);
                            SharedService.setVar('ilincsCmapTable', self.ilincsCmapTable);
                            SharedService.setVar('ilincsKnockdownTable', self.ilincsKnockdownTable);
                        $scope.geneIlincsError = true;
                    }
                    );
            }
            else{
                $scope.geneIlincsError = false;
                $scope.showGeneIlincsProcessed = true;
                //console.log($scope.showGeneIlincsProcessed);
                SharedService.setVar('showGeneIlincsProcessed', $scope.showGeneIlincsProcessed);

                self.ilincs = {"cMAP":[],"perturbations":[],"knockdown":[]};
                self.ilincsCmap = self.ilincs["cMAP"];
                self.ilincsPerturbations = self.ilincs["perturbations"];
                self.ilincsKnockdown = self.ilincs["knockdown"];

                // self.ilincsKnockdownTable
                self.ilincsKnockdownTable = new NgTableParams({
                    count: 5
                }, {
                    total: self.ilincsKnockdown.length,  dataset: self.ilincsKnockdown,counts: [5, 10, 25]});

                self.ilincsCmapTable= new NgTableParams({
                    count: 5
                }, {
                    total: self.ilincsCmap.length,  dataset: self.ilincsCmap,counts: [5, 10, 25]});

                self.ilincsPerturbationsTable = new NgTableParams({
                    count: 5
                }, {
                    total: self.ilincsPerturbations.length,  dataset: self.ilincsPerturbations,counts: [5, 10, 25]});

                SharedService.setVar('ilincsPerturbationsTable', self.ilincsPerturbationsTable);
                SharedService.setVar('ilincsCmapTable', self.ilincsCmapTable);
                SharedService.setVar('ilincsKnockdownTable', self.ilincsKnockdownTable);

            }
        }


        $scope.redirectToiLincs = function(){
            $window.open(self.ilincsSignatureUrl+"?mainTab=2", '_blank');
        };
        if(2 < 1) {

            if (self.parsedGenes.length > 0) {
                //var spinner = new Spinner(opts).spin(target);
                $scope.genePathwayError = false;
                $http.get("api/network/genes/" + self.parsedGenes)
                    .success(function (apiNetwork) {
                        //console.log("api/network/genes/ success!")
                        $scope.showGeneNetworkProcessed = true;
                        //console.log("$scope.showGeneNetworkProcessed");
                        //console.log($scope.showGeneNetworkProcessed);
                        SharedService.setVar('showGeneNetworkProcessed', $scope.showGeneNetworkProcessed);
                        //spinner.stop();
                        self.network = apiNetwork;
                        //SharedService.setVar('network', self.network);

                        console.log(self.network);

                        self.pathwayWaiting = false;


                        //console.log(self.network);

                    })
                    .error(function () {
                        //console.log("Error in obtaining network from api/network/genes/");
                        $scope.genePathwayError = true;
                    });
            }
        }

        if (self.parsedGenes.length > 0) {
            //var spinner = new Spinner(opts).spin(target);
            $scope.enrichmentError = false;
            $http.get("api/enrichment/target/" + 'KEGG_2019_Human' + "/genes/" + self.parsedGenes)
                .success(function (apiNetwork) {
                    $scope.showGeneEnrichmentProcessed = true;
                    SharedService.setVar('showGeneEnrichmentProcessed', $scope.showGeneEnrichmentProcessed);
                    //spinner.stop();
                    // self.enrichmentNetwork = {};
                    // self.enrichmentNetwork
                    self.enrichmentNetwork['KEGG_2019_Human'] = apiNetwork;
                    SharedService.setVar('enrichmentNetwork', self.enrichmentNetwork);

                    //console.log(self.enrichmentNetwork);

                    self.pathwayWaiting = false;



                    ////console.log(self.network);

                })
                .error(function () {
                    //console.log("Error in obtaining network from api/enrichment/genes/");
                    $scope.enrichmentError = true;
                });
        }
        // +++++++++++++++++++++++++++++++++++++++++
        // +++++++++++++++++++++++++++++++++++++++++
        // Kinase pathway analysis


        if (self.parsedGenes.length > 0) {
            $scope.kinaseError = false;
            //var spinner2 = new Spinner(opts).spin(target2);
            $http.get("api/kinase/genes/" + self.parsedGenes)
                .success(function (apiKinaseNetwork) {

                    $scope.showKinaseNetworkProcessed = true;
                    //console.log("showKinaseNetworkProcessed");
                    //console.log($scope.showKinaseNetworkProcessed);
                    SharedService.setVar('showKinaseNetworkProcessed', $scope.showKinaseNetworkProcessed);
                    //spinner2.stop();
                    //console.log("kinaseNetwork");

                    self.kinaseNetwork = apiKinaseNetwork.network;
                    SharedService.setVar('kinaseNetwork', self.kinaseNetwork);


                    self.kinaseTable = apiKinaseNetwork.table;
                    console.log("kinaseTable");
                    console.log(self.kinaseTable);
                    SharedService.setVar('kinaseTable', self.kinaseTable);
                    //console.log(self.kinaseNetwork);


                })
                .error(function () {
                    //console.log("Error in obtaining network from api/kinase/genes/");
                    $scope.kinaseError = true;
                });
        }





        self.waitingPathway = false;
        self.showOutputPathway = true;
        SharedService.setVar('showOutputPathway', self.showOutputPathway);
        //console.log("self.showOutputPathway");
        //console.log(self.showOutputPathway);
        // self.waitingPathway = false;
        // self.showOutputPathway = true;
    }


    $scope.graphType4enrich = 1;
    $scope.circleSliderValue4enrich = 1100;
    $scope.nodeSliderValue4enrich = 15;
    $scope.fontSliderValue4enrich = 14;
    $scope.widthSliderValue4enrich = 1500;
    $(document).on('input', '#circle_slider4enrich', function() {
        $('#circle_slider_value4enrich').html( $(this).val() );
        ////console.log($(this).val());
        $scope.circleSliderValue4enrich = $(this).val();

        $scope.$apply();
        $scope.makeEnrichmentGraph(self.enrichmentNetwork, self.geneToAbundanceMap, $scope.graphType4enrich, $scope.circleSliderValue4enrich, $scope.nodeSliderValue4enrich, $scope.fontSliderValue4enrich, $scope.widthSliderValue4enrich);

    });

    $(document).on('input', '#node_slider4enrich', function() {
        $('#node_slider_value4enrich').html( $(this).val() );
        ////console.log($(this).val());
        $scope.nodeSliderValue4enrich = $(this).val();

        $scope.$apply();

        $scope.makeEnrichmentGraph(self.enrichmentNetwork, self.geneToAbundanceMap, $scope.graphType4enrich, $scope.circleSliderValue4enrich, $scope.nodeSliderValue4enrich, $scope.fontSliderValue4enrich, $scope.widthSliderValue4enrich);

    });

    $(document).on('input', '#font_slider4enrich', function() {
        $('#font_slider_value4enrich').html( $(this).val() );
        ////console.log($(this).val());
        $scope.fontSliderValue4enrich = $(this).val();

        $scope.$apply();

        $scope.makeEnrichmentGraph(self.enrichmentNetwork, self.geneToAbundanceMap, $scope.graphType4enrich, $scope.circleSliderValue4enrich, $scope.nodeSliderValue4enrich, $scope.fontSliderValue4enrich, $scope.widthSliderValue4enrich);

    });

    $(document).on('input', '#width_slider4enrich', function() {
        $('#width_slider_value4enrich').html( $(this).val() );
        ////console.log($(this).val());
        $scope.widthSliderValue4enrich = $(this).val();

        $scope.$apply();

        $scope.makeEnrichmentGraph(self.enrichmentNetwork, self.geneToAbundanceMap, $scope.graphType4enrich, $scope.circleSliderValue4enrich, $scope.nodeSliderValue4enrich, $scope.fontSliderValue4enrich, $scope.widthSliderValue4enrich);

    });



    $scope.hideEnrichmentGraph = function () {
        self.showEnrichmentGraphTmp = true;
        self.showEnrichmentGraph = false;
    }

    $scope.makeEnrichmentGraph = function (inputNetwork, geneToAbundance, graphType, circleSliderValue, nodeSliderValue, fontSliderValue, widthSliderValue) {
        //console.log("in makeEnrichmentGraph");
        //console.log(inputNetwork);
        if(self.showEnrichmentGraphTmp)
        {
            self.showEnrichmentGraphTmp = false;
            self.showEnrichmentGraph = true;
        }
        else {
            console.log("in makeEnrichmentGraph");
            self.showEnrichmentGraphTmp = true;
            self.showEnrichmentGraph = false;
            // d3.select("#chart5").remove();
            // if(svg5) {
            //     svg5.remove();
            // };
            d3.select("#chart5").select("svg").remove();
            if (typeof svg5 === 'undefined') {
                var svg5 = d3.selectAll("#chart5").append("svg");
            }

            var force;
            var colNodeScaleSeparate = d3.scale.ordinal()
                .range(["#987024", "#ed0909", "#0af702"])
                //.range(["#987024", "#982482", "#0af702"])
                .domain([0, 1, 2]);
//#f9a3f5
            // var colNodeScaleSeparate = d3.scale.ordinal()
            //     .range(["#767776", "#f91104", "#0af702"])
            //     .domain([0,1,2]);
            var colNodeScalePValue = d3.scale.linear().range(["#ffffff", "#ed0909"]);
            var colNodeScale = d3.scale.linear().range(["#987024", "#ed0909"]);
            var colScale = d3.scale.linear().range(["#987024", "#ed0909"]);
            var edgeWeightScale = d3.scale.linear().range([1, 3]);
            var xScale = d3.scale.linear().range([nodeSliderValue/3.0, nodeSliderValue]);
            //var xScale = d3.scale.linear().range([5, 15]);
            var textPlacePlusMinus = d3.scale.ordinal()
                .range([18, -18])
                .domain([1, 2]);
            var textPlaceStartEnd = d3.scale.ordinal().range(["start", "end"])
                .domain([1, 2]);


            var colorsForAbundance = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
            var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];
            var colorScale = d3.scale.threshold()
                .domain(domain_data)
                .range(colorsForAbundance);






            function updateEnrichment(nodes, links, graphType, circleValue, nodeValue, fontValue, widthValue) {
                //
                //var svg;
                circleValue = Math.min(circleValue, widthValue - 300);

                // $('force1').click();
                //document.getElementById('force1').click();

                // //console.log(circularLayout);
                function defaultView5() {


                    svg5.remove();

                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    colNodeScale.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    colNodeScalePValue.domain(d3.extent(nodes, function (d) {
                        return d.value;
                    }));
                    // colorScale.domain(d3.extent(nodes, function (d) {
                    //     return d.value;
                    // }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));

                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = w,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;

//These variables are global variables
                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;

                    svg5 = d3.select("#chart5")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);
                    svg5.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");


                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h])
                        .linkDistance(150)
                        .charge(-500)
                        //.linkStrength(0.9)
                        //.friction(0.9)
                        //.chargeDistance(300)
                        .gravity(0.25)
                        //.theta(0.8)
                        //.alpha(0.1)
                        .on("tick", tick)
                        .start();

                    // for (var i = n*n; i > 0; --i) force.tick();
                    // force.stop();

                    //.stop();


                    var path = svg5.append("svg:g").selectAll("path")
                    //.data(links)
                        .data(force.links())
                        .enter().append("svg:path")
                        .style("stroke-width", 1)
                        .style('stroke', "black")
                        //.style("stroke", function (d) {return colScale(d.value); })
                        .attr("class", function (d) {
                            return "link ";
                        });


                    var node = svg5.append("svg:g").selectAll("g.node")
                        .data(force.nodes())
                        .enter().append("svg:g")
                        // .style("stroke-width", 3)
                        // .style('stroke', "black")
                        //.attr("class", "node")
                        .call(force.drag);

                    // nodes.forEach(function(v) {
                    //     var nd;
                    //     var cx = v.coord[0];
                    //     var cy = v.coord[1];
                    //
                    //     switch (v.group) {
                    //         case 1:
                    //             nd = svg.append("circle");
                    //             break;
                    //         case 2:
                    //             nd = svg.append("rect");
                    //             break;
                    //     }
                    // });

                    node.append("circle")
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        .style("fill", function (d) {
                            if (d.group == 1) {
                                return colorScale(d.value);
                            }
                            else {
                                return colNodeScalePValue(d.value);
                            }
                            //return colNodeScale(d.group);
                        })
                        // .style("fill", function (d) {
                        //     return colNodeScale(d.group);
                        // })
                        .style("stroke", "#333")
                        .style("stroke-width", "2px");
                    //.on("dblclick", dblclick);


                    function openLink() {
                        return function (d) {
                            var url = "";
                            if (d.slug != "") {
                                url = d.slug
                            } //else if(d.type == 2) {
                            //url = "clients/" + d.slug
                            //} else if(d.type == 3) {
                            //url = "agencies/" + d.slug
                            //}
                            window.open("//" + url)
                        }
                    };
                    node.append("svg:image")
                    //****************************************
                    //.attr("class", function(d){ return d.name })
                    //****************************************
                    //.attr("xlink:href", function(d){ return d.img_hrefD})
                        .attr("x", "-36px")
                        .attr("y", "-36px")
                        .attr("width", "70px")
                        .attr("height", "70px")
                    //.on("dblclick", openLink());

                    // .on("mouseover", function (d) { if(d.entity == "company")
                    // {
                    //     d3.select(this).attr("width", "90px")
                    //         .attr("x", "-46px")
                    //         .attr("y", "-36.5px")
                    //         .attr("xlink:href", function(d){ return d.img_hrefL});
                    // }
                    // })
                    // .on("mouseout", function (d) { if(d.entity == "company")
                    // {
                    //     d3.select(this).attr("width", "70px")
                    //         .attr("x", "-36px")
                    //         .attr("y", "-36px")
                    //         .attr("xlink:href", function(d){ return d.img_hrefD});
                    // }
                    // });


                    //.text(function(d) { return d.name })
                    node.append("svg:text")
                    //****************************************
                        .attr("class", function (d) {
                            return d.full_name
                        })
                        //****************************************
                        .attr("x", 16)
                        .attr("y", ".31em")
                        //.attr("class", "shadow")
                        //.style("font-size","10px")
                        // .attr("dx", 0)
                        // .attr("dy", ".35em")
                        //.style("font-size","12px")
                        //****************************************
                        //text.shadow {
                        .style("stroke", "#fff")
                        .style("stroke-width", "4px")
                        //}
                        //.attr("class", "shadow")
                        .style("font", String(fontValue) + "px Arial")
                        //.style("font", "14px Times New Roman")
                        //****************************************
                        //.attr("text-anchor", "middle")
                        //****************************************
                        .text(function (d) {
                            return d.full_name
                        });
                    //****************************************


                    //This one is for the actual text
                    node.append("svg:text")
                    //****************************************
                        .attr("class", function (d) {
                            return d.full_name
                        })
                        //****************************************
                        .attr("x", 16)
                        .attr("y", ".31em")
                        //.attr("class", "shadow")
                        //.style("font-size","10px")
                        // .attr("dx", 0)
                        // .attr("dy", ".35em")
                        //.style("font-size","12px")
                        //****************************************
                        .style("font", String(fontValue) + "px Arial")
                        //.style("font", "14px Times New Roman")
                        //****************************************
                        //.attr("text-anchor", "middle")
                        //****************************************
                        .text(function (d) {
                            return d.full_name
                        });
                    //****************************************


                    node.on("mouseover", function (d) {
                        // d3.select(this).select("text")
                        //     .transition()
                        //     .duration(300)
                        //     .text(function (d) {
                        //         return d.full_name;
                        //     })
                        // //.style("font-size", "15px")
                        // .style("font", "14px Times New Roman");
                        //
                        // d3.select(this).select("text")
                        //     .transition()
                        //     .duration(300)
                        //     .text(function (d) {
                        //         return d.full_name;
                        //     })
                        //     //.style("font-size", "15px")
                        //     //.attr("class", "shadow")
                        //     .style("font", "14px Times New Roman");
                        // d3.select(this).select("text")
                        //     .transition()
                        //     .duration(300)
                        //     .text(function (d) {
                        //         return d.full_name;
                        //     })
                        //
                        //     .style("fill",'black')
                        //     .style("font", "14px Times New Roman");

                        //d3.selectAll("text").remove();
                        //d3.select(this).style("stroke-width", 6);

                        //d3.select(this).select("text").style("stroke", "blue");

                        var nodeNeighbors = links.filter(function (link) {
                            // Filter the list of links to only those links that have our target
                            // node as a source or target
                            return link.source.index === d.index || link.target.index === d.index;
                        })
                            .map(function (link) {
                                // Map the list of links to a simple array of the neighboring indices - this is
                                // technically not required but makes the code below simpler because we can use
                                // indexOf instead of iterating and searching ourselves.
                                return link.source.index === d.index ? link.target.index : link.source.index;
                            });

                        d3.selectAll('circle').filter(function (node) {
                            // I filter the selection of all circles to only those that hold a node with an
                            // index in my listg of neighbors
                            return nodeNeighbors.indexOf(node.index) > -1;
                        })
                            .style('stroke', 'blue');

                        //d3.selectAll('text').filter(d).style('fill', 'blue');
                        //****************************
                        // d3.selectAll('text').filter(function(node) {
                        //     // I filter the selection of all circles to only those that hold a node with an
                        //     // index in my listg of neighbors
                        //     return nodeNeighbors.indexOf(node.index) > -1;
                        // }).style('fill', 'blue')
                        //     //.style("font-size", "16px")
                        //     //.style("font-weight", "bold");
                        // //****************************
                        path.style('stroke', function (l) {
                            if (d === l.source || d === l.target)
                                return "blue";
                            else
                                return "grey";
                        })

                        path.style('stroke-width', function (l) {
                            if (d === l.source || d === l.target)
                                return 2;
                            else
                                return 1;
                        })

                    })
                        .on("mouseout", function (d) {
                            d3.select(this).select("text")
                                .transition()
                                .duration(300)
                                .text(function (d) {

                                    return d.full_name;
                                });
                            // d3.select(this).select("text")
                            //     //*******************************
                            //     .style("font", "14px Times New Roman")
                            //     //*******************************
                            //     .style("font-size", "14px")
                            //     .style("fill",'black')
                            //     .style("font-weight", "normal");

                            // d3.select(this).select("text")
                            // //*******************************
                            //     .style("font", "14px Times New Roman")
                            //     //*******************************
                            //     .style("font-size", "14px")
                            //     .style("fill",'black')
                            //     .style("font-weight", "normal");
                            //d3.select(this).style("stroke", "black");
                            //d3.select(this).style("stroke-width", 1);
                            //d3.select(this).style("stroke", "#333");
                            path.style('stroke', "grey");
                            path.style('stroke-width', 1);
                            //circle.style('stroke', "grey");
                            //node.style("stroke-width", 3);
                            //node.style("stroke", "#333");
                            //d3.selectAll('text').style('fill', 'black')
                            // d3.selectAll('text').style('fill', 'black')
                            //     .style("font-weight", "normal");
                            //d3.selectAll("text").style("font-weight", "normal");
                            node.selectAll("circle").style("stroke-width", 3)
                                .style('stroke', "black");
                            //.style("font-size", "12px");
                            //}
                        });


                    function pythag(r, b, coord) {
                        r += nodeBaseRad;

                        // force use of b coord that exists in circle to avoid sqrt(x<0)
                        b = Math.min(w - r - strokeWidth, Math.max(r + strokeWidth, b));

                        var b2 = Math.pow((b - radius), 2),
                            a = Math.sqrt(hyp2 - b2);

                        function openLink() {
                            return function (d) {
                                var url = "";
                                if (d.slug != "") {
                                    url = d.slug
                                } //else if(d.type == 2) {
                                //url = "clients/" + d.slug
                                //} else if(d.type == 3) {
                                //url = "agencies/" + d.slug
                                //}
                                window.open("//" + url)
                            }
                        }

                        // radius - sqrt(hyp^2 - b^2) < coord < sqrt(hyp^2 - b^2) + radius
                        coord = Math.max(radius - a + r + strokeWidth,
                            Math.min(a + radius - r - strokeWidth, coord));

                        return coord;
                    }

                    function tick(e) {
                        path.attr("d", function (d) {
                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,

                                dr = Math.sqrt(dx * dx + dy * dy);
                            ////console.log(d.source.x);
                            // //console.log(d.target.x);
                            return "M" + d.source.x + "," + d.source.y + "," + d.target.x + "," + d.target.y;
                            //return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
                        });

                        node.attr('x', function (d) {
                            return d.x = pythag(Math.random() * 12, d.y, d.x);
                        })
                            .attr('y', function (d) {
                                return d.y = pythag(Math.random() * 12, d.x, d.y);
                            })
                            .attr("transform", function (d) {
                                return "translate(" + d.x + "," + d.y + ")"
                            });

                        //d3.select(this).classed("fixed", d.fixed = true);
                        // circle.attr("transform", function(d) {
                        //     return "translate(" + d.x + "," + d.y + ")";
                        // });
                        //************************************
                        // text.attr("transform", function(d) {
                        //     return "translate(" + d.x + "," + d.y + ")";
                        // });
                        //************************************
                    }

                    //For not moving after drag
                    var drag = force.drag()
                        .on("dragstart", dragstart);
                    //.on("dragstart", dragstartAll);

                    //For not moving after drag
                    function dblclick(d) {
                        d3.select(this).classed("fixed", d.fixed = false);

                    }

                    //For not moving after drag
                    function dragstart(d) {
                        d3.select(this).classed("fixed", d.fixed = true);

                        for (i = 0; i < nodes.length; i++) {
                            nodes[i].fixed = true;
                        }
                    }


                    var svgText = svg5.append("text");
                    svgText.attr("x",10).attr("y",globalHPlus50-50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);



                    var legend2 = svg5.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());
                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg5.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg5.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg5.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();





                    // For legend
                    // var colNodeScaleSeparateInfo = d3.scale.ordinal()
                    //     .range(["#767776", "#f91104"])
                    //     .domain(["Query Gene Set", "Pathways / Kinases Perturbation"]);
                    //
                    //
                    // var legend = svg.selectAll(".legend")
                    //     .data(colNodeScaleSeparateInfo.domain())
                    //     .enter().append("g")
                    //     .attr("class", "legend")
                    //     .attr("transform", function (d, i) {
                    //         return "translate(0," + (i) * 25 + ")";
                    //     });
                    //
                    // legend.append("rect")
                    //     .attr("x", w - 25)
                    //     .attr("width", 25)
                    //     .attr("height", 25)
                    //     .style("fill", colNodeScaleSeparateInfo);
                    //
                    // legend.append("text")
                    //     .attr("x", w - 35)
                    //     .attr("y", 12.5)
                    //     .attr("dy", ".35em")
                    //     .style("text-anchor", "end")
                    //     .text(function (d) {
                    //         return d;
                    //     });
                    //
                    //
                    // d3.select("#download").on("click", function () {
                    //     d3.select(this)
                    //         .attr("href", 'data:application/octet-stream;base64,' + btoa(d3.select("#chart").html()))
                    //         .attr("download", "pathway_network.svg")
                    // })

                };

                function circosView5(){
                    svg5.remove();

                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    colNodeScale.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));
                    colNodeScalePValue.domain(d3.extent(nodes, function (d) {
                        return d.value;
                    }));
                    // colorScale.domain(d3.extent(nodes, function (d) {
                    //     return d.value;
                    // }));
                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = w,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;


                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;


                    svg5 = d3.select("#chart5")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);
                    svg5.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");


                    // This is for grouping nodes


                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h]);

// evenly spaces nodes along arc
                    var circleCoord = function (node, index, num_nodes) {
                        var circumference = circle.node().getTotalLength();
                        var pointAtLength = function (l) {
                            return circle.node().getPointAtLength(l)
                        };
                        var sectionLength = (circumference) / num_nodes;
                        var position = sectionLength * index + sectionLength / 2;
                        return pointAtLength(circumference - position)
                    }

                    var is_connected = function (d, opacity) {
                        lines.transition().style("stroke-opacity", function (o) {
                            return o.source === d || o.target === d ? 1 : opacity;
                        });
                    }

                    var dim = w - (widthValue - circleValue);
                    var circle = svg5.append("path")
                        .attr("d", "M " + String((widthValue - circleValue)/2) + ", " + (dim / 2 + (widthValue - circleValue)/2) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                        .style("fill", "white");

                    // var dim = w - 900
                    // var circle = svg5.append("path")
                    //     .attr("d", "M 450, " + (dim / 2 + 450) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                    //     .style("fill", "white");

                    force.start();

                    nodes.forEach(function (n, i) {
                        var coord = circleCoord(n, i, nodes.length)
                        n.x = coord.x
                        n.y = coord.y
                    });


                    // use this one for straight line links...
                    // var lines = svg.selectAll("line.node-link")
                    //     .data(links).enter().append("line")
                    //     .attr("class", "node-link")
                    //     .attr("x1", function(d) { return d.source.x; })
                    //     .attr("y1", function(d) { return d.source.y; })
                    //     .attr("x2", function(d) { return d.target.x; })
                    //     .attr("y2", function(d) { return d.target.y; });

                    var lines = svg5.selectAll("path.node-link")
                        .data(links).enter().append("path")
                        .style("fill", "none")
                        .style("stroke", "#726363")
                        .attr("class", "node-link")
                        .attr("d", function (d) {

                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,
                                dr = Math.sqrt(dx * dx + dy * dy),
                                a1 = dx,
                                a2 = dy,
                                c1 = w / 2 - d.source.x,
                                c2 = h / 2 - d.source.y,
                                d1 = w / 2 - d.target.x,
                                d2 = h / 2 - d.target.y,

                                drx = dr / 1.5,
                                dry = dr / 1.5,
                                xRotation = 0, // degrees
                                largeArc = 0, // 1 or 0

                                sweep = 1, // 1 or 0
                                x2 = d.target.x,
                                y2 = d.target.y;


                            // if( (a1*c2 - a2*c1) > 0)
                            // {
                            //     sweep = 0
                            // }
                            // else
                            // {sweep = 1}
                            if ((c1 * d2 - c2 * d1) > 0) {
                                sweep = 0
                            }
                            else {
                                sweep = 1
                            }


                            return "M" + d.source.x + "," + d.source.y + "A" + drx + "," + dry + " " + xRotation + "," + largeArc + "," + sweep + " " + x2 + "," + y2;
                        });
                        // .attr("d", function (d) {
                        //     var dx = d.target.x - d.source.x,
                        //         dy = d.target.y - d.source.y,
                        //         dr = Math.sqrt(dx * dx + dy * dy);
                        //     return "M" +
                        //         d.source.x + "," +
                        //         d.source.y + "," +
                        //         d.target.x + "," +
                        //         d.target.y;
                        //
                        // });


                    var gnodes = svg5.selectAll('g.gnode')
                        .data(nodes).enter().append('g')
                        .attr("transform", function (d) {
                            return "translate(" + d.x + "," + d.y + ")"
                        })
                        .classed('gnode', true);


                    // node.append("circle")
                    //     .attr("r", function (d) { return xScale(d.weight); })
                    //     .style("fill", function(d) { return colNodeScale(d.group); });

                    var node = gnodes.append("circle")
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        .style("fill", function (d) {
                            if (d.group == 1) {
                                return colorScale(d.value);
                            }
                            else {
                                return colNodeScalePValue(d.value);
                            }
                            //return colNodeScale(d.group);
                        })
                        // .style("fill", function (d) {
                        //     return colNodeScale(d.group);
                        // })
                        .style("stroke", "#333")
                        .style("stroke-width", "2px")
                        //.attr("class", "node")
                        .on("mouseenter", function (d) {
                            is_connected(d, 0.1)
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            d3.select(this).transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight + 10);
                            })
                        })
                        .on("mouseleave", function (d) {
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            is_connected(d, 1);
                        })
                        .call(force.drag);

                    var labels = gnodes.append("text")
                        .attr("dx", 4)
                        .attr("dy", 4)
                        .style("font", String(fontValue) + "px Arial")
                        //.style("font", "14px Times New Roman")
                        .attr("text-anchor", function (d) {
                            return d.x < w / 2 ? "end" : "start";
                        })
                        .attr("transform", function (d) {
                            return d.x < w / 2 ? "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(-20)" : "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(20)";
                        })
                        //.attr("transform", function(d) { return  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")"})
                        //.attr("transform", function(d) { return (d.x-w/2)/(d.y-w/2) < 0 ?  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")" : "rotate(180)"; })
                        .text(function (d) {
                            return d.full_name
                        })

                    var drag = force.drag()
                        .on("dragstart", dragstart);
                    //.on("dragstart", dragstartAll);


                    //For not moving after drag
                    function dragstart(d) {
                        d3.select(this).classed("fixed", d.fixed = true);

                        for (i = 0; i < nodes.length; i++) {
                            nodes[i].fixed = true;
                        }
                    }


                    var svgText = svg5.append("text");
                    svgText.attr("x",10).attr("y",globalHPlus50-50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);



                    var legend2 = svg5.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());
                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg5.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg5.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg5.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();




                };

                function circularView5() {
                    svg5.remove();

                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    colNodeScale.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));
                    colNodeScalePValue.domain(d3.extent(nodes, function (d) {
                        return d.value;
                    }));
                    // colorScale.domain(d3.extent(nodes, function (d) {
                    //     return d.value;
                    // }));
                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = w,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;


                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;


                    svg5 = d3.select("#chart5")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);
                    svg5.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");


                    // This is for grouping nodes


                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h]);

// evenly spaces nodes along arc
                    var circleCoord = function (node, index, num_nodes) {
                        var circumference = circle.node().getTotalLength();
                        var pointAtLength = function (l) {
                            return circle.node().getPointAtLength(l)
                        };
                        var sectionLength = (circumference) / num_nodes;
                        var position = sectionLength * index + sectionLength / 2;
                        return pointAtLength(circumference - position)
                    }

                    var is_connected = function (d, opacity) {
                        lines.transition().style("stroke-opacity", function (o) {
                            return o.source === d || o.target === d ? 1 : opacity;
                        });
                    }

                    var dim = w - (widthValue - circleValue);
                    var circle = svg5.append("path")
                        .attr("d", "M " + String((widthValue - circleValue)/2) + ", " + (dim / 2 + (widthValue - circleValue)/2) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                        .style("fill", "white");

                    // var dim = w - 900
                    // var circle = svg5.append("path")
                    //     .attr("d", "M 450, " + (dim / 2 + 450) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                    //     .style("fill", "white");

                    force.start();

                    nodes.forEach(function (n, i) {
                        var coord = circleCoord(n, i, nodes.length)
                        n.x = coord.x
                        n.y = coord.y
                    });


                    // use this one for straight line links...
                    // var lines = svg.selectAll("line.node-link")
                    //     .data(links).enter().append("line")
                    //     .attr("class", "node-link")
                    //     .attr("x1", function(d) { return d.source.x; })
                    //     .attr("y1", function(d) { return d.source.y; })
                    //     .attr("x2", function(d) { return d.target.x; })
                    //     .attr("y2", function(d) { return d.target.y; });

                    var lines = svg5.selectAll("path.node-link")
                        .data(links).enter().append("path")
                        .style("fill", "none")
                        .style("stroke", "#726363")
                        .attr("class", "node-link")
                        .attr("d", function (d) {
                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,
                                dr = Math.sqrt(dx * dx + dy * dy);
                            return "M" +
                                d.source.x + "," +
                                d.source.y + "," +
                                d.target.x + "," +
                                d.target.y;

                        });


                    var gnodes = svg5.selectAll('g.gnode')
                        .data(nodes).enter().append('g')
                        .attr("transform", function (d) {
                            return "translate(" + d.x + "," + d.y + ")"
                        })
                        .classed('gnode', true);


                    // node.append("circle")
                    //     .attr("r", function (d) { return xScale(d.weight); })
                    //     .style("fill", function(d) { return colNodeScale(d.group); });

                    var node = gnodes.append("circle")
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        .style("fill", function (d) {
                            if (d.group == 1) {
                                return colorScale(d.value);
                            }
                            else {
                                return colNodeScalePValue(d.value);
                            }
                            //return colNodeScale(d.group);
                        })
                        // .style("fill", function (d) {
                        //     return colNodeScale(d.group);
                        // })
                        .style("stroke", "#333")
                        .style("stroke-width", "2px")
                        //.attr("class", "node")
                        .on("mouseenter", function (d) {
                            is_connected(d, 0.1)
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            d3.select(this).transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight + 10);
                            })
                        })
                        .on("mouseleave", function (d) {
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            is_connected(d, 1);
                        })
                        .call(force.drag);

                    var labels = gnodes.append("text")
                        .attr("dx", 4)
                        .attr("dy", 4)
                        .style("font", String(fontValue) + "px Arial")
                        //.style("font", "14px Times New Roman")
                        .attr("text-anchor", function (d) {
                            return d.x < w / 2 ? "end" : "start";
                        })
                        .attr("transform", function (d) {
                            return d.x < w / 2 ? "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(-20)" : "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(20)";
                        })
                        //.attr("transform", function(d) { return  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")"})
                        //.attr("transform", function(d) { return (d.x-w/2)/(d.y-w/2) < 0 ?  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")" : "rotate(180)"; })
                        .text(function (d) {
                            return d.full_name
                        })

                    var drag = force.drag()
                        .on("dragstart", dragstart);
                    //.on("dragstart", dragstartAll);


                    //For not moving after drag
                    function dragstart(d) {
                        d3.select(this).classed("fixed", d.fixed = true);

                        for (i = 0; i < nodes.length; i++) {
                            nodes[i].fixed = true;
                        }
                    }


                    var svgText = svg5.append("text");
                    svgText.attr("x",10).attr("y",globalHPlus50-50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);



                    var legend2 = svg5.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());
                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg5.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg5.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg5.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();




                };

                function parallelView5() {
                    svg5.remove();

                    //xPosition.domain(d3.extent(nodes, function (d) { return d.text; }));
                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    colNodeScale.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    colNodeScalePValue.domain(d3.extent(nodes, function (d) {
                        return d.value;
                    }));

                    // colorScale.domain(d3.extent(nodes, function (d) {
                    //     return d.value;
                    // }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));
                    textPlacePlusMinus.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    textPlaceStartEnd.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));

                    n1 = 0;
                    n2 = 0;

                    nodes.forEach(function (n, i) {


                        if (n.group == 1) {

                            n1 = n1 + 1;
                        }
                        if (n.group == 2) {

                            n2 = n2 + 1;
                        }

                    });

                    //console.log(n1);
                    //console.log(n1 * 12);
                    //console.log(n2);
                    //console.log(n2 * 12);
                    var parallelH = Math.max(n1 * 12, n2 * 12, 500);
                    //var parallelH = Math.max(n1 * 12, n2 * 12);

                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = parallelH,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;

                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;


                    svg5 = d3.select("#chart5")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);

                    svg5.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");


                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h]);


                    var parallelCoordx = function (group) {

                        if (group == 1) {
                            return w * 1.5 / 3.;
                        }
                        else {
                            return w / 3.;
                        }
                    }

                    var parallelCoordy = function (index, num_nodes) {
                        var dist = h / (num_nodes + 1);

                        return (index + 1) * dist;
                    }

                    var is_connected = function (d, opacity) {
                        lines.transition().style("stroke-opacity", function (o) {
                            return o.source === d || o.target === d ? 1 : opacity;
                        });
                    }

                    //var dim = w-80
                    // var circle = svg.append("path")
                    //     .attr("d", "M 40, "+(dim/2+40)+" a "+dim/2+","+dim/2+" 0 1,0 "+dim+",0 a "+dim/2+","+dim/2+" 0 1,0 "+dim*-1+",0")
                    //     .style("fill", "#f5f5f5");

                    force.start();


                    // //console.log(nodes.length);
                    var groupId = [];
                    var maxId = 0;
                    for (var i = 0; i < nodes.length; i++) {
                        var item = nodes[i];

                        if (!groupId[item.group]) {
                            groupId[item.group] = [];
                        }

                        groupId[item.group].push({name: item.name});
                        // //console.log(item.group);
                        // //console.log(groupId[item.group]);
                        if (maxId < item.group) {
                            maxId = item.group;
                        }
                    }
                    // //console.log(maxId);
                    // //console.log(groupId[1].length);
                    // //console.log(groupId[2].length);

                    n1 = 0;
                    n2 = 0;

                    nodes.forEach(function (n, i) {
                        var item = nodes[i];

                        if (n.group == 1) {
                            n.x = parallelCoordx(n.group)
                            n.y = parallelCoordy(n1, groupId[1].length)
                            n1 = n1 + 1;
                        }
                        if (n.group == 2) {
                            n.x = parallelCoordx(n.group)
                            n.y = parallelCoordy(n2, groupId[2].length)
                            n2 = n2 + 1;
                        }

                    });


                    // use this one for straight line links...
                    // var lines = svg.selectAll("line.node-link")
                    //   .data(links).enter().append("line")
                    //     .attr("class", "node-link")
                    //   .attr("x1", function(d) { return d.source.x; })
                    //   .attr("y1", function(d) { return d.source.y; })
                    //   .attr("x2", function(d) { return d.target.x; })
                    //   .attr("y2", function(d) { return d.target.y; });

                    var lines = svg5.selectAll("path.node-link")
                        .data(links).enter().append("path")
                        .style("fill", "none")
                        .style("stroke", "#726363")
                        .attr("class", "node-link")
                        .attr("d", function (d) {
                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,
                                dr = Math.sqrt(dx * dx + dy * dy);
                            return "M" +
                                d.source.x + "," +
                                d.source.y + "," +
                                d.target.x + "," +
                                d.target.y;
                        });

                    // var lines = svg.selectAll("path.node-link")
                    //     .data(links).enter().append("path")
                    //     .style("fill", "none")
                    //     .style("stroke", "black")
                    //     .attr("class", "node-link")
                    //     .attr("d", function(d) {
                    //         var dx = d.target.x - d.source.x,
                    //             dy = d.target.y - d.source.y,
                    //             dr = Math.sqrt(dx * dx + dy * dy);
                    //         return "M" +
                    //             d.source.x + "," +
                    //             d.source.y + "A" +
                    //             dr + "," + dr + " 0 0,1 " +
                    //             d.target.x + "," +
                    //             d.target.y;
                    //     });

                    var gnodes = svg5.selectAll('g.gnode')
                        .data(nodes).enter().append('g')
                        .attr("transform", function (d) {
                            return "translate(" + d.x + "," + d.y + ")"
                        })
                        .classed('gnode', true);

                    var node = gnodes.append("circle")
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        .style("fill", function (d) {
                            if (d.group == 1) {
                                return colorScale(d.value);
                            }
                            else {
                                return colNodeScalePValue(d.value);
                            }
                            //return colNodeScale(d.group);
                        })

                        .style("stroke", "#333")
                        .style("stroke-width", "2px")
                        //.attr("class", "node")
                        .on("mouseenter", function (d) {
                            is_connected(d, 0.1)
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            d3.select(this).transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight + 10);
                            })
                        })
                        .on("mouseleave", function (d) {
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            is_connected(d, 1);
                        })
                        .call(force.drag);
                    // var bbox = textElement.getBBox();
                    // var width = bbox.width;
                    // var height = bbox.height;
                    var labels = gnodes.append("text")
                        .style("font", String(fontValue) + "px Arial")
                        //.style("font", "14px Times New Roman")
                        .attr("dx", function (d) {
                            return textPlacePlusMinus(d.group);
                        })
                        .attr("dy", 4)
                        .attr("text-anchor", function (d) {
                            return textPlaceStartEnd(d.group);
                        })
                        .text(function (d) {
                            return d.full_name
                        })

                    var svgText = svg5.append("text");
                    svgText.attr("x",10).attr("y",globalHPlus50-50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);



                    var legend2 = svg5.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());
                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg5.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg5.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg5.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();



                };

                //parallelView5();

                // d3.select('#parallelView5').on('click', function () {
                //     parallelView5()
                // });




                d3.select('#force5').on('click', function () {
                    defaultView5();
                    $scope.graphType4enrich = 0;
                });
                d3.select('#parallelView5').on('click', function () {
                    parallelView5();
                    $scope.graphType4enrich = 1;
                });
                d3.select('#circosView5').on('click', function (){
                    circosView5();
                    $scope.graphType4enrich = 2;
                });
                d3.select('#circularView5').on('click', function (){
                    circularView5();
                    $scope.graphType4enrich = 3;
                });


                if(graphType == 0){
                    defaultView5();
                }
                else if(graphType == 1){
                    parallelView5();
                }
                else if(graphType == 2){
                    circosView5();
                }
                else if(graphType == 3){
                    circularView5();
                }



                d3.select("#download-svg5").on("click", function ()  {
                    var name = 'Pinet-Enrichr-Enrichment-Analysis.svg';
                    var svgEl = svg5.node();
                    svgEl.setAttribute("xmlns", "http://www.w3.org/2000/svg");
                    var svgData = svgEl.outerHTML;
                    var preface = '<?xml version="1.0" standalone="no"?>\r\n';
                    var svgBlob = new Blob([preface, svgData], {type:"image/svg+xml;charset=utf-8"});
                    var svgUrl = URL.createObjectURL(svgBlob);
                    var downloadLink = document.createElement("a");
                    downloadLink.href = svgUrl;
                    downloadLink.download = name;
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                })

                // Set-up the export button
                d3.select('#download-png5').on('click', function () {
                    var svgString = getSVGString(svg5.node());

                    svgString2Image(svgString, 4 * globalW, 4 * globalHPlus50, 'png', save); // passes Blob and filesize String to the callback

                    function save(dataBlob, filesize) {
                        saveAs(dataBlob, 'Pinet-Enrichr-Enrichment-Analysis.png'); // FileSaver.js function
                    }
                });
                d3.select('#saveButton').on('click', function () {
                    var svgString = getSVGString(svg5.node());

                    svgString2Image(svgString, 4 * 1550, 4 * 1550, 'png', save); // passes Blob and filesize String to the callback

                    function save(dataBlob, filesize) {
                        saveAs(dataBlob, 'PiNET-grapg.png'); // FileSaver.js function
                    }
                });

// Below are the functions that handle actual exporting:
// getSVGString ( svgNode ) and svgString2Image( svgString, width, height, format, callback )
                function getSVGString(svgNode) {
                    svgNode.setAttribute('xlink', 'http://www.w3.org/1999/xlink');
                    var cssStyleText = getCSSStyles(svgNode);
                    appendCSS(cssStyleText, svgNode);

                    var serializer = new XMLSerializer();
                    var svgString = serializer.serializeToString(svgNode);
                    svgString = svgString.replace(/(\w+)?:?xlink=/g, 'xmlns:xlink='); // Fix root xlink without namespace
                    svgString = svgString.replace(/NS\d+:href/g, 'xlink:href'); // Safari NS namespace fix

                    return svgString;

                    function getCSSStyles(parentElement) {
                        var selectorTextArr = [];

                        // Add Parent element Id and Classes to the list
                        selectorTextArr.push('#' + parentElement.id);
                        for (var c = 0; c < parentElement.classList.length; c++)
                            if (!contains('.' + parentElement.classList[c], selectorTextArr))
                                selectorTextArr.push('.' + parentElement.classList[c]);

                        // Add Children element Ids and Classes to the list
                        var nodes = parentElement.getElementsByTagName("*");
                        for (var i = 0; i < nodes.length; i++) {
                            var id = nodes[i].id;
                            if (!contains('#' + id, selectorTextArr))
                                selectorTextArr.push('#' + id);

                            var classes = nodes[i].classList;
                            for (var c = 0; c < classes.length; c++)
                                if (!contains('.' + classes[c], selectorTextArr))
                                    selectorTextArr.push('.' + classes[c]);
                        }

                        // Extract CSS Rules
                        var extractedCSSText = "";
                        for (var i = 0; i < document.styleSheets.length; i++) {
                            var s = document.styleSheets[i];

                            try {
                                if (!s.cssRules) continue;
                            } catch (e) {
                                if (e.name !== 'SecurityError') throw e; // for Firefox
                                continue;
                            }

                            var cssRules = s.cssRules;
                            for (var r = 0; r < cssRules.length; r++) {
                                if (contains(cssRules[r].selectorText, selectorTextArr))
                                    extractedCSSText += cssRules[r].cssText;
                            }
                        }


                        return extractedCSSText;

                        function contains(str, arr) {
                            return arr.indexOf(str) === -1 ? false : true;
                        }

                    }

                    function appendCSS(cssText, element) {
                        var styleElement = document.createElement("style");
                        styleElement.setAttribute("type", "text/css");
                        styleElement.innerHTML = cssText;
                        var refNode = element.hasChildNodes() ? element.children[0] : null;
                        element.insertBefore(styleElement, refNode);
                    }
                }


                function svgString2Image(svgString, width, height, format, callback) {
                    var format = format ? format : 'png';

                    var imgsrc = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgString))); // Convert SVG string to data URL

                    var canvas = document.createElement("canvas");
                    var context = canvas.getContext("2d");

                    canvas.width = width;
                    canvas.height = height;

                    var image = new Image();
                    image.onload = function () {
                        context.clearRect(0, 0, width, height);
                        context.drawImage(image, 0, 0, width, height);

                        canvas.toBlob(function (blob) {
                            var filesize = Math.round(blob.length / 1024) + ' KB';
                            if (callback) callback(blob, filesize);
                        });


                    };

                    image.src = imgsrc;
                }


                // d3.select("#download").on("click", function(){
                //     var html = d3.select("svg")
                //         .attr("version", 1.1)
                //         .attr("xmlns", "http://www.w3.org/2000/svg")
                //         .node().parentNode.innerHTML;
                //
                //     ////console.log(html);
                //     var imgsrc = 'data:image/svg+xml;base64,'+ btoa(html);
                //     var img = '<img src="'+imgsrc+'">';
                //     d3.select("#svgdataurl").html(img);
                //
                //
                //     var canvas = document.querySelector("canvas"),
                //         context = canvas.getContext("2d");
                //
                //     var image = new Image;
                //     image.src = imgsrc;
                //     image.onload = function() {
                //         context.drawImage(image, 0, 0);
                //
                //         var canvasdata = canvas.toDataURL("image/png");
                //
                //         var pngimg = '<img src="'+canvasdata+'">';
                //         d3.select("#pngdataurl").html(pngimg);
                //
                //         var a = document.createElement("a");
                //         a.download = "sample.png";
                //         a.href = canvasdata;
                //         a.click();
                //     };
                //
                // });


            }

            // $scope.pathways = [
            //     {value: "KEGG_2015"},
            //     {value: "WikiPathways_2015"},
            //     {value: "Panther_2015"},
            //     {value: "KEGG_2016"},
            //     {value: "WikiPathways_2016"},
            //
            //     {value: "ARCHS4_Kinases_Coexp"},
            //     {value: "Reactome_2016"},
            //     {value: "BioCarta_2016"},
            //     {value: "Humancyc_2016"},
            //     {value: "NCI-Nature_2016"},
            //     {value: "Panther_2016"},
            //     {value: "BioPlex_2017"},
            //
            //     {value: "huMAP"},
            //     {value: "PPI_Hub_Proteins"},
            //     {value: "KEA_2015"},
            //     {value: "LINCS_L1000_Kinase_Perturbations_down"},
            //     {value: "LINCS_L1000_Kinase_Perturbations_up"},
            //     {value: "Kinase_Perturbations_from_GEO"},
            //     {value: "Kinase_Perturbations_from_GEO_down"},
            //     {value: "Kinase_Perturbations_from_GEO_up"},
            //     {value: "NURSA_Human_Endogenous_Complexome"},
            //     {value: "CORUM"},
            //
            //     {value: "SILAC_Phosphoproteomics"},
            //     {value: "Phosphatase_Substrates_from_DEPOD"}
            // ];
            // $scope.selectedPathways = $scope.pathways[0];

            $scope.enrichmentPathways = [

                {value: "KEGG_2019_Human"},
                {value: "KEGG_2019_Mouse"},
                {value: "WikiPathways_2019_Human"},
                {value: "WikiPathways_2019_Mouse"},
                {value: "WikiPathways_2015"},
                {value: "Panther_2015"},
                {value: "KEGG_2016"},
                {value: "WikiPathways_2016"},
                {value: "ARCHS4_Kinases_Coexp"},
                {value: "Reactome_2016"},
                {value: "BioCarta_2016"},
                {value: "Humancyc_2016"},
                {value: "NCI-Nature_2016"},
                {value: "Panther_2016"},
                {value: "BioPlex_2017"},

                {value: "huMAP"},
                {value: "PPI_Hub_Proteins"},
                {value: "KEA_2015"},
                {value: "LINCS_L1000_Kinase_Perturbations_down"},
                {value: "LINCS_L1000_Kinase_Perturbations_up"},
                {value: "Kinase_Perturbations_from_GEO_down"},
                {value: "Kinase_Perturbations_from_GEO_up"},
                {value: "NURSA_Human_Endogenous_Complexome"},
                {value: "CORUM"},

                {value: "SILAC_Phosphoproteomics"},
                {value: "Phosphatase_Substrates_from_DEPOD"}
            ];
            $scope.selectedEnrichmentPathways = $scope.enrichmentPathways[3];


            $scope.enrichmentDiseaseDrugs = [
                {value: "LINCS_L1000_Chem_Pert_up"},
                {value: "LINCS_L1000_Chem_Pert_down"},
                {value: "LINCS_L1000_Ligand_Perturbations_up"},

                {value: "LINCS_L1000_Ligand_Perturbations_down"},
                {value: "ARCHS4_IDG_Coexp"},
                {value: "DrugMatrix"},

                {value: "Old_CMAP_up"},
                {value: "Old_CMAP_down"},
                {value: "GeneSigDB"},

                {value: "OMIM_Disease"},
                {value: "OMIM_Expanded"},
                {value: "VirusMINT"},

                {value: "MSigDB_Computational"},
                {value: "MSigDB_Oncogenic_Signatures"},
                {value: "Virus_Perturbations_from_GEO_up"},

                {value: "Virus_Perturbations_from_GEO_down"},
                {value: "Achilles_fitness_increase"},
                {value: "Achilles_fitness_decrease"},
                {value: "dbGaP"}
            ];

            $scope.selectedEnrichmentDiseaseDrugs = $scope.enrichmentDiseaseDrugs[0];


            $scope.enrichmentOntology = [
                {value: "GO_Cellular_Component_2017b"},
                {value: "GO_Biological_Process_2017b"},
                {value: "GO_Molecular_Function_2017b"},

                {value: "MGI_Mammalian_Phenotype_2017"},
                {value: "Human_Phenotype_Ontology"},
                {value: "Jensen_TISSUES"},

                {value: "Jensen_COMPARTMENTS"},
                {value: "Jensen_DISEASES"}
            ];

            $scope.selectedEnrichmentOntology = $scope.enrichmentOntology[0];


            $scope.enrichmentTranscription = [
                {value: "ChEA_2016"},
                {value: "TRANSFAC_and_JASPAR_PWMs"},
                {value: "ARCHS4_TFs_Coexp"},

                {value: "Genome_Browser_PWMs"},
                {value: "ENCODE_and_ChEA_Consensus_TFs_from_ChIP-X"},
                {value: "Epigenomics_Roadmap_HM_ChIP-seq"},

                {value: "TargetScan_microRNA"},
                {value: "ENCODE_TF_ChIP-seq_2015"},
                {value: "TF-LOF_Expression_from_GEO"},

                {value: "ENCODE_Histone_Modifications_2015"},
                {value: "Transcription_Factor_PPIs"}

            ];

            $scope.selectedEnrichmentTranscription = $scope.enrichmentTranscription[0];


            $scope.enrichmentCellType = [
                {value: "Human_Gene_Atlas"},
                {value: "Mouse_Gene_Atlas"},
                {value: "ARCHS4_Tissues"},

                {value: "ARCHS4_Cell-lines"},
                {value: "Allen_Brain_Atlas_up"},
                {value: "Allen_Brain_Atlas_down"},

                {value: "GTEx_Tissue_Sample_Gene_Expression_Profiles_up"},
                {value: "GTEx_Tissue_Sample_Gene_Expression_Profiles_down"},
                {value: "Cancer_Cell_Line_Encyclopedia"},

                {value: "NCI-60_Cancer_Cell_Lines"},
                {value: "Tissue_Protein_Expression_from_ProteomicsDB"},
                {value: "Tissue_Protein_Expression_from_Human_Proteome_Map"},
                {value: "ESCAPE"}

            ];

            $scope.selectedEnrichmentCellType = $scope.enrichmentCellType[0];


            var network = inputNetwork.KEGG_2019_Human;
            $scope.enrichmentTable = network.table;
            //console.log($scope.enrichmentTable);
            //console.log(inputNetwork);
            $scope.enrichmentItem = 'KEGG_2019_Human';
            // //console.log(network.parallel);
            // //console.log(network.circular);
            // update(network.nodes, network.edges, network.parallel, network.circular);

            inputNodes = network.nodes;
            //console.log(inputNodes);

            for (var iterNetNode = 0; iterNetNode < network.nodes.length; iterNetNode++)
            {
                var iterNetNodeKey = network.nodes[iterNetNode]["name"]
                if (iterNetNodeKey in geneToAbundance)
                {
                    if (geneToAbundance[iterNetNodeKey] == "NA")
                    {
                        network.nodes[iterNetNode]["value"] = 0.0;
                    }
                    else {
                        network.nodes[iterNetNode]["value"] = geneToAbundance[iterNetNodeKey];
                    }
                }
            }

            if(self.computeWeightForUpdateEnrichment) {
                for (var iterNetNode = 0; iterNetNode < network.edges.length; iterNetNode++)
                {
                    //var iterNetNodeKey = network.nodes[iterNetNode]["name"];
                    var idx1 = network.edges[iterNetNode]["source"];
                    var idx2 = network.edges[iterNetNode]["target"];
                    network.nodes[idx1]["weight"] += 1;
                    network.nodes[idx2]["weight"] += 1;

                }
                self.computeWeightForUpdateEnrichment = false;
                SharedService.setVar('computeWeightForUpdateEnrichment',self.computeWeightForUpdateEnrichment);
            }
            ////console.log(network.nodes);
            updateEnrichment(network.nodes, network.edges, graphType, circleSliderValue, nodeSliderValue, fontSliderValue, widthSliderValue);
            $scope.changedValue = function (item) {

                var net = item.value.toString();
                //console.log(net);

                //var net = item.value;
                //$scope.showGeneEnrichmentProcessed = false;
                self.showGeneEnrichmentChangeProcessed = false;
                if (self.enrichmentNetwork.hasOwnProperty(net)) {

                    //console.log(net);
                    //console.log("Network has the property");
                    //console.log(item.value);
                    $scope.enrichmentItem = net;

                    var network = self.enrichmentNetwork[net];
                    //console.log('network');
                    //console.log(network);
                    // //console.log(network.parallel);
                    // //console.log(network.circular);
                    // update(network.nodes, network.edges, network.parallel, network.circular);
                    self.showGeneEnrichmentChangeProcessed = true;

                    updateEnrichment(network.nodes, network.edges, graphType, circleSliderValue, nodeSliderValue, fontSliderValue, widthSliderValue);

                }
                else {
                    //console.log("Adding to network");
                    $scope.enrichmentError = false;
                    $http.get("api/enrichment/target/" + net + "/genes/" + self.parsedGenes)

                        .success(function (apiNetwork) {
                            self.showGeneEnrichmentChangeProcessed = true;
                            SharedService.setVar('showGeneEnrichmentProcessed', $scope.showGeneEnrichmentProcessed);
                            //spinner.stop();
                            // self.enrichmentNetwork = {};
                            // self.enrichmentNetwork

                            if(self.computeWeightForUpdateEnrichment) {
                                for (var iterNetNode = 0; iterNetNode < apiNetwork.edges.length; iterNetNode++) {
                                    //var iterNetNodeKey = network.nodes[iterNetNode]["name"];
                                    var idx1 = apiNetwork.edges[iterNetNode]["source"];
                                    var idx2 = apiNetwork.edges[iterNetNode]["target"];
                                    apiNetwork.nodes[idx1]["weight"] += 1;
                                    apiNetwork.nodes[idx2]["weight"] += 1;
                                    // //console.log(apiNetwork.nodes[idx2]["weight"]);
                                    // //console.log(apiNetwork.nodes[idx1]["weight"]);

                                }
                                self.computeWeightForUpdateEnrichment = false;
                                SharedService.setVar('computeWeightForUpdateEnrichment',self.computeWeightForUpdateEnrichment);
                            }
                            for (var iterNetNode = 0; iterNetNode < apiNetwork.nodes.length; iterNetNode++)
                            {
                                var iterNetNodeKey = apiNetwork.nodes[iterNetNode]["name"]
                                if (iterNetNodeKey in geneToAbundance)
                                {
                                    if (geneToAbundance[iterNetNodeKey] == "NA")
                                    {
                                        apiNetwork.nodes[iterNetNode]["value"] = 0.0;
                                    }
                                    else {
                                        apiNetwork.nodes[iterNetNode]["value"] = geneToAbundance[iterNetNodeKey];
                                    }
                                }
                            }

                            self.enrichmentNetwork[net] = apiNetwork;
                            SharedService.setVar('enrichmentNetwork', self.enrichmentNetwork);

                            //console.log(self.enrichmentNetwork);


                            $scope.enrichmentItem = net;
                            var network = self.enrichmentNetwork[net];
                            //console.log('network');
                            //console.log(network);
                            $scope.enrichmentTable = network.table;
                            //console.log($scope.enrichmentTable);
                            // //console.log(network.circular);
                            // update(network.nodes, network.edges, network.parallel, network.circular);
                            //self.showGeneEnrichmentChangeProcessed = true;





                            updateEnrichment(network.nodes, network.edges, graphType, circleSliderValue, nodeSliderValue, fontSliderValue, widthSliderValue);

                            ////console.log(self.network);

                        })
                        .error(function () {
                            //console.log("Error in obtaining network from api/enrichment/genes/");
                            $scope.enrichmentError = true;
                        });

                }
                //$scope.itemList.push(item.value);
            }
            self.showEnrichmentGraph = true;
        }

    }

    $scope.tryEnrichmentGraph = function () {

        self.showPathwayGraph = false;
        self.showPathwayGraphTmp = true;

    }

    $scope.hidePathwayGraph = function () {

        self.showPathwayGraph = false;
        self.showPathwayGraphTmp = true;

    }





    $scope.graphType4pathway = 1;
    $scope.circleSliderValue4pathway = 1100;
    $scope.nodeSliderValue4pathway = 15;
    $scope.fontSliderValue4pathway = 14;
    $scope.widthSliderValue4pathway = 1500;
    $(document).on('input', '#circle_slider4pathway', function() {
        $('#circle_slider_value4pathway').html( $(this).val() );
        ////console.log($(this).val());
        $scope.circleSliderValue4pathway = $(this).val();

        $scope.$apply();

        $scope.makePathwayGraph(self.network, self.geneToAbundanceMap, $scope.graphType4pathway, $scope.circleSliderValue4pathway, $scope.nodeSliderValue4pathway, $scope.fontSliderValue4pathway, $scope.widthSliderValue4pathway);

    });

    $(document).on('input', '#node_slider4pathway', function() {
        $('#node_slider_value4pathway').html( $(this).val() );
        ////console.log($(this).val());
        $scope.nodeSliderValue4pathway = $(this).val();

        $scope.$apply();

        $scope.makePathwayGraph(self.network, self.geneToAbundanceMap, $scope.graphType4pathway, $scope.circleSliderValue4pathway, $scope.nodeSliderValue4pathway, $scope.fontSliderValue4pathway, $scope.widthSliderValue4pathway);

    });

    $(document).on('input', '#font_slider4pathway', function() {
        $('#font_slider_value4pathway').html( $(this).val() );
        ////console.log($(this).val());
        $scope.fontSliderValue4pathway = $(this).val();

        $scope.$apply();

        $scope.makePathwayGraph(self.network, self.geneToAbundanceMap, $scope.graphType4pathway, $scope.circleSliderValue4pathway, $scope.nodeSliderValue4pathway, $scope.fontSliderValue4pathway, $scope.widthSliderValue4pathway);

    });

    $(document).on('input', '#width_slider4pathway', function() {
        $('#width_slider_value4pathway').html( $(this).val() );
        ////console.log($(this).val());
        $scope.widthSliderValue4pathway = $(this).val();

        $scope.$apply();

        $scope.makePathwayGraph(self.network, self.geneToAbundanceMap, $scope.graphType4pathway, $scope.circleSliderValue4pathway, $scope.nodeSliderValue4pathway, $scope.fontSliderValue4pathway, $scope.widthSliderValue4pathway);

    });





    $scope.makePathwayGraph = function (inputNetwork, geneToAbundance, graphType, circleSliderValue, nodeSliderValue, fontSliderValue, widthSliderValue) {
        //console.log("in makePathwayGraph");
        //console.log(inputNetwork);
        if(self.showPathwayGraphTmp)
        {
            self.showPathwayGraph = true;
            self.showPathwayGraphTmp = false;
        }
        else {
            self.showPathwayGraph = false;
            self.showPathwayGraphTmp = true;
            console.log("in makePathwayGraph");
            d3.select("#chart").select("svg").remove();
            if (typeof svg === 'undefined') {
                var svg = d3.selectAll("#chart").append("svg");
            }


            var force;
            var colNodeScaleSeparate = d3.scale.ordinal()
                .range(["#987024", "#ed0909", "#0af702"])
                //.range(["#987024", "#982482", "#0af702"])
                .domain([0, 1, 2]);
//#f9a3f5
            // var colNodeScaleSeparate = d3.scale.ordinal()
            //     .range(["#767776", "#f91104", "#0af702"])
            //     .domain([0,1,2]);

            var colNodeScale = d3.scale.linear().range(["#987024", "#ed0909"]);
            var colScale = d3.scale.linear().range(["#987024", "#ed0909"]);
            var edgeWeightScale = d3.scale.linear().range([1, 3]);
            var xScale = d3.scale.linear().range([nodeSliderValue/3.0, nodeSliderValue]);
            //var xScale = d3.scale.linear().range([5, 15]);
            var textPlacePlusMinus = d3.scale.ordinal()
                .range([18, -18])
                .domain([1, 2]);
            var textPlaceStartEnd = d3.scale.ordinal().range(["start", "end"])
                .domain([1, 2]);

            var colorsForAbundance = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
            var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];
            var colorScale = d3.scale.threshold()
                .domain(domain_data)
                .range(colorsForAbundance);

            function update(nodes, links, graphType, circleValue, nodeValue, fontValue, widthValue) {
                //
                //var svg;
                circleValue = Math.min(circleValue, widthValue - 300);

                // $('force1').click();
                //document.getElementById('force1').click();

                // //console.log(circularLayout);
                function defaultView1() {


                    svg.remove();

                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    colNodeScale.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));

                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = w,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;

//These variables are global variables
                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;

                    svg = d3.select("#chart")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);
                    svg.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");


                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h])
                        .linkDistance(150)
                        .charge(-500)
                        //.linkStrength(0.9)
                        //.friction(0.9)
                        //.chargeDistance(300)
                        .gravity(0.25)
                        //.theta(0.8)
                        //.alpha(0.1)
                        .on("tick", tick)
                        .start();

                    // for (var i = n*n; i > 0; --i) force.tick();
                    // force.stop();

                    //.stop();


                    var path = svg.append("svg:g").selectAll("path")
                    //.data(links)
                        .data(force.links())
                        .enter().append("svg:path")
                        .style("stroke-width", 1)
                        .style('stroke', "black")
                        //.style("stroke", function (d) {return colScale(d.value); })
                        .attr("class", function (d) {
                            return "link ";
                        });


                    var node = svg.append("svg:g").selectAll("g.node")
                        .data(force.nodes())
                        .enter().append("svg:g")
                        // .style("stroke-width", 3)
                        // .style('stroke', "black")
                        //.attr("class", "node")
                        .call(force.drag);

                    // nodes.forEach(function(v) {
                    //     var nd;
                    //     var cx = v.coord[0];
                    //     var cy = v.coord[1];
                    //
                    //     switch (v.group) {
                    //         case 1:
                    //             nd = svg.append("circle");
                    //             break;
                    //         case 2:
                    //             nd = svg.append("rect");
                    //             break;
                    //     }
                    // });

                    node.append("circle")
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        .style("fill", function (d) {
                            if (d.group == 1) {
                                return colorScale(d.value);
                            }
                            else {
                                return colNodeScale(d.group);
                            }
                            //return colNodeScale(d.group);
                        })
                        // .style("fill", function (d) {
                        //     return colNodeScale(d.group);
                        // })
                        .style("stroke", "#333")
                        .style("stroke-width", "2px");
                    //.on("dblclick", dblclick);


                    function openLink() {
                        return function (d) {
                            var url = "";
                            if (d.slug != "") {
                                url = d.slug
                            } //else if(d.type == 2) {
                            //url = "clients/" + d.slug
                            //} else if(d.type == 3) {
                            //url = "agencies/" + d.slug
                            //}
                            window.open("//" + url)
                        }
                    };
                    node.append("svg:image")
                    //****************************************
                    //.attr("class", function(d){ return d.name })
                    //****************************************
                    //.attr("xlink:href", function(d){ return d.img_hrefD})
                        .attr("x", "-36px")
                        .attr("y", "-36px")
                        .attr("width", "70px")
                        .attr("height", "70px")
                    //.on("dblclick", openLink());

                    // .on("mouseover", function (d) { if(d.entity == "company")
                    // {
                    //     d3.select(this).attr("width", "90px")
                    //         .attr("x", "-46px")
                    //         .attr("y", "-36.5px")
                    //         .attr("xlink:href", function(d){ return d.img_hrefL});
                    // }
                    // })
                    // .on("mouseout", function (d) { if(d.entity == "company")
                    // {
                    //     d3.select(this).attr("width", "70px")
                    //         .attr("x", "-36px")
                    //         .attr("y", "-36px")
                    //         .attr("xlink:href", function(d){ return d.img_hrefD});
                    // }
                    // });


                    //.text(function(d) { return d.name })
                    node.append("svg:text")
                    //****************************************
                        .attr("class", function (d) {
                            return d.full_name
                        })
                        //****************************************
                        .attr("x", 16)
                        .attr("y", ".31em")
                        //.attr("class", "shadow")
                        //.style("font-size","10px")
                        // .attr("dx", 0)
                        // .attr("dy", ".35em")
                        //.style("font-size","12px")
                        //****************************************
                        //text.shadow {
                        .style("stroke", "#fff")
                        .style("stroke-width", "4px")
                        //}
                        //.attr("class", "shadow")
                        .style("font", String(fontValue) + "px Arial")
                        //.style("font", "14px Times New Roman")
                        //****************************************
                        //.attr("text-anchor", "middle")
                        //****************************************
                        .text(function (d) {
                            return d.full_name
                        });
                    //****************************************


                    //This one is for the actual text
                    node.append("svg:text")
                    //****************************************
                        .attr("class", function (d) {
                            return d.full_name
                        })
                        //****************************************
                        .attr("x", 16)
                        .attr("y", ".31em")
                        //.attr("class", "shadow")
                        //.style("font-size","10px")
                        // .attr("dx", 0)
                        // .attr("dy", ".35em")
                        //.style("font-size","12px")
                        //****************************************
                        //.style("font", "14px Times New Roman")
                        .style("font", String(fontValue) + "px Arial")
                        //****************************************
                        //.attr("text-anchor", "middle")
                        //****************************************
                        .text(function (d) {
                            return d.full_name
                        });
                    //****************************************


                    node.on("mouseover", function (d) {
                        // d3.select(this).select("text")
                        //     .transition()
                        //     .duration(300)
                        //     .text(function (d) {
                        //         return d.full_name;
                        //     })
                        // //.style("font-size", "15px")
                        // .style("font", "14px Times New Roman");
                        //
                        // d3.select(this).select("text")
                        //     .transition()
                        //     .duration(300)
                        //     .text(function (d) {
                        //         return d.full_name;
                        //     })
                        //     //.style("font-size", "15px")
                        //     //.attr("class", "shadow")
                        //     .style("font", "14px Times New Roman");
                        // d3.select(this).select("text")
                        //     .transition()
                        //     .duration(300)
                        //     .text(function (d) {
                        //         return d.full_name;
                        //     })
                        //
                        //     .style("fill",'black')
                        //     .style("font", "14px Times New Roman");

                        //d3.selectAll("text").remove();
                        //d3.select(this).style("stroke-width", 6);

                        //d3.select(this).select("text").style("stroke", "blue");

                        var nodeNeighbors = links.filter(function (link) {
                            // Filter the list of links to only those links that have our target
                            // node as a source or target
                            return link.source.index === d.index || link.target.index === d.index;
                        })
                            .map(function (link) {
                                // Map the list of links to a simple array of the neighboring indices - this is
                                // technically not required but makes the code below simpler because we can use
                                // indexOf instead of iterating and searching ourselves.
                                return link.source.index === d.index ? link.target.index : link.source.index;
                            });

                        d3.selectAll('circle').filter(function (node) {
                            // I filter the selection of all circles to only those that hold a node with an
                            // index in my listg of neighbors
                            return nodeNeighbors.indexOf(node.index) > -1;
                        })
                            .style('stroke', 'blue');

                        //d3.selectAll('text').filter(d).style('fill', 'blue');
                        //****************************
                        // d3.selectAll('text').filter(function(node) {
                        //     // I filter the selection of all circles to only those that hold a node with an
                        //     // index in my listg of neighbors
                        //     return nodeNeighbors.indexOf(node.index) > -1;
                        // }).style('fill', 'blue')
                        //     //.style("font-size", "16px")
                        //     //.style("font-weight", "bold");
                        // //****************************
                        path.style('stroke', function (l) {
                            if (d === l.source || d === l.target)
                                return "blue";
                            else
                                return "grey";
                        })

                        path.style('stroke-width', function (l) {
                            if (d === l.source || d === l.target)
                                return 2;
                            else
                                return 1;
                        })

                    })
                        .on("mouseout", function (d) {
                            d3.select(this).select("text")
                                .transition()
                                .duration(300)
                                .text(function (d) {

                                    return d.full_name;
                                });
                            // d3.select(this).select("text")
                            //     //*******************************
                            //     .style("font", "14px Times New Roman")
                            //     //*******************************
                            //     .style("font-size", "14px")
                            //     .style("fill",'black')
                            //     .style("font-weight", "normal");

                            // d3.select(this).select("text")
                            // //*******************************
                            //     .style("font", "14px Times New Roman")
                            //     //*******************************
                            //     .style("font-size", "14px")
                            //     .style("fill",'black')
                            //     .style("font-weight", "normal");
                            //d3.select(this).style("stroke", "black");
                            //d3.select(this).style("stroke-width", 1);
                            //d3.select(this).style("stroke", "#333");
                            path.style('stroke', "grey");
                            path.style('stroke-width', 1);
                            //circle.style('stroke', "grey");
                            //node.style("stroke-width", 3);
                            //node.style("stroke", "#333");
                            //d3.selectAll('text').style('fill', 'black')
                            // d3.selectAll('text').style('fill', 'black')
                            //     .style("font-weight", "normal");
                            //d3.selectAll("text").style("font-weight", "normal");
                            node.selectAll("circle").style("stroke-width", 3)
                                .style('stroke', "black");
                            //.style("font-size", "12px");
                            //}
                        });


                    function pythag(r, b, coord) {
                        r += nodeBaseRad;

                        // force use of b coord that exists in circle to avoid sqrt(x<0)
                        b = Math.min(w - r - strokeWidth, Math.max(r + strokeWidth, b));

                        var b2 = Math.pow((b - radius), 2),
                            a = Math.sqrt(hyp2 - b2);

                        function openLink() {
                            return function (d) {
                                var url = "";
                                if (d.slug != "") {
                                    url = d.slug
                                } //else if(d.type == 2) {
                                //url = "clients/" + d.slug
                                //} else if(d.type == 3) {
                                //url = "agencies/" + d.slug
                                //}
                                window.open("//" + url)
                            }
                        }

                        // radius - sqrt(hyp^2 - b^2) < coord < sqrt(hyp^2 - b^2) + radius
                        coord = Math.max(radius - a + r + strokeWidth,
                            Math.min(a + radius - r - strokeWidth, coord));

                        return coord;
                    }

                    function tick(e) {
                        path.attr("d", function (d) {
                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,

                                dr = Math.sqrt(dx * dx + dy * dy);
                            ////console.log(d.source.x);
                            // //console.log(d.target.x);
                            return "M" + d.source.x + "," + d.source.y + "," + d.target.x + "," + d.target.y;
                            //return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
                        });

                        node.attr('x', function (d) {
                            return d.x = pythag(Math.random() * 12, d.y, d.x);
                        })
                            .attr('y', function (d) {
                                return d.y = pythag(Math.random() * 12, d.x, d.y);
                            })
                            .attr("transform", function (d) {
                                return "translate(" + d.x + "," + d.y + ")"
                            });

                        //d3.select(this).classed("fixed", d.fixed = true);
                        // circle.attr("transform", function(d) {
                        //     return "translate(" + d.x + "," + d.y + ")";
                        // });
                        //************************************
                        // text.attr("transform", function(d) {
                        //     return "translate(" + d.x + "," + d.y + ")";
                        // });
                        //************************************
                    }

                    //For not moving after drag
                    var drag = force.drag()
                        .on("dragstart", dragstart);
                    //.on("dragstart", dragstartAll);

                    //For not moving after drag
                    function dblclick(d) {
                        d3.select(this).classed("fixed", d.fixed = false);

                    }

                    //For not moving after drag
                    function dragstart(d) {
                        d3.select(this).classed("fixed", d.fixed = true);

                        for (i = 0; i < nodes.length; i++) {
                            nodes[i].fixed = true;
                        }
                    }


                    var svgText = svg.append("text");
                    svgText.attr("x",10).attr("y",globalHPlus50-50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);



                    var legend2 = svg.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());

                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();



                    // For legend
                    // var colNodeScaleSeparateInfo = d3.scale.ordinal()
                    //     .range(["#767776", "#f91104"])
                    //     .domain(["Query Gene Set", "Pathways / Kinases Perturbation"]);
                    //
                    //
                    // var legend = svg.selectAll(".legend")
                    //     .data(colNodeScaleSeparateInfo.domain())
                    //     .enter().append("g")
                    //     .attr("class", "legend")
                    //     .attr("transform", function (d, i) {
                    //         return "translate(0," + (i) * 25 + ")";
                    //     });
                    //
                    // legend.append("rect")
                    //     .attr("x", w - 25)
                    //     .attr("width", 25)
                    //     .attr("height", 25)
                    //     .style("fill", colNodeScaleSeparateInfo);
                    //
                    // legend.append("text")
                    //     .attr("x", w - 35)
                    //     .attr("y", 12.5)
                    //     .attr("dy", ".35em")
                    //     .style("text-anchor", "end")
                    //     .text(function (d) {
                    //         return d;
                    //     });
                    //
                    //
                    // d3.select("#download").on("click", function () {
                    //     d3.select(this)
                    //         .attr("href", 'data:application/octet-stream;base64,' + btoa(d3.select("#chart").html()))
                    //         .attr("download", "pathway_network.svg")
                    // })

                };


                function circularView1(){
                    svg.remove();

                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    colNodeScale.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));
                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = w,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;


                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;


                    svg = d3.select("#chart")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);
                    svg.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");


                    // This is for grouping nodes


                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h]);

// evenly spaces nodes along arc
                    var circleCoord = function (node, index, num_nodes) {
                        var circumference = circle.node().getTotalLength();
                        var pointAtLength = function (l) {
                            return circle.node().getPointAtLength(l)
                        };
                        var sectionLength = (circumference) / num_nodes;
                        var position = sectionLength * index + sectionLength / 2;
                        return pointAtLength(circumference - position)
                    }

                    var is_connected = function (d, opacity) {
                        lines.transition().style("stroke-opacity", function (o) {
                            return o.source === d || o.target === d ? 1 : opacity;
                        });
                    }


                    var dim = w - (widthValue - circleValue);
                    var circle = svg.append("path")
                        .attr("d", "M " + String((widthValue - circleValue)/2) + ", " + (dim / 2 + (widthValue - circleValue)/2) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                        .style("fill", "white");

                    // var dim = w - 900
                    // var circle = svg.append("path")
                    //     .attr("d", "M 450, " + (dim / 2 + 450) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                    //     .style("fill", "white");

                    force.start();

                    nodes.forEach(function (n, i) {
                        var coord = circleCoord(n, i, nodes.length)
                        n.x = coord.x
                        n.y = coord.y
                    });


                    // use this one for straight line links...
                    // var lines = svg.selectAll("line.node-link")
                    //     .data(links).enter().append("line")
                    //     .attr("class", "node-link")
                    //     .attr("x1", function(d) { return d.source.x; })
                    //     .attr("y1", function(d) { return d.source.y; })
                    //     .attr("x2", function(d) { return d.target.x; })
                    //     .attr("y2", function(d) { return d.target.y; });

                    var lines = svg.selectAll("path.node-link")
                        .data(links).enter().append("path")
                        .style("fill", "none")
                        .style("stroke", "#726363")
                        .attr("class", "node-link")
                        .attr("d", function (d) {
                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,
                                dr = Math.sqrt(dx * dx + dy * dy);
                            return "M" +
                                d.source.x + "," +
                                d.source.y + "," +
                                d.target.x + "," +
                                d.target.y;

                        });


                    var gnodes = svg.selectAll('g.gnode')
                        .data(nodes).enter().append('g')
                        .attr("transform", function (d) {
                            return "translate(" + d.x + "," + d.y + ")"
                        })
                        .classed('gnode', true);


                    // node.append("circle")
                    //     .attr("r", function (d) { return xScale(d.weight); })
                    //     .style("fill", function(d) { return colNodeScale(d.group); });

                    var node = gnodes.append("circle")
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        .style("fill", function (d) {
                            if (d.group == 1) {
                                return colorScale(d.value);
                            }
                            else {
                                return colNodeScale(d.group);
                            }
                            //return colNodeScale(d.group);
                        })
                        // .style("fill", function (d) {
                        //     return colNodeScale(d.group);
                        // })
                        .style("stroke", "#333")
                        .style("stroke-width", "2px")
                        //.attr("class", "node")
                        .on("mouseenter", function (d) {
                            is_connected(d, 0.1)
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            d3.select(this).transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight + 10);
                            })
                        })
                        .on("mouseleave", function (d) {
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            is_connected(d, 1);
                        })
                        .call(force.drag);

                    var labels = gnodes.append("text")
                        .attr("dx", 4)
                        .attr("dy", 4)
                        .style("font", String(fontValue) + "px Arial")
                        //.style("font", "14px Times New Roman")
                        .attr("text-anchor", function (d) {
                            return d.x < w / 2 ? "end" : "start";
                        })
                        .attr("transform", function (d) {
                            return d.x < w / 2 ? "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(-20)" : "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(20)";
                        })
                        //.attr("transform", function(d) { return  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")"})
                        //.attr("transform", function(d) { return (d.x-w/2)/(d.y-w/2) < 0 ?  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")" : "rotate(180)"; })
                        .text(function (d) {
                            return d.full_name
                        })

                    var drag = force.drag()
                        .on("dragstart", dragstart);
                    //.on("dragstart", dragstartAll);


                    //For not moving after drag
                    function dragstart(d) {
                        d3.select(this).classed("fixed", d.fixed = true);

                        for (i = 0; i < nodes.length; i++) {
                            nodes[i].fixed = true;
                        }
                    }


                    var svgText = svg.append("text");
                    svgText.attr("x",10).attr("y",globalHPlus50-50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);



                    var legend2 = svg.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());

                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();




                };

                function circosView1(){
                    svg.remove();

                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    colNodeScale.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));
                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = w,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;


                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;


                    svg = d3.select("#chart")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);
                    svg.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");


                    // This is for grouping nodes


                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h]);

// evenly spaces nodes along arc
                    var circleCoord = function (node, index, num_nodes) {
                        var circumference = circle.node().getTotalLength();
                        var pointAtLength = function (l) {
                            return circle.node().getPointAtLength(l)
                        };
                        var sectionLength = (circumference) / num_nodes;
                        var position = sectionLength * index + sectionLength / 2;
                        return pointAtLength(circumference - position)
                    }

                    var is_connected = function (d, opacity) {
                        lines.transition().style("stroke-opacity", function (o) {
                            return o.source === d || o.target === d ? 1 : opacity;
                        });
                    }


                    var dim = w - (widthValue - circleValue);
                    var circle = svg.append("path")
                        .attr("d", "M " + String((widthValue - circleValue)/2) + ", " + (dim / 2 + (widthValue - circleValue)/2) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                        .style("fill", "white");

                    // var dim = w - 900
                    // var circle = svg.append("path")
                    //     .attr("d", "M 450, " + (dim / 2 + 450) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                    //     .style("fill", "white");

                    force.start();

                    nodes.forEach(function (n, i) {
                        var coord = circleCoord(n, i, nodes.length)
                        n.x = coord.x
                        n.y = coord.y
                    });


                    // use this one for straight line links...
                    // var lines = svg.selectAll("line.node-link")
                    //     .data(links).enter().append("line")
                    //     .attr("class", "node-link")
                    //     .attr("x1", function(d) { return d.source.x; })
                    //     .attr("y1", function(d) { return d.source.y; })
                    //     .attr("x2", function(d) { return d.target.x; })
                    //     .attr("y2", function(d) { return d.target.y; });

                    var lines = svg.selectAll("path.node-link")
                        .data(links).enter().append("path")
                        .style("fill", "none")
                        .style("stroke", "#726363")
                        .attr("class", "node-link")
                        .attr("d", function (d) {

                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,
                                dr = Math.sqrt(dx * dx + dy * dy),
                                a1 = dx,
                                a2 = dy,
                                c1 = w / 2 - d.source.x,
                                c2 = h / 2 - d.source.y,
                                d1 = w / 2 - d.target.x,
                                d2 = h / 2 - d.target.y,

                                drx = dr / 1.5,
                                dry = dr / 1.5,
                                xRotation = 0, // degrees
                                largeArc = 0, // 1 or 0

                                sweep = 1, // 1 or 0
                                x2 = d.target.x,
                                y2 = d.target.y;


                            // if( (a1*c2 - a2*c1) > 0)
                            // {
                            //     sweep = 0
                            // }
                            // else
                            // {sweep = 1}
                            if ((c1 * d2 - c2 * d1) > 0) {
                                sweep = 0
                            }
                            else {
                                sweep = 1
                            }


                            return "M" + d.source.x + "," + d.source.y + "A" + drx + "," + dry + " " + xRotation + "," + largeArc + "," + sweep + " " + x2 + "," + y2;
                        });
                        // .attr("d", function (d) {
                        //     var dx = d.target.x - d.source.x,
                        //         dy = d.target.y - d.source.y,
                        //         dr = Math.sqrt(dx * dx + dy * dy);
                        //     return "M" +
                        //         d.source.x + "," +
                        //         d.source.y + "," +
                        //         d.target.x + "," +
                        //         d.target.y;
                        //
                        // });


                    var gnodes = svg.selectAll('g.gnode')
                        .data(nodes).enter().append('g')
                        .attr("transform", function (d) {
                            return "translate(" + d.x + "," + d.y + ")"
                        })
                        .classed('gnode', true);


                    // node.append("circle")
                    //     .attr("r", function (d) { return xScale(d.weight); })
                    //     .style("fill", function(d) { return colNodeScale(d.group); });

                    var node = gnodes.append("circle")
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        .style("fill", function (d) {
                            if (d.group == 1) {
                                return colorScale(d.value);
                            }
                            else {
                                return colNodeScale(d.group);
                            }
                            //return colNodeScale(d.group);
                        })
                        // .style("fill", function (d) {
                        //     return colNodeScale(d.group);
                        // })
                        .style("stroke", "#333")
                        .style("stroke-width", "2px")
                        //.attr("class", "node")
                        .on("mouseenter", function (d) {
                            is_connected(d, 0.1)
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            d3.select(this).transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight + 10);
                            })
                        })
                        .on("mouseleave", function (d) {
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            is_connected(d, 1);
                        })
                        .call(force.drag);

                    var labels = gnodes.append("text")
                        .attr("dx", 4)
                        .attr("dy", 4)
                        .style("font", String(fontValue) + "px Arial")
                        //.style("font", "14px Times New Roman")
                        .attr("text-anchor", function (d) {
                            return d.x < w / 2 ? "end" : "start";
                        })
                        .attr("transform", function (d) {
                            return d.x < w / 2 ? "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(-20)" : "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(20)";
                        })
                        //.attr("transform", function(d) { return  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")"})
                        //.attr("transform", function(d) { return (d.x-w/2)/(d.y-w/2) < 0 ?  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")" : "rotate(180)"; })
                        .text(function (d) {
                            return d.full_name
                        })

                    var drag = force.drag()
                        .on("dragstart", dragstart);
                    //.on("dragstart", dragstartAll);


                    //For not moving after drag
                    function dragstart(d) {
                        d3.select(this).classed("fixed", d.fixed = true);

                        for (i = 0; i < nodes.length; i++) {
                            nodes[i].fixed = true;
                        }
                    }


                    var svgText = svg.append("text");
                    svgText.attr("x",10).attr("y",globalHPlus50-50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);



                    var legend2 = svg.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());

                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();




                };

                function parallelView1() {
                    //d3.select('#parallelView1').on('click', function () {
                    svg.remove();

                    //xPosition.domain(d3.extent(nodes, function (d) { return d.text; }));
                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    colNodeScale.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));
                    textPlacePlusMinus.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    textPlaceStartEnd.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));

                    n1 = 0;
                    n2 = 0;

                    nodes.forEach(function (n, i) {


                        if (n.group == 1) {

                            n1 = n1 + 1;
                        }
                        if (n.group == 2) {

                            n2 = n2 + 1;
                        }

                    });

                    //console.log(n1);
                    //console.log(n1 * 12);
                    //console.log(n2);
                    //console.log(n2 * 12);
                    var parallelH = Math.max(n1 * 12, n2 * 12, 500);
                    //var parallelH = Math.max(n1 * 12, n2 * 12);

                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = parallelH,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;

                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;


                    svg = d3.select("#chart")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);

                    svg.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");


                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h]);


                    var parallelCoordx = function (group) {

                        if (group == 1) {
                            return w * 1.5 / 3.;
                        }
                        else {
                            return w / 3.;
                        }
                    }

                    var parallelCoordy = function (index, num_nodes) {
                        var dist = h / (num_nodes + 1);

                        return (index + 1) * dist;
                    }

                    var is_connected = function (d, opacity) {
                        lines.transition().style("stroke-opacity", function (o) {
                            return o.source === d || o.target === d ? 1 : opacity;
                        });
                    }

                    //var dim = w-80
                    // var circle = svg.append("path")
                    //     .attr("d", "M 40, "+(dim/2+40)+" a "+dim/2+","+dim/2+" 0 1,0 "+dim+",0 a "+dim/2+","+dim/2+" 0 1,0 "+dim*-1+",0")
                    //     .style("fill", "#f5f5f5");

                    force.start();


                    // //console.log(nodes.length);
                    var groupId = [];
                    var maxId = 0;
                    for (var i = 0; i < nodes.length; i++) {
                        var item = nodes[i];

                        if (!groupId[item.group]) {
                            groupId[item.group] = [];
                        }

                        groupId[item.group].push({name: item.name});
                        // //console.log(item.group);
                        // //console.log(groupId[item.group]);
                        if (maxId < item.group) {
                            maxId = item.group;
                        }
                    }
                    // //console.log(maxId);
                    // //console.log(groupId[1].length);
                    // //console.log(groupId[2].length);

                    n1 = 0;
                    n2 = 0;

                    nodes.forEach(function (n, i) {
                        var item = nodes[i];

                        if (n.group == 1) {
                            n.x = parallelCoordx(n.group)
                            n.y = parallelCoordy(n1, groupId[1].length)
                            n1 = n1 + 1;
                        }
                        if (n.group == 2) {
                            n.x = parallelCoordx(n.group)
                            n.y = parallelCoordy(n2, groupId[2].length)
                            n2 = n2 + 1;
                        }

                    });


                    // use this one for straight line links...
                    // var lines = svg.selectAll("line.node-link")
                    //   .data(links).enter().append("line")
                    //     .attr("class", "node-link")
                    //   .attr("x1", function(d) { return d.source.x; })
                    //   .attr("y1", function(d) { return d.source.y; })
                    //   .attr("x2", function(d) { return d.target.x; })
                    //   .attr("y2", function(d) { return d.target.y; });

                    var lines = svg.selectAll("path.node-link")
                        .data(links).enter().append("path")
                        .style("fill", "none")
                        .style("stroke", "#726363")
                        .attr("class", "node-link")
                        .attr("d", function (d) {
                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,
                                dr = Math.sqrt(dx * dx + dy * dy);
                            return "M" +
                                d.source.x + "," +
                                d.source.y + "," +
                                d.target.x + "," +
                                d.target.y;
                        });

                    // var lines = svg.selectAll("path.node-link")
                    //     .data(links).enter().append("path")
                    //     .style("fill", "none")
                    //     .style("stroke", "black")
                    //     .attr("class", "node-link")
                    //     .attr("d", function(d) {
                    //         var dx = d.target.x - d.source.x,
                    //             dy = d.target.y - d.source.y,
                    //             dr = Math.sqrt(dx * dx + dy * dy);
                    //         return "M" +
                    //             d.source.x + "," +
                    //             d.source.y + "A" +
                    //             dr + "," + dr + " 0 0,1 " +
                    //             d.target.x + "," +
                    //             d.target.y;
                    //     });

                    var gnodes = svg.selectAll('g.gnode')
                        .data(nodes).enter().append('g')
                        .attr("transform", function (d) {
                            return "translate(" + d.x + "," + d.y + ")"
                        })
                        .classed('gnode', true);

                    var node = gnodes.append("circle")
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        .style("fill", function (d) {
                            if (d.group == 1) {
                                return colorScale(d.value);
                            }
                            else {
                                return colNodeScale(d.group);
                            }
                            //return colNodeScale(d.group);
                        })
                        // .style("fill", function (d) {
                        //     return colNodeScale(d.group);
                        // })
                        .style("stroke", "#333")
                        .style("stroke-width", "2px")
                        //.attr("class", "node")
                        .on("mouseenter", function (d) {
                            is_connected(d, 0.1)
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            d3.select(this).transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight + 10);
                            })
                        })
                        .on("mouseleave", function (d) {
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            is_connected(d, 1);
                        })
                        .call(force.drag);
                    // var bbox = textElement.getBBox();
                    // var width = bbox.width;
                    // var height = bbox.height;
                    var labels = gnodes.append("text")
                        .style("font", String(fontValue) + "px Arial")
                        //.style("font", "14px Times New Roman")
                        .attr("dx", function (d) {
                            return textPlacePlusMinus(d.group);
                        })
                        .attr("dy", 4)
                        .attr("text-anchor", function (d) {
                            return textPlaceStartEnd(d.group);
                        })
                        .text(function (d) {
                            return d.full_name
                        })

                    var svgText = svg.append("text");
                    svgText.attr("x",10).attr("y",globalHPlus50-50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);



                    var legend2 = svg.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());
                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();





                };


                d3.select('#force1').on('click', function () {
                    defaultView1();
                    $scope.graphType4pathway = 0;
                });
                d3.select('#parallelView1').on('click', function () {
                    parallelView1();
                    $scope.graphType4pathway = 1;
                });
                d3.select('#circosView1').on('click', function (){
                    circosView1();
                    $scope.graphType4pathway = 2;
                });
                d3.select('#circularView1').on('click', function (){
                    circularView1();
                    $scope.graphType4pathway = 3;
                });


                if(graphType == 0){
                    defaultView1();
                }
                else if(graphType == 1){
                    parallelView1();
                }
                else if(graphType == 2){
                    circosView1();
                }
                else if(graphType == 3){
                    circularView1();
                }



                d3.select("#download-svg1").on("click", function ()  {
                    var name = 'Pinet-Gene-Pathway-Association-Network.svg';
                    var svgEl = svg.node();
                    svgEl.setAttribute("xmlns", "http://www.w3.org/2000/svg");
                    var svgData = svgEl.outerHTML;
                    var preface = '<?xml version="1.0" standalone="no"?>\r\n';
                    var svgBlob = new Blob([preface, svgData], {type:"image/svg+xml;charset=utf-8"});
                    var svgUrl = URL.createObjectURL(svgBlob);
                    var downloadLink = document.createElement("a");
                    downloadLink.href = svgUrl;
                    downloadLink.download = name;
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                })
//             d3.select('#drug1').on('click', function () {
//                 svg.remove();
//
//                 //xPosition.domain(d3.extent(nodes, function (d) { return d.text; }));
//                 xScale.domain(d3.extent(nodes, function (d) {
//                     return d.weight;
//                 }));
//                 colNodeScale.domain(d3.extent(nodes, function (d) {
//                     return d.group;
//                 }));
//                 colScale.domain(d3.extent(links, function (d) {
//                     return d.weight;
//                 }));
//                 textPlacePlusMinus.domain(d3.extent(nodes, function (d) {
//                     return d.group;
//                 }));
//                 textPlaceStartEnd.domain(d3.extent(nodes, function (d) {
//                     return d.group;
//                 }));
//
//                 var drug_data = {
//                     "nodes": [{"full_name": "PRKCG", "weight": 0, "idx": 0, "group": 1},
//                         {"full_name": "YWHAZ", "weight": 0, "idx": 1, "group": 1},
//                         {"full_name": "ALB", "weight": 0, "idx": 2, "group": 1},
//                         {"full_name": "NSF", "weight": 0, "idx": 3, "group": 1},
//                         {"full_name": "FGA", "weight": 0, "idx": 4, "group": 1},
//                         {"full_name": "VCAN", "weight": 0, "idx": 5, "group": 1},
//                         {"full_name": "AK5", "weight": 0, "idx": 6, "group": 1},
//                         {"full_name": "CAMK2A", "weight": 0, "idx": 7, "group": 1},
//                         {"full_name": "LANCL1", "weight": 0, "idx": 8, "group": 1},
//                         {"full_name": "PRKCB", "weight": 0, "idx": 9, "group": 1},
//                         {"full_name": "CAMK2B", "weight": 0, "idx": 10, "group": 1},
//                         {"full_name": "TUBA1A", "weight": 0, "idx": 11, "group": 1},
//                         {"full_name": "CKB", "weight": 0, "idx": 12, "group": 1},
//                         {"full_name": "TUBB2A", "weight": 0, "idx": 13, "group": 1},
//                         {"full_name": "ACTB", "weight": 0, "idx": 14, "group": 1},
//                         {"full_name": "CAMK2D", "weight": 0, "idx": 15, "group": 1},
//                         {"full_name": "FGG", "weight": 0, "idx": 16, "group": 1},
//                         {"full_name": "APOE", "weight": 0, "idx": 17, "group": 1},
//                         {"full_name": "fluphenazine", "weight": 0, "idx": 18, "group": 2},
//                         {"full_name": "mesoridazine", "weight": 0, "idx": 19, "group": 2},
//                         {"full_name": "thioproperazine", "weight": 0, "idx": 20, "group": 2},
//                         {"full_name": "thioridazine", "weight": 0, "idx": 21, "group": 2},
//                         {"full_name": "trifluoperazine", "weight": 0, "idx": 22, "group": 2}],
//                     "edges": [{"source": 0, "target": 18}, {"source": 0, "target": 21}, {"source": 0, "target": 22},
//                         {"source": 3, "target": 19}, {"source": 3, "target": 20}, {
//                             "source": 3,
//                             "target": 21
//                         }, {"source": 3, "target": 22},
//                         {"source": 4, "target": 19}, {"source": 4, "target": 20}, {
//                             "source": 4,
//                             "target": 21
//                         }, {"source": 4, "target": 22},
//                         {"source": 5, "target": 18}, {"source": 5, "target": 19}, {
//                             "source": 5,
//                             "target": 21
//                         }, {"source": 5, "target": 22},
//                         {"source": 7, "target": 18}, {"source": 7, "target": 21}, {"source": 7, "target": 22},
//                         {"source": 9, "target": 18}, {"source": 9, "target": 21}, {"source": 9, "target": 22},
//                         {"source": 10, "target": 19}, {"source": 10, "target": 20},
//                         {"source": 11, "target": 18}, {"source": 11, "target": 21}, {"source": 11, "target": 22},
//                         {"source": 12, "target": 19}, {"source": 12, "target": 21}, {"source": 12, "target": 22},
//                         {"source": 13, "target": 18}, {"source": 13, "target": 21}, {"source": 13, "target": 22},
//                         {"source": 15, "target": 18}, {"source": 15, "target": 22},
//                         {"source": 17, "target": 22}]
//                 };
//
//                 var margin = 75,
//                     w = 750 - 2 * margin,
//                     h = w,
//                     radius = w / 2,
//                     strokeWidth = 4,
//                     hyp2 = Math.pow(radius, 2),
//                     nodeBaseRad = 5;
//
//
//                 nodes = drug_data.nodes;
//                 links = drug_data.edges;
//                 svg = d3.select("#chart")
//                     .append("svg")
//                     .attr("style", "outline: thin solid yellow;")
//                     .attr("width", w)
//                     .attr("height", h);
//
//                 svg.append("rect")
//                     .attr("width", "100%")
//                     .attr("height", "100%")
//                     .attr("fill", "white");
//
//
//                 var force = d3.layout.force()
//                     .nodes(nodes)
//                     .links(links)
//                     .size([w, h]);
//
//
//                 var parallelCoordx = function (group) {
//
//                     if (group == 1) {
//                         return w * 2 / 3;
//                     }
//                     else {
//                         return w / 2.2;
//                     }
//                 }
//
//                 var parallelCoordy = function (index, num_nodes) {
//                     var dist = h / (num_nodes + 1);
//
//                     return (index + 1) * dist;
//                 }
//
//                 var is_connected = function (d, opacity) {
//                     lines.transition().style("stroke-opacity", function (o) {
//                         return o.source === d || o.target === d ? 1 : opacity;
//                     });
//                 }
//
//                 //var dim = w-80
//                 // var circle = svg.append("path")
//                 //     .attr("d", "M 40, "+(dim/2+40)+" a "+dim/2+","+dim/2+" 0 1,0 "+dim+",0 a "+dim/2+","+dim/2+" 0 1,0 "+dim*-1+",0")
//                 //     .style("fill", "#f5f5f5");
//
//                 force.start();
//
//
//                 // //console.log(nodes.length);
//                 var groupId = [];
//                 var maxId = 0;
//                 for (var i = 0; i < nodes.length; i++) {
//                     var item = nodes[i];
//
//                     if (!groupId[item.group]) {
//                         groupId[item.group] = [];
//                     }
//
//                     groupId[item.group].push({name: item.name});
//                     // //console.log(item.group);
//                     // //console.log(groupId[item.group]);
//                     if (maxId < item.group) {
//                         maxId = item.group;
//                     }
//                 }
//                 // //console.log(maxId);
//                 // //console.log(groupId[1].length);
//                 // //console.log(groupId[2].length);
//
//                 n1 = 0;
//                 n2 = 0;
//
//                 nodes.forEach(function (n, i) {
//                     var item = nodes[i];
//
//                     if (n.group == 1) {
//                         n.x = parallelCoordx(n.group)
//                         n.y = parallelCoordy(n1, groupId[1].length)
//                         n1 = n1 + 1;
//                     }
//                     if (n.group == 2) {
//                         n.x = parallelCoordx(n.group)
//                         n.y = parallelCoordy(n2, groupId[2].length)
//                         n2 = n2 + 1;
//                     }
//
//                 });
//
//
//                 var lines = svg.selectAll("path.node-link")
//                     .data(links).enter().append("path")
//                     .style("fill", "none")
//                     .style("stroke", "#726363")
//                     .attr("class", "node-link")
//                     .attr("d", function (d) {
//                         var dx = d.target.x - d.source.x,
//                             dy = d.target.y - d.source.y,
//                             dr = Math.sqrt(dx * dx + dy * dy);
//                         return "M" +
//                             d.source.x + "," +
//                             d.source.y + "," +
//                             d.target.x + "," +
//                             d.target.y;
//                     });
//
//
//                 var gnodes = svg.selectAll('g.gnode')
//                     .data(nodes).enter().append('g')
//                     .attr("transform", function (d) {
//                         return "translate(" + d.x + "," + d.y + ")"
//                     })
//                     .classed('gnode', true);
//
//
// //to include molecule figure substitute this
//                 var node = gnodes.append("circle")
//                     .attr("r", function (d) {
//                         return xScale(d.weight);
//                     })
//                     .style("fill", function (d) {
//                         return colNodeScale(d.group);
//                     })
//                     .style("stroke", "#333")
//                     .style("stroke-width", "2px")
//                     //.attr("class", "node")
//                     .on("mouseenter", function (d) {
//                         is_connected(d, 0.1)
//                         node.transition().duration(100).attr("r", function (d) {
//                             return xScale(d.weight);
//                         })
//                         d3.select(this).transition().duration(100).attr("r", function (d) {
//                             return xScale(d.weight + 10);
//                         })
//                     })
//                     .on("mouseleave", function (d) {
//                         node.transition().duration(100).attr("r", function (d) {
//                             return xScale(d.weight);
//                         })
//                         is_connected(d, 1);
//                     })
//                     .call(force.drag);
//
//
//                 // gnodes.append("image")
//                 //     .attr("xlink:href", function(d) { return d.group < 2 ? "images/molecule-icon.png" : "images/pathway.png"; })
//                 //     .attr("x", -8)
//                 //     .attr("y", -8)
//                 //     .attr("width", 16)
//                 //     .attr("height", 16);
//
//
//                 var labels = gnodes.append("text")
//
//                     .attr("dx", function (d) {
//                         return textPlacePlusMinus(d.group);
//                     })
//                     .attr("dy", 4)
//                     .attr("text-anchor", function (d) {
//                         return textPlaceStartEnd(d.group);
//                     })
//                     .text(function (d) {
//                         return d.full_name
//                     })
//
//             });
//
//             d3.select('#customizedParallelView1').on('click', function () {
//                 svg.remove();
//
//
//                 var margin = {top: 75, right: 75, bottom: 75, left: 75}, cus
//                 width = 1550 - margin.left - margin.right,
//                     height = 1550 - margin.top - margin.bottom;
//
//                 var x = d3.scale.ordinal().rangePoints([0, width], 1),
//                     y = {},
//                     dragging = {};
//
//                 var line = d3.svg.line(),
//                     axis = d3.svg.axis().orient("left"),
//                     background,
//                     foreground;
//
//
//                 svg = d3.select("#chart").append("svg")
//                     .attr("width", width + margin.left + margin.right)
//                     .attr("style", "outline: thin solid yellow;")
//                     .attr("height", height + margin.top + margin.bottom)
//                     .append("g")
//                     .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
//
//                 var margin = 75,
//                     w = 1550 - 2 * margin,
//                     h = w,
//                     radius = w / 2,
//                     strokeWidth = 4,
//                     hyp2 = Math.pow(radius, 2),
//                     nodeBaseRad = 5;
//
//                 var data = parallelLayout;
//
//
//                 x.domain(dimensions = d3.keys(data[0]).filter(function (d) {
//
//                     if (d === "name") return false;
//
//                     else {
//                         y[d] = d3.scale.ordinal()
//                             .domain(data.map(function (p) {
//                                 return p[d];
//                             }))
//                             .rangePoints([height, 0]);
//
//                     }
//                     //else {
//                     //    y[d] = d3.scale.linear()
//                     //      .domain(d3.extent(data, function(p) { return +p[d]; }))
//                     //      .range([h, 0]);
//                     //}
//
//                     return true;
//                 }));
//
//                 background = svg.append("g")
//                     .style("fill", "none")
//                     .style("stroke", "#ddd")
//                     .style("shape-rendering", "crispEdges")
//
//                     .selectAll("path")
//                     .data(data)
//                     .enter().append("path")
//                     .attr("d", path);
//
//                 // Add blue foreground lines for focus.
//                 foreground = svg.append("g")
//                     .style("fill", "none")
//                     .style("stroke", "steelblue")
//                     //.style("shape-rendering", "crispEdges")
//                     .selectAll("path")
//                     .data(data)
//                     .enter().append("path")
//                     .attr("d", path);
//
// // Add a group element for each dimension.
//                 var g = svg.selectAll(".dimension")
//                     .data(dimensions)
//                     .enter().append("g")
//                     .attr("class", "dimension")
//                     .attr("transform", function (d) {
//                         return "translate(" + x(d) + ")";
//                     })
//                     .call(d3.behavior.drag()
//                         .origin(function (d) {
//                             return {x: x(d)};
//                         })
//                         .on("dragstart", function (d) {
//                             dragging[d] = x(d);
//                             background.attr("visibility", "hidden");
//                         })
//                         .on("drag", function (d) {
//                             dragging[d] = Math.min(width, Math.max(0, d3.event.x));
//                             foreground.attr("d", path);
//                             dimensions.sort(function (a, b) {
//                                 return position(a) - position(b);
//                             });
//                             x.domain(dimensions);
//                             g.attr("transform", function (d) {
//                                 return "translate(" + position(d) + ")";
//                             })
//                         })
//                         .on("dragend", function (d) {
//                             delete dragging[d];
//                             transition(d3.select(this)).attr("transform", "translate(" + x(d) + ")");
//                             transition(foreground).attr("d", path);
//                             background
//                                 .attr("d", path)
//                                 .transition()
//                                 .delay(500)
//                                 .duration(0)
//                                 .attr("visibility", null);
//                         }));
//
//                 // Add an axis and title.
//                 g.append("g")
//                     .style("fill", "none")
//                     .style("stroke", "black")
//                     //.style("stroke-width","#000")
//                     //.style("fill", "none")
//                     .style("stroke-width", "1")
//                     .style("shape-rendering", "crispEdges")
//                     //.style("shape-rendering","crispEdges")
//                     // fill: none;
//                     // stroke: #000;
//                     // shape-rendering: crispEdges;
//                     //.attr("class", "axis")
//                     .each(function (d) {
//                         d3.select(this).call(axis.scale(y[d]));
//                     })
//                     .append("text")
//                     .style("font", "13px Times New Roman")
//                     .style("text-anchor", "middle")
//                     .attr("y", -9)
//                     .text(function (d) {
//                         return d;
//                     });
//
//                 // Add and store a brush for each axis.
//                 g.append("g")
//
//                 // fill-opacity: .3;
//                 // stroke: #fff;
//                 // shape-rendering: crispEdges;
//                 //.attr("class", "brush")
//                     .each(function (d) {
//                         d3.select(this).call(y[d].brush = d3.svg.brush().y(y[d]).on("brushstart", brushstart).on("brush", brush));
//                     })
//                     .selectAll("rect")
//                     .attr("x", -8)
//                     .style("fill-opacity", ".3")
//                     .style("stroke", "#fff")
//                     .style("shape-rendering", "crispEdges")
//                     .attr("width", 16);
//
// //Added from here========================================
//
//
//                 var projection = svg.selectAll(".foreground path")
//                     .on("mouseover", mouseover)
//                     .on("mouseout", mouseout);
//
//                 function mouseover(d) {
//                     //svg.classed("active", false);
//                     projection.classed("inactive", function (p) {
//                         return p !== d;
//                     });
//                     projection.classed("active", function (p) {
//                         return p === d;
//                     });
//                     //projection.filter(function(p) { return p === d; }).each(moveToFront);
//                 }
//
//                 function mouseout(d) {
//
//                     //projection.classed("inactive", function(p) { return p !== d; });
//                     projection.classed("active");
//
//                 }
//
//                 function position(d) {
//                     var v = dragging[d];
//                     return v == null ? x(d) : v;
//                 }
//
//                 function transition(g) {
//                     return g.transition().duration(500);
//                 }
//
//                 function path(d) {
//                     return line(dimensions.map(function (p) {
//                         return [position(p), y[p](d[p])];
//                     }));
//                 }
//
//                 function brushstart() {
//                     d3.event.sourceEvent.stopPropagation();
//                 }
//
// // Handles a brush event, toggling the display of foreground lines.
//                 function brush() {
//                     var actives = dimensions.filter(function (p) {
//                             return !y[p].brush.empty();
//                         }),
//                         extents = actives.map(function (p) {
//                             return y[p].brush.extent();
//                         });
//                     foreground.style("display", function (d) {
//                         return actives.every(function (p, i) {
//
//                             return extents[i][0] <= y[p](d[p]) && y[p](d[p]) <= extents[i][1];
// //This one is for numeric
//                             //return extents[i][0] <= d[p] && d[p] <= extents[i][1];
//                         }) ? null : "none";
//                     });
//                 }
//
//
//             });
//
//             d3.select('#customizedCircularView1').on('click', function () {
//
//                 svg.remove();
//                 var diameter = 1200;
//                 svg = d3.select("#chart").append("svg")
//                     .attr("width", diameter)
//                     .attr("height", diameter)
//                     .attr("style", "outline: thin solid yellow;")
//                     .append("g")
//                     .attr("transform", "translate(" + diameter / 2 + "," + diameter / 2 + ")");
//
//                 var outer = d3.map();
//                 var inner = [];
//                 var links = [];
//                 var outerId = [0];
//                 var data = circularLayout;
//                 //console.log(data);
//                 data.forEach(function (d) {
//
//                     if (d == null)
//                         return;
//
//                     i = {id: 'i' + inner.length, name: d[0], related_links: []};
//                     i.related_nodes = [i.id];
//                     inner.push(i);
//
//                     if (!Array.isArray(d[1]))
//                         d[1] = [d[1]];
//
//                     d[1].forEach(function (d1) {
//
//                         o = outer.get(d1);
//
//                         if (o == null) {
//                             o = {name: d1, id: 'o' + outerId[0], related_links: []};
//                             o.related_nodes = [o.id];
//                             outerId[0] = outerId[0] + 1;
//
//                             outer.set(d1, o);
//                         }
//
//                         // create the links
//                         l = {id: 'l-' + i.id + '-' + o.id, inner: i, outer: o}
//                         links.push(l);
//
//                         // and the relationships
//                         i.related_nodes.push(o.id);
//                         i.related_links.push(l.id);
//                         o.related_nodes.push(i.id);
//                         o.related_links.push(l.id);
//                     });
//                 });
//                 data = {
//                     inner: inner,
//                     outer: outer.values(),
//                     links: links
//                 }
// // sort the data -- TODO: have multiple sort options
//                 outer = data.outer;
//                 data.outer = Array(outer.length);
//                 var i1 = 0;
//                 var i2 = outer.length - 1;
//                 for (var i = 0; i < data.outer.length; ++i) {
//                     if (i % 2 == 1)
//                         data.outer[i2--] = outer[i];
//                     else
//                         data.outer[i1++] = outer[i];
//                 }
//                 //console.log(data.outer.reduce(function (a, b) {
//                         return a + b.related_links.length;
//                     }, 0) / data.outer.length);
// // from d3 colorbrewer:
// // This product includes color specifications and designs developed by Cynthia Brewer (http://colorbrewer.org/).
//                 //var colors = ["#a50026","#d73027","#f46d43","#fdae61","#fee090","#ffffbf","#e0f3f8","#abd9e9","#74add1","#4575b4","#313695"]
//                 // var color = d3.scale.linear()
//                 //     .domain([60, 220])
//                 //     .range([colors.length-1, 0])
//                 //     .clamp(true);
//
//
//                 var rect_width = 100;
//                 var rect_height = 20;
//                 var link_width = "1px";
//                 var il = data.inner.length;
//                 var ol = data.outer.length;
//                 var inner_y = d3.scale.linear()
//                     .domain([0, il])
//                     .range([-(il * rect_height) / 2, (il * rect_height) / 2]);
//                 mid = (data.outer.length / 2.0)
//                 var outer_x = d3.scale.linear()
//                     .domain([0, mid, mid, data.outer.length])
//                     .range([15, 170, 190, 355]);
//                 var outer_y = d3.scale.linear()
//                     .domain([0, data.outer.length])
//                     .range([0, diameter / 2 - 150]);
// // setup positioning
//                 data.outer = data.outer.map(function (d, i) {
//                     d.x = outer_x(i);
//                     d.y = diameter / 3;
//                     return d;
//                 });
//                 data.inner = data.inner.map(function (d, i) {
//                     d.x = -(rect_width / 2);
//                     d.y = inner_y(i);
//                     return d;
//                 });
//                 function get_color(name) {
//                     // var c = Math.round(color(name));
//                     // if (isNaN(c))
//                     //     return '#dddddd';	// fallback color
//                     //
//                     // return colors[c];
//
//
//                     return '#a39c9c';
//                 }
//
// // Can't just use d3.svg.diagonal because one edge is in normal space, the
// // other edge is in radial space. Since we can't just ask d3 to do projection
// // of a single point, do it ourselves the same way d3 would do it.
//                 function projectX(x) {
//                     return ((x - 90) / 180 * Math.PI) - (Math.PI / 2);
//                 }
//
//                 var diagonal = d3.svg.diagonal()
//                     .source(function (d) {
//                         return {
//                             "x": d.outer.y * Math.cos(projectX(d.outer.x)),
//                             "y": -d.outer.y * Math.sin(projectX(d.outer.x))
//                         };
//                     })
//                     .target(function (d) {
//                         return {
//                             "x": d.inner.y + rect_height / 2,
//                             "y": d.outer.x > 180 ? d.inner.x : d.inner.x + rect_width
//                         };
//                     })
//                     .projection(function (d) {
//                         return [d.y, d.x];
//                     });
//
//                 // svg = d3.select("#chart")
//                 //     .append("svg")
//                 //     .attr("style", "outline: thin solid yellow;")
//                 //     .attr("width", w)
//                 //     .attr("height", h);
//
//
// // links
//                 var link = svg.append('g')
//                 //.attr('class', 'links')
//                     .selectAll(".link")
//                     .data(data.links)
//                     .enter().append('path')
//                     .style('fill', 'none')
//                     .attr('id', function (d) {
//                         return d.id
//                     })
//                     .attr("d", diagonal)
//                     .attr('stroke', function (d) {
//                         return get_color(d.inner.name);
//                     })
//                     .attr('stroke-width', link_width);
// // outer nodes
//                 var onode = svg.append('g').selectAll(".outer_node")
//                     .data(data.outer)
//                     .enter().append("g")
//                     .style("stroke", "#315B7E")
//                     .style("stroke-width", "2px")
//
//                     // .attr("class", "outer_node")
//                     .attr("transform", function (d) {
//                         return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")";
//                     })
//                     .on("mouseover", mouseover)
//                     .on("mouseout", mouseout);
//
//                 onode.append("circle")
//                     .attr('id', function (d) {
//                         return d.id
//                     })
//                     .attr("r", 4.5);
//
//                 onode.append("circle")
//                     .attr('r', 20)
//                     .attr('visibility', 'hidden');
//
//                 onode.append("text")
//                     .attr('id', function (d) {
//                         return d.id + '-txt';
//                     })
//                     .attr("dy", ".31em")
//                     .style("stroke", "black")
//                     .style("font-weight", "normal")
//                     .style("font", "13px Times New Roman")
//                     .attr("text-anchor", function (d) {
//                         return d.x < 180 ? "start" : "end";
//                     })
//                     .attr("transform", function (d) {
//                         return d.x < 180 ? "translate(8)" : "rotate(180)translate(-8)";
//                     })
//                     .text(function (d) {
//                         return d.name;
//                     });
//
// // inner nodes
//
//                 var inode = svg.append('g').selectAll(".inner_node")
//                     .data(data.inner)
//                     .enter().append("g")
//                     .style("stroke", "#315B7E")
//                     .style("stroke-width", "2px")
//
//                     //.attr("class", "inner_node")
//                     .attr("transform", function (d, i) {
//                         return "translate(" + d.x + "," + d.y + ")"
//                     })
//                     .on("mouseover", mouseover)
//                     .on("mouseout", mouseout);
//
//                 inode.append('rect')
//                     .attr('width', rect_width)
//                     .attr('height', rect_height)
//                     .attr('id', function (d) {
//                         return d.id;
//                     })
//                     .attr('fill', function (d) {
//                         return get_color(d.name);
//                     });
//
//                 inode.append("text")
//                     .attr('id', function (d) {
//                         return d.id + '-txt';
//                     })
//                     .attr('text-anchor', 'middle')
//                     .style("stroke", "#315B7E")
//                     .style("font-weight", "normal")
//                     .style("font", "13px Times New Roman")
//                     .attr("transform", "translate(" + rect_width / 2 + ", " + rect_height * .75 + ")")
//                     .text(function (d) {
//                         return d.name;
//                     });
// // need to specify x/y/etc
//                 d3.select(self.frameElement).style("height", diameter - 150 + "px");
//                 function mouseover(d) {
//                     // bring to front
//                     d3.selectAll('.links .link').sort(function (a, b) {
//                         return d.related_links.indexOf(a.id);
//                     });
//
//                     for (var i = 0; i < d.related_nodes.length; i++) {
//                         d3.select('#' + d.related_nodes[i]).classed('highlight', true);
//                         d3.select('#' + d.related_nodes[i] + '-txt').attr("font-weight", 'bold');
//                     }
//
//                     for (var i = 0; i < d.related_links.length; i++)
//                         d3.select('#' + d.related_links[i]).attr('stroke-width', '5px');
//                 }
//
//                 function mouseout(d) {
//                     for (var i = 0; i < d.related_nodes.length; i++) {
//                         d3.select('#' + d.related_nodes[i]).classed('highlight', false);
//                         d3.select('#' + d.related_nodes[i] + '-txt').attr("font-weight", 'normal');
//                     }
//
//                     for (var i = 0; i < d.related_links.length; i++)
//                         d3.select('#' + d.related_links[i]).attr('stroke-width', link_width);
//                 }
//
//             });
                // Set-up the export button
                d3.select('#download-png1').on('click', function () {
                    var svgString = getSVGString(svg.node());

                    svgString2Image(svgString, 4 * globalW, 4 * globalHPlus50, 'png', save); // passes Blob and filesize String to the callback

                    function save(dataBlob, filesize) {
                        saveAs(dataBlob, 'Pinet-Gene-Pathway-Association-Network.png'); // FileSaver.js function
                    }
                });
                d3.select('#saveButton').on('click', function () {
                    var svgString = getSVGString(svg.node());

                    svgString2Image(svgString, 4 * 1550, 4 * 1550, 'png', save); // passes Blob and filesize String to the callback

                    function save(dataBlob, filesize) {
                        saveAs(dataBlob, 'PiNET-grapg.png'); // FileSaver.js function
                    }
                });

// Below are the functions that handle actual exporting:
// getSVGString ( svgNode ) and svgString2Image( svgString, width, height, format, callback )
                function getSVGString(svgNode) {
                    svgNode.setAttribute('xlink', 'http://www.w3.org/1999/xlink');
                    var cssStyleText = getCSSStyles(svgNode);
                    appendCSS(cssStyleText, svgNode);

                    var serializer = new XMLSerializer();
                    var svgString = serializer.serializeToString(svgNode);
                    svgString = svgString.replace(/(\w+)?:?xlink=/g, 'xmlns:xlink='); // Fix root xlink without namespace
                    svgString = svgString.replace(/NS\d+:href/g, 'xlink:href'); // Safari NS namespace fix

                    return svgString;

                    function getCSSStyles(parentElement) {
                        var selectorTextArr = [];

                        // Add Parent element Id and Classes to the list
                        selectorTextArr.push('#' + parentElement.id);
                        for (var c = 0; c < parentElement.classList.length; c++)
                            if (!contains('.' + parentElement.classList[c], selectorTextArr))
                                selectorTextArr.push('.' + parentElement.classList[c]);

                        // Add Children element Ids and Classes to the list
                        var nodes = parentElement.getElementsByTagName("*");
                        for (var i = 0; i < nodes.length; i++) {
                            var id = nodes[i].id;
                            if (!contains('#' + id, selectorTextArr))
                                selectorTextArr.push('#' + id);

                            var classes = nodes[i].classList;
                            for (var c = 0; c < classes.length; c++)
                                if (!contains('.' + classes[c], selectorTextArr))
                                    selectorTextArr.push('.' + classes[c]);
                        }

                        // Extract CSS Rules
                        var extractedCSSText = "";
                        for (var i = 0; i < document.styleSheets.length; i++) {
                            var s = document.styleSheets[i];

                            try {
                                if (!s.cssRules) continue;
                            } catch (e) {
                                if (e.name !== 'SecurityError') throw e; // for Firefox
                                continue;
                            }

                            var cssRules = s.cssRules;
                            for (var r = 0; r < cssRules.length; r++) {
                                if (contains(cssRules[r].selectorText, selectorTextArr))
                                    extractedCSSText += cssRules[r].cssText;
                            }
                        }


                        return extractedCSSText;

                        function contains(str, arr) {
                            return arr.indexOf(str) === -1 ? false : true;
                        }

                    }

                    function appendCSS(cssText, element) {
                        var styleElement = document.createElement("style");
                        styleElement.setAttribute("type", "text/css");
                        styleElement.innerHTML = cssText;
                        var refNode = element.hasChildNodes() ? element.children[0] : null;
                        element.insertBefore(styleElement, refNode);
                    }
                }


                function svgString2Image(svgString, width, height, format, callback) {
                    var format = format ? format : 'png';

                    var imgsrc = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgString))); // Convert SVG string to data URL

                    var canvas = document.createElement("canvas");
                    var context = canvas.getContext("2d");

                    canvas.width = width;
                    canvas.height = height;

                    var image = new Image();
                    image.onload = function () {
                        context.clearRect(0, 0, width, height);
                        context.drawImage(image, 0, 0, width, height);

                        canvas.toBlob(function (blob) {
                            var filesize = Math.round(blob.length / 1024) + ' KB';
                            if (callback) callback(blob, filesize);
                        });


                    };

                    image.src = imgsrc;
                }


                // d3.select("#download").on("click", function(){
                //     var html = d3.select("svg")
                //         .attr("version", 1.1)
                //         .attr("xmlns", "http://www.w3.org/2000/svg")
                //         .node().parentNode.innerHTML;
                //
                //     ////console.log(html);
                //     var imgsrc = 'data:image/svg+xml;base64,'+ btoa(html);
                //     var img = '<img src="'+imgsrc+'">';
                //     d3.select("#svgdataurl").html(img);
                //
                //
                //     var canvas = document.querySelector("canvas"),
                //         context = canvas.getContext("2d");
                //
                //     var image = new Image;
                //     image.src = imgsrc;
                //     image.onload = function() {
                //         context.drawImage(image, 0, 0);
                //
                //         var canvasdata = canvas.toDataURL("image/png");
                //
                //         var pngimg = '<img src="'+canvasdata+'">';
                //         d3.select("#pngdataurl").html(pngimg);
                //
                //         var a = document.createElement("a");
                //         a.download = "sample.png";
                //         a.href = canvasdata;
                //         a.click();
                //     };
                //
                // });


            }

            $scope.pathways = [
                {value: "KEGG_2015"},
                {value: "WikiPathways_2015"},
                {value: "Panther_2015"},
                {value: "KEGG_2016"},
                {value: "WikiPathways_2016"},

                // {value: "ARCHS4_Kinases_Coexp"},
                // {value: "Reactome_2016"},
                // {value: "BioCarta_2016"},
                // {value: "Humancyc_2016"},
                // {value: "NCI-Nature_2016"},
                {value: "Panther_2016"},
                // {value: "BioPlex_2017"},
                //
                // {value: "huMAP"},
                // {value: "PPI_Hub_Proteins"},
                // {value: "KEA_2015"},
                // {value: "LINCS_L1000_Kinase_Perturbations_down"},
                // {value: "LINCS_L1000_Kinase_Perturbations_up"},
                {value: "Kinase_Perturbations_from_GEO"},
                {value: "Kinase_Perturbations_from_GEO_down"},
                {value: "Kinase_Perturbations_from_GEO_up"}
                // {value: "NURSA_Human_Endogenous_Complexome"},
                // {value: "CORUM"},
                //
                // {value: "SILAC_Phosphoproteomics"},
                // {value: "Phosphatase_Substrates_from_DEPOD"}
            ];
            $scope.selectedPathways = $scope.pathways[0];

            $scope.pathways = [

                {value: "KEGG_2016"},
                {value: "WikiPathways_2016"},
                {value: "ARCHS4_Kinases_Coexp"},
                {value: "Reactome_2016"},
                {value: "BioCarta_2016"},
                {value: "Humancyc_2016"},
                {value: "NCI-Nature_2016"},
                {value: "Panther_2016"},
                {value: "BioPlex_2017"},

                {value: "huMAP"},
                {value: "PPI_Hub_Proteins"},
                {value: "KEA_2015"},
                {value: "LINCS_L1000_Kinase_Perturbations_down"},
                {value: "LINCS_L1000_Kinase_Perturbations_up"},
                {value: "Kinase_Perturbations_from_GEO_down"},
                {value: "Kinase_Perturbations_from_GEO_up"},
                {value: "NURSA_Human_Endogenous_Complexome"},
                {value: "CORUM"},

                {value: "SILAC_Phosphoproteomics"},
                {value: "Phosphatase_Substrates_from_DEPOD"}
            ];
            $scope.selectedPathways = $scope.pathways[0];


            $scope.diseaseDrugs = [
                {value: "LINCS_L1000_Chem_Pert_up"},
                {value: "LINCS_L1000_Chem_Pert_down"},
                {value: "LINCS_L1000_Ligand_Perturbations_up"},

                {value: "LINCS_L1000_Ligand_Perturbations_down"},
                {value: "ARCHS4_IDG_Coexp"},
                {value: "DrugMatrix"},

                {value: "Old_CMAP_up"},
                {value: "Old_CMAP_down"},
                {value: "GeneSigDB"},

                {value: "OMIM_Disease"},
                {value: "OMIM_Expanded"},
                {value: "VirusMINT"},

                {value: "MSigDB_Computational"},
                {value: "MSigDB_Oncogenic_Signatures"},
                {value: "Virus_Perturbations_from_GEO_up"},

                {value: "Virus_Perturbations_from_GEO_down"},
                {value: "Achilles_fitness_increase"},
                {value: "Achilles_fitness_decrease"},
                {value: "dbGaP"}
            ];

            $scope.selectedDiseaseDrugs = $scope.diseaseDrugs[0];


            $scope.ontology = [
                {value: "GO_Cellular_Component_2017b"},
                {value: "GO_Biological_Process_2017b"},
                {value: "GO_Molecular_Function_2017b"},

                {value: "MGI_Mammalian_Phenotype_2017"},
                {value: "Human_Phenotype_Ontology"},
                {value: "Jensen_TISSUES"},

                {value: "Jensen_COMPARTMENTS"},
                {value: "Jensen_DISEASES"}
            ];

            $scope.selectedOntology = $scope.ontology[0];


            $scope.transcription = [
                {value: "ChEA_2016"},
                {value: "TRANSFAC_and_JASPAR_PWMs"},
                {value: "ARCHS4_TFs_Coexp"},

                {value: "Genome_Browser_PWMs"},
                {value: "ENCODE_and_ChEA_Consensus_TFs_from_ChIP-X"},
                {value: "Epigenomics_Roadmap_HM_ChIP-seq"},

                {value: "TargetScan_microRNA"},
                {value: "ENCODE_TF_ChIP-seq_2015"},
                {value: "TF-LOF_Expression_from_GEO"},

                {value: "ENCODE_Histone_Modifications_2015"},
                {value: "Transcription_Factor_PPIs"}

            ];

            $scope.selectedTranscription = $scope.transcription[0];


            $scope.cellType = [
                {value: "Human_Gene_Atlas"},
                {value: "Mouse_Gene_Atlas"},
                {value: "ARCHS4_Tissues"},

                {value: "ARCHS4_Cell-lines"},
                {value: "Allen_Brain_Atlas_up"},
                {value: "Allen_Brain_Atlas_down"},

                {value: "GTEx_Tissue_Sample_Gene_Expression_Profiles_up"},
                {value: "GTEx_Tissue_Sample_Gene_Expression_Profiles_down"},
                {value: "Cancer_Cell_Line_Encyclopedia"},

                {value: "NCI-60_Cancer_Cell_Lines"},
                {value: "Tissue_Protein_Expression_from_ProteomicsDB"},
                {value: "Tissue_Protein_Expression_from_Human_Proteome_Map"},
                {value: "ESCAPE"}

            ];

            $scope.selectedCellType = $scope.cellType[0];


            var network = inputNetwork.KEGG_2016;
            // //console.log(network.parallel);
            // //console.log(network.circular);
            // update(network.nodes, network.edges, network.parallel, network.circular);
            if (self.computeWeightForUpdate) {
            for (var iterNetNode = 0; iterNetNode < network.nodes.length; iterNetNode++)
            {
                var iterNetNodeKey = network.nodes[iterNetNode]["name"]
                if (iterNetNodeKey in geneToAbundance)
                {
                    if (geneToAbundance[iterNetNodeKey] == "NA")
                    {
                        network.nodes[iterNetNode]["value"] = 0.0;
                    }
                    else {
                        network.nodes[iterNetNode]["value"] = geneToAbundance[iterNetNodeKey];
                    }
                }
            }

                for (var iterNetNode = 0; iterNetNode < network.edges.length; iterNetNode++) {
                    //var iterNetNodeKey = network.nodes[iterNetNode]["name"];
                    var idx1 = network.edges[iterNetNode]["source"];
                    var idx2 = network.edges[iterNetNode]["target"];
                    network.nodes[idx1]["weight"] += 1;
                    network.nodes[idx2]["weight"] += 1;

                }
                self.computeWeightForUpdate = false;
                SharedService.setVar('computeWeightForUpdate',self.computeWeightForUpdate);
            }
            update(network.nodes, network.edges, graphType, circleSliderValue, nodeSliderValue, fontSliderValue, widthSliderValue);
            $scope.pathwayItem = 'KEGG_2016';
            $scope.changedValue = function (item) {
                //var net = item.value;

                //console.log(item);
                //console.log(item.value);
                var net = item.value.toString();
                $scope.pathwayItem = net;
                //console.log(net);

                var network = inputNetwork[net];
                //console.log('network');
                //console.log(network);
                for (var iterNetNode = 0; iterNetNode < network.nodes.length; iterNetNode++)
                {
                    var iterNetNodeKey = network.nodes[iterNetNode]["name"]
                    if (iterNetNodeKey in geneToAbundance)
                    {
                        if (geneToAbundance[iterNetNodeKey] == "NA")
                        {
                            network.nodes[iterNetNode]["value"] = 0.0;
                        }
                        else {
                            network.nodes[iterNetNode]["value"] = geneToAbundance[iterNetNodeKey];
                        }
                    }
                }
                if (self.computeWeightForUpdate) {
                    for (var iterNetNode = 0; iterNetNode < network.edges.length; iterNetNode++)
                    {
                        //var iterNetNodeKey = network.nodes[iterNetNode]["name"];
                        var idx1 = network.edges[iterNetNode]["source"];
                        var idx2 = network.edges[iterNetNode]["target"];
                        network.nodes[idx1]["weight"] += 1;
                        network.nodes[idx2]["weight"] += 1;

                    }
                    self.computeWeightForUpdate = false;
                    SharedService.setVar('computeWeightForUpdate',self.computeWeightForUpdate);
                }
                // //console.log(network.parallel);
                // //console.log(network.circular);
                // update(network.nodes, network.edges, network.parallel, network.circular);
                update(network.nodes, network.edges, graphType, circleSliderValue, nodeSliderValue, fontSliderValue, widthSliderValue);
                //$scope.itemList.push(item.value);
            }
            self.showPathwayGraph = true;
        }

    }




    $scope.graphType4kinase = 2;
    $scope.circleSliderValue4kinase = 1100;
    $scope.nodeSliderValue4kinase = 15;
    $scope.fontSliderValue4kinase = 14;
    $scope.widthSliderValue4kinase = 1500;
    $(document).on('input', '#circle_slider4kinase', function() {
        $('#circle_slider_value4kinase').html( $(this).val() );
        ////console.log($(this).val());
        $scope.circleSliderValue4kinase = $(this).val();

        $scope.$apply();

        $scope.makeKinaseGraph(self.kinaseNetwork, self.geneToAbundanceMap, $scope.graphType4kinase, $scope.circleSliderValue4kinase, $scope.nodeSliderValue4kinase, $scope.fontSliderValue4kinase, $scope.widthSliderValue4kinase);

    });

    $(document).on('input', '#node_slider4kinase', function() {
        $('#node_slider_value4kinase').html( $(this).val() );
        ////console.log($(this).val());
        $scope.nodeSliderValue4kinase = $(this).val();

        $scope.$apply();

        $scope.makeKinaseGraph(self.kinaseNetwork, self.geneToAbundanceMap, $scope.graphType4kinase, $scope.circleSliderValue4kinase, $scope.nodeSliderValue4kinase, $scope.fontSliderValue4kinase, $scope.widthSliderValue4kinase);

    });

    $(document).on('input', '#font_slider4kinase', function() {
        $('#font_slider_value4kinase').html( $(this).val() );
        ////console.log($(this).val());
        $scope.fontSliderValue4kinase = $(this).val();

        $scope.$apply();

        $scope.makeKinaseGraph(self.kinaseNetwork, self.geneToAbundanceMap, $scope.graphType4kinase, $scope.circleSliderValue4kinase, $scope.nodeSliderValue4kinase, $scope.fontSliderValue4kinase, $scope.widthSliderValue4kinase);

    });

    $(document).on('input', '#width_slider4kinase', function() {
        $('#width_slider_value4kinase').html( $(this).val() );
        ////console.log($(this).val());
        $scope.widthSliderValue4kinase = $(this).val();

        $scope.$apply();

        $scope.makeKinaseGraph(self.kinaseNetwork, self.geneToAbundanceMap, $scope.graphType4kinase, $scope.circleSliderValue4kinase, $scope.nodeSliderValue4kinase, $scope.fontSliderValue4kinase, $scope.widthSliderValue4kinase);

    });





    $scope.hideKinaseGraph = function () {
        self.showKinaseGraphTmp = true;
        self.showKinaseGraph = false;
    }

        //     <svg width="200" viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg">
        //     <defs>
        //     <marker id="triangle" viewBox="-1 -10 2 20"
        // refX="0" refY="0"
        // markerUnits="strokeWidth"
        // markerWidth="10" markerHeight="10"
        // orient="auto">
        //     <path d="M 0,0 m -1,-10 L 1,-10 L 1,10 L -1,10 Z" fill="#f00"/>
        //     </marker>
        //     </defs>
        //     <polyline fill="none" stroke="black"
        // points="70,80 100,60" marker-end="url(#triangle)"/>
        // </svg>
    $scope.makeKinaseGraph = function (inputNetwork, geneToAbundance, graphType, circleSliderValue, nodeSliderValue, fontSliderValue, widthSliderValue) {

        if(self.showKinaseGraphTmp){
            self.showKinaseGraphTmp = false;
            self.showKinaseGraph = true;
        }
        else {
            console.log("in makeKinaseGraph");
            self.showKinaseGraphTmp = true;
            self.showKinaseGraph = false;
            //console.log("in makeKinaseGraph");
            //console.log(inputNetwork);
            d3.select("#chart2").select("svg").remove();
            if (typeof svg2 === 'undefined') {
                var svg2 = d3.selectAll("#chart2").append("svg");
            }

            var force;
            var colNodeScaleSeparate = d3.scale.ordinal()
                .range(["#987024", "#ed0909", "#0af702"])
                //.range(["#987024", "#982482", "#0af702"])
                .domain([0, 1, 2]);
//#f9a3f5
            // var colNodeScaleSeparate = d3.scale.ordinal()
            //     .range(["#767776", "#f91104", "#0af702"])
            //     .domain([0,1,2]);

            var colNodeScale = d3.scale.linear().range(["#987024", "#ed0909"]);
            var colScale = d3.scale.linear().range(["#987024", "#ed0909"]);
            var edgeWeightScale = d3.scale.linear().range([1, 3]);
            var xScale = d3.scale.linear().range([nodeSliderValue/3.0, nodeSliderValue]);
            //var xScale = d3.scale.linear().range([5, 15]);
            var textPlacePlusMinus = d3.scale.ordinal()
                .range([18, -18])
                .domain([1, 2]);
            var textPlaceStartEnd = d3.scale.ordinal().range(["start", "end"])
                .domain([1, 2]);

            var colorsForAbundance = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
            var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];
            var colorScale = d3.scale.threshold()
                .domain(domain_data)
                .range(colorsForAbundance);

            function updateKinase(nodes, links, graphType, circleValue, nodeValue, fontValue, widthValue) {
                //
                //var svg;
                circleValue = Math.min(circleValue, widthValue - 300);

                // $('force1').click();
                //document.getElementById('force1').click();

                // //console.log(circularLayout);
                function defaultView2() {


                    svg2.remove();

                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    colNodeScaleSeparate.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));
                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = w,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;

                    //These variables are global variables
                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;


                    svg2 = d3.select("#chart2")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);
                    svg2.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");

                    var arrow_data = [
                        { id: 0, name: 'circle', path: 'M 0, 0  m -5, 0  a 5,5 0 1,0 10,0  a 5,5 0 1,0 -10,0', viewbox: '-6 -6 12 12' }
                        , { id: 1, name: 'square', path: 'M 0,0 m -5,-5 L 5,-5 L 5,5 L -5,5 Z', viewbox: '-5 -5 10 10' }
                        , { id: 2, name: 'arrow', path: 'M 0,0 m -5,-5 L 5,0 L -5,5 Z', viewbox: '-5 -5 10 10' }
                        , { id: 2, name: 'stub', path: 'M 0,0 m -1,-10 L 1,-10 L 1,10 L -1,10 Z', viewbox: '-1 -10 2 20' }
                        // , { id: 2, name: 'stub', path: 'M 0,0 m -1,-5 L 1,-5 L 1,5 L -1,5 Z', viewbox: '-1 -5 2 10' }
                    ];

                    // var marker = defs.selectAll('marker')
                    //     .data(arrow_data)
                    //     .enter()
                    //     .append('svg:marker')
                    //     .attr('id', function(d){ return 'marker_' + d.name})
                    //     .attr('markerHeight', 5)
                    //     .attr('markerWidth', 5)
                    //     .attr('markerUnits', 'strokeWidth')
                    //     .attr('orient', 'auto')
                    //     .attr('refX', 0)
                    //     .attr('refY', 0)
                    //     .attr('viewBox', function(d){ return d.viewbox })
                    //     .append('svg:path')
                    //     .attr('d', function(d){ return d.path })
                    //     .attr('fill', "#f00");

                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h])
                        .linkDistance(150)
                        .charge(-500)
                        //.linkStrength(0.9)
                        //.friction(0.9)
                        //.chargeDistance(300)
                        .gravity(0.25)
                        //.theta(0.8)
                        //.alpha(0.1)
                        .on("tick", tick)
                        .start();

                    // for (var i = n*n; i > 0; --i) force.tick();
                    // force.stop();

                    //.stop();
                    svg2.append('defs').append('marker')
                        .attr({
                            'id': 'arrowhead',
                            'viewBox': '-0 -5 10 10',
                            'refX': 25,
                            'refY': 0,
                            //'markerUnits':'strokeWidth',
                            'orient': 'auto',
                            'markerWidth': 5,
                            'markerHeight': 6,
                            'xoverflow': 'visible'
                        })
                        .append('svg:path')
                        .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
                        .attr('fill', 'black')
                        .attr('stroke', '#ccc');

                    svg2.append('defs').append('marker')
                        .attr({
                            'id': 'block',
                            'viewBox': '-0 -10 20 20',
                            'refX': 25,
                            'refY': 0,
                            //'markerUnits':'strokeWidth',
                            'orient': 'auto',
                            'markerWidth': 15,
                            'markerHeight': 10,
                            'xoverflow': 'visible'
                        })
                        .append('svg:path')
                        .attr('d', 'M 0,0 m -1,-10 L 1,-10 L 1,10 L -1,10 Z')
                        .attr('fill', 'red')
                        .attr('stroke', '#f00');


                    var path = svg2.append("svg:g").selectAll("path")
                    //.data(links)
                        .data(force.links())
                        .enter().append("svg:path")
                        .style("fill", "none")
                        .style("stroke", "black")
                        .style("stroke", function (d) {
                            return colScale(d.value);
                        })
                        //.attr("marker-end", function(d) { return "url(#" + d.type + ")"; })
                        .attr("class", function (d) {
                            return "link ";
                        })
                        //.attr('marker-end', function(d,i){ return 'url(#marker_stub)' });
                       .attr('marker-end', 'url(#arrowhead)');
                    //.attr("marker-end", "url(#arrow)");


                    // var path = svg2.append("svg:g").selectAll("path")
                    // //.data(links)
                    //     .data(force.links())
                    //     .enter().append("svg:path")
                    //     .style("stroke-width", 1)
                    //     .style('stroke', "black")
                    //     //.style("stroke", function (d) {return colScale(d.value); })
                    //     .attr("class", function (d) {
                    //         return "link ";
                    //     });


                    var node = svg2.append("svg:g").selectAll("g.node")
                        .data(force.nodes())
                        .enter().append("svg:g")
                        // .style("stroke-width", 3)
                        // .style('stroke', "black")
                        //.attr("class", "node")
                        .call(force.drag);

                    // nodes.forEach(function(v) {
                    //     var nd;
                    //     var cx = v.coord[0];
                    //     var cy = v.coord[1];
                    //
                    //     switch (v.group) {
                    //         case 1:
                    //             nd = svg.append("circle");
                    //             break;
                    //         case 2:
                    //             nd = svg.append("rect");
                    //             break;
                    //     }
                    // });

                    node.append("circle")
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })

                        .style("fill", function (d) {
                            if (d.group == 0) {
                                return colorScale(d.value);
                            }
                            else {

                                return colNodeScaleSeparate(d.group);
                            }
                        })
                        .style("stroke", "#333")
                        .style("stroke-width", "2px");
                    //.on("dblclick", dblclick);


                    function openLink() {
                        return function (d) {
                            var url = "";
                            if (d.slug != "") {
                                url = d.slug
                            } //else if(d.type == 2) {
                            //url = "clients/" + d.slug
                            //} else if(d.type == 3) {
                            //url = "agencies/" + d.slug
                            //}
                            window.open("//" + url)
                        }
                    };
                    node.append("svg:image")
                    //****************************************
                    //.attr("class", function(d){ return d.name })
                    //****************************************
                    //.attr("xlink:href", function(d){ return d.img_hrefD})
                        .attr("x", "-36px")
                        .attr("y", "-36px")
                        .attr("width", "70px")
                        .attr("height", "70px")
                    //.on("dblclick", openLink());

                    // .on("mouseover", function (d) { if(d.entity == "company")
                    // {
                    //     d3.select(this).attr("width", "90px")
                    //         .attr("x", "-46px")
                    //         .attr("y", "-36.5px")
                    //         .attr("xlink:href", function(d){ return d.img_hrefL});
                    // }
                    // })
                    // .on("mouseout", function (d) { if(d.entity == "company")
                    // {
                    //     d3.select(this).attr("width", "70px")
                    //         .attr("x", "-36px")
                    //         .attr("y", "-36px")
                    //         .attr("xlink:href", function(d){ return d.img_hrefD});
                    // }
                    // });


                    //.text(function(d) { return d.name })
                    node.append("svg:text")
                    //****************************************
                        .attr("class", function (d) {
                            return d.full_name
                        })
                        //****************************************
                        .attr("x", 16)
                        .attr("y", ".31em")
                        //.attr("class", "shadow")
                        //.style("font-size","10px")
                        // .attr("dx", 0)
                        // .attr("dy", ".35em")
                        //.style("font-size","12px")
                        //****************************************
                        //text.shadow {
                        .style("stroke", "#fff")
                        .style("stroke-width", "4px")
                        //}
                        //.attr("class", "shadow")
                        .style("font", String(fontValue) + "px Arial")
                        //.style("font", "14px Times New Roman")
                        //****************************************
                        //.attr("text-anchor", "middle")
                        //****************************************
                        .text(function (d) {
                            return d.full_name
                        });
                    //****************************************


                    //This one is for the actual text
                    node.append("svg:text")
                    //****************************************
                        .attr("class", function (d) {
                            return d.full_name
                        })
                        //****************************************
                        .attr("x", 16)
                        .attr("y", ".31em")
                        //.attr("class", "shadow")
                        //.style("font-size","10px")
                        // .attr("dx", 0)
                        // .attr("dy", ".35em")
                        //.style("font-size","12px")
                        //****************************************
                        .style("font", String(fontValue) + "px Arial")
                        //.style("font", "14px Times New Roman")
                        //****************************************
                        //.attr("text-anchor", "middle")
                        //****************************************
                        .text(function (d) {
                            return d.full_name
                        });
                    //****************************************


                    node.on("mouseover", function (d) {
                        // d3.select(this).select("text")
                        //     .transition()
                        //     .duration(300)
                        //     .text(function (d) {
                        //         return d.full_name;
                        //     })
                        // //.style("font-size", "15px")
                        // .style("font", "14px Times New Roman");
                        //
                        // d3.select(this).select("text")
                        //     .transition()
                        //     .duration(300)
                        //     .text(function (d) {
                        //         return d.full_name;
                        //     })
                        //     //.style("font-size", "15px")
                        //     //.attr("class", "shadow")
                        //     .style("font", "14px Times New Roman");
                        // d3.select(this).select("text")
                        //     .transition()
                        //     .duration(300)
                        //     .text(function (d) {
                        //         return d.full_name;
                        //     })
                        //
                        //     .style("fill",'black')
                        //     .style("font", "14px Times New Roman");

                        //d3.selectAll("text").remove();
                        //d3.select(this).style("stroke-width", 6);

                        //d3.select(this).select("text").style("stroke", "blue");

                        var nodeNeighbors = links.filter(function (link) {
                            // Filter the list of links to only those links that have our target
                            // node as a source or target
                            return link.source.index === d.index || link.target.index === d.index;
                        })
                            .map(function (link) {
                                // Map the list of links to a simple array of the neighboring indices - this is
                                // technically not required but makes the code below simpler because we can use
                                // indexOf instead of iterating and searching ourselves.
                                return link.source.index === d.index ? link.target.index : link.source.index;
                            });

                        d3.selectAll('circle').filter(function (node) {
                            // I filter the selection of all circles to only those that hold a node with an
                            // index in my listg of neighbors
                            return nodeNeighbors.indexOf(node.index) > -1;
                        })
                            .style('stroke', 'blue');

                        //d3.selectAll('text').filter(d).style('fill', 'blue');
                        //****************************
                        // d3.selectAll('text').filter(function(node) {
                        //     // I filter the selection of all circles to only those that hold a node with an
                        //     // index in my listg of neighbors
                        //     return nodeNeighbors.indexOf(node.index) > -1;
                        // }).style('fill', 'blue')
                        //     //.style("font-size", "16px")
                        //     //.style("font-weight", "bold");
                        // //****************************
                        path.style('stroke', function (l) {
                            if (d === l.source || d === l.target)
                                return "blue";
                            else
                                return "grey";
                        })

                        path.style('stroke-width', function (l) {
                            if (d === l.source || d === l.target)
                                return 2;
                            else
                                return 1;
                        })

                    })
                        .on("mouseout", function (d) {
                            d3.select(this).select("text")
                                .transition()
                                .duration(300)
                                .text(function (d) {

                                    return d.full_name;
                                });
                            // d3.select(this).select("text")
                            //     //*******************************
                            //     .style("font", "14px Times New Roman")
                            //     //*******************************
                            //     .style("font-size", "14px")
                            //     .style("fill",'black')
                            //     .style("font-weight", "normal");

                            // d3.select(this).select("text")
                            // //*******************************
                            //     .style("font", "14px Times New Roman")
                            //     //*******************************
                            //     .style("font-size", "14px")
                            //     .style("fill",'black')
                            //     .style("font-weight", "normal");
                            //d3.select(this).style("stroke", "black");
                            //d3.select(this).style("stroke-width", 1);
                            //d3.select(this).style("stroke", "#333");
                            path.style('stroke', "grey");
                            path.style('stroke-width', 1);
                            //circle.style('stroke', "grey");
                            //node.style("stroke-width", 3);
                            //node.style("stroke", "#333");
                            //d3.selectAll('text').style('fill', 'black')
                            // d3.selectAll('text').style('fill', 'black')
                            //     .style("font-weight", "normal");
                            //d3.selectAll("text").style("font-weight", "normal");
                            node.selectAll("circle").style("stroke-width", 3)
                                .style('stroke', "black");
                            //.style("font-size", "12px");
                            //}
                        });


                    function pythag(r, b, coord) {
                        r += nodeBaseRad;

                        // force use of b coord that exists in circle to avoid sqrt(x<0)
                        b = Math.min(w - r - strokeWidth, Math.max(r + strokeWidth, b));

                        var b2 = Math.pow((b - radius), 2),
                            a = Math.sqrt(hyp2 - b2);

                        function openLink() {
                            return function (d) {
                                var url = "";
                                if (d.slug != "") {
                                    url = d.slug
                                } //else if(d.type == 2) {
                                //url = "clients/" + d.slug
                                //} else if(d.type == 3) {
                                //url = "agencies/" + d.slug
                                //}
                                window.open("//" + url)
                            }
                        }

                        // radius - sqrt(hyp^2 - b^2) < coord < sqrt(hyp^2 - b^2) + radius
                        coord = Math.max(radius - a + r + strokeWidth,
                            Math.min(a + radius - r - strokeWidth, coord));

                        return coord;
                    }

                    function tick(e) {
                        path.attr("d", function (d) {
                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,
                                dr = Math.sqrt(dx * dx + dy * dy),
                                drx = dr,
                                dry = dr,
                                xRotation = 0, // degrees
                                largeArc = 0, // 1 or 0
                                sweep = 1, // 1 or 0
                                x2 = d.target.x,
                                y2 = d.target.y;
                            ////console.log(d.source.x);
                            // //console.log(d.target.x);

                            if (d.target.x === d.source.x && d.target.y === d.source.y) {
                                // Fiddle with this angle to get loop oriented.
                                xRotation = -45;

                                // Needs to be 1.
                                largeArc = 1;

                                // Change sweep to change orientation of loop.
                                //sweep = 0;

                                // Make drx and dry different to get an ellipse
                                // instead of a circle.
                                drx = 30;
                                dry = 20;

                                // For whatever reason the arc collapses to a point if the beginning
                                // and ending points of the arc are the same, so kludge it.
                                x2 = d.target.x + 1;
                                y2 = d.target.y + 1;
                            }

                            return "M" + d.source.x + "," + d.source.y + "A" + drx + "," + dry + " " + xRotation + "," + largeArc + "," + sweep + " " + x2 + "," + y2;


                            //return "M" + d.source.x + "," + d.source.y + ","+ d.target.x + "," + d.target.y;
                            //return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
                        });


                        node.attr('x', function (d) {
                            return d.x = pythag(Math.random() * 12, d.y, d.x);
                        })
                            .attr('y', function (d) {
                                return d.y = pythag(Math.random() * 12, d.x, d.y);
                            })
                            .attr("transform", function (d) {
                                return "translate(" + d.x + "," + d.y + ")"
                            });

                        //d3.select(this).classed("fixed", d.fixed = true);
                        // circle.attr("transform", function(d) {
                        //     return "translate(" + d.x + "," + d.y + ")";
                        // });
                        //************************************
                        // text.attr("transform", function(d) {
                        //     return "translate(" + d.x + "," + d.y + ")";
                        // });
                        //************************************
                    }

                    //For not moving after drag
                    var drag = force.drag()
                        .on("dragstart", dragstart);
                    //.on("dragstart", dragstartAll);

                    //For not moving after drag
                    function dblclick(d) {
                        d3.select(this).classed("fixed", d.fixed = false);

                    }

                    //For not moving after drag
                    function dragstart(d) {
                        d3.select(this).classed("fixed", d.fixed = true);

                        for (i = 0; i < nodes.length; i++) {
                            nodes[i].fixed = true;
                        }
                    }


                    // For legend
                    // var colNodeScaleSeparateInfo = d3.scale.ordinal()
                    //     .range(["#767776", "#f91104"])
                    //     .domain(["Query Gene Set", "Pathways / Kinases Perturbation"]);


                    var svgText = svg2.append("text");
                    svgText.attr("x",10).attr("y",globalHPlus50-50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);



                    var legend2 = svg2.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());
                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg2.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg2.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg2.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();



                };

                //defaultSVG2();

                // d3.select('#force2').on('click', function () {
                //     defaultSVG2();
                // });
                // Set-up the export button
                // d3.select('#download-png').on('click', function() {
                //
                // })

                function circularView2(){
                    svg2.remove();

                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    colNodeScaleSeparate.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));
                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = w,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;

//These variables are global variables
                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;

                    svg2 = d3.select("#chart2")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);
                    svg2.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");


                    // This is for grouping nodes


                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h]);

// evenly spaces nodes along arc
                    var circleCoord = function (node, index, num_nodes) {
                        var circumference = circle.node().getTotalLength();
                        var pointAtLength = function (l) {
                            return circle.node().getPointAtLength(l)
                        };
                        var sectionLength = (circumference) / num_nodes;
                        var position = sectionLength * index + sectionLength / 2;
                        return pointAtLength(circumference - position)
                    }

                    var is_connected = function (d, opacity) {
                        lines.transition().style("stroke-opacity", function (o) {
                            return o.source === d || o.target === d ? 1 : opacity;
                        });
                    }

                    var dim = w - (widthValue - circleValue);
                    var circle = svg2.append("path")
                        .attr("d", "M " + String((widthValue - circleValue)/2) + ", " + (dim / 2 + (widthValue - circleValue)/2) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                        .style("fill", "white");

                    // var dim = w - 900;
                    // var circle = svg2.append("path")
                    //     .attr("d", "M 450, " + (dim / 2 + 450) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                    //     .style("fill", "white");

                    force.start();

                    nodes.forEach(function (n, i) {
                        var coord = circleCoord(n, i, nodes.length)
                        n.x = coord.x
                        n.y = coord.y
                    });


                    // use this one for straight line links...
                    // var lines = svg.selectAll("line.node-link")
                    //     .data(links).enter().append("line")
                    //     .attr("class", "node-link")
                    //     .attr("x1", function(d) { return d.source.x; })
                    //     .attr("y1", function(d) { return d.source.y; })
                    //     .attr("x2", function(d) { return d.target.x; })
                    //     .attr("y2", function(d) { return d.target.y; });


                    svg2.append('defs').append('marker')
                        .attr({
                            'id': 'arrowhead',
                            'viewBox': '-0 -5 10 10',
                            'refX': 25,
                            'refY': 0,
                            //'markerUnits':'strokeWidth',
                            'orient': 'auto',
                            'markerWidth': 5,
                            'markerHeight': 6,
                            'xoverflow': 'visible'
                        })
                        .append('svg:path')
                        .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
                        .attr('fill', 'black')
                        .attr('stroke', '#ccc');


                    var lines = svg2.selectAll("path.node-link")
                        .data(links).enter().append("path")
                        .style("fill", "none")
                        .style("stroke", "#726363")
                        .attr("class", "node-link")
                        .attr("d", function (d) {

                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,
                                dr = Math.sqrt(dx * dx + dy * dy),
                                a1 = dx,
                                a2 = dy,
                                c1 = w / 2 - d.source.x,
                                c2 = h / 2 - d.source.y,
                                d1 = w / 2 - d.target.x,
                                d2 = h / 2 - d.target.y,

                                drx = dr / 1.5,
                                dry = dr / 1.5,
                                xRotation = 0, // degrees
                                largeArc = 0, // 1 or 0

                                sweep = 1, // 1 or 0
                                x2 = d.target.x,
                                y2 = d.target.y;


                            // if( (a1*c2 - a2*c1) > 0)
                            // {
                            //     sweep = 0
                            // }
                            // else
                            // {sweep = 1}
                            if ((c1 * d2 - c2 * d1) > 0) {
                                sweep = 0
                            }
                            else {
                                sweep = 1
                            }

                            if (d.target.x === d.source.x && d.target.y === d.source.y) {
                                // Fiddle with this angle to get loop oriented.
                                xRotation = -45;

                                // Needs to be 1.
                                largeArc = 1;

                                // Change sweep to change orientation of loop.
                                //sweep = 0;

                                // Make drx and dry different to get an ellipse
                                // instead of a circle.
                                drx = 30;
                                dry = 20;

                                // For whatever reason the arc collapses to a point if the beginning
                                // and ending points of the arc are the same, so kludge it.
                                x2 = d.target.x + 1;
                                y2 = d.target.y + 1;
                                return "M" + d.source.x + "," + d.source.y + "A" + drx + "," + dry + " " + xRotation + "," + largeArc + "," + sweep + " " + x2 + "," + y2;

                            }
                            else{
                                return "M" +
                                    d.source.x + "," +
                                    d.source.y + "," +
                                    d.target.x + "," +
                                    d.target.y;
                            }



                        })










                        // .attr("d", function (d) {
                        //     var dx = d.target.x - d.source.x,
                        //         dy = d.target.y - d.source.y,
                        //         dr = Math.sqrt(dx * dx + dy * dy),
                        //         drx = dr,
                        //         dry = dr,
                        //         xRotation = 0, // degrees
                        //         largeArc = 0, // 1 or 0
                        //         sweep = 1, // 1 or 0
                        //         x2 = d.target.x,
                        //         y2 = d.target.y;
                        //     ////console.log(d.source.x);
                        //     // //console.log(d.target.x);
                        //
                        //     if (d.target.x === d.source.x && d.target.y === d.source.y) {
                        //         // Fiddle with this angle to get loop oriented.
                        //         xRotation = -45;
                        //
                        //         // Needs to be 1.
                        //         largeArc = 1;
                        //
                        //         // Change sweep to change orientation of loop.
                        //         //sweep = 0;
                        //
                        //         // Make drx and dry different to get an ellipse
                        //         // instead of a circle.
                        //         drx = 30;
                        //         dry = 20;
                        //
                        //         // For whatever reason the arc collapses to a point if the beginning
                        //         // and ending points of the arc are the same, so kludge it.
                        //         x2 = d.target.x + 1;
                        //         y2 = d.target.y + 1;
                        //     }
                        //
                        //     return "M" + d.source.x + "," + d.source.y + "A" + drx + "," + dry + " " + xRotation + "," + largeArc + "," + sweep + " " + x2 + "," + y2;
                        //
                        //
                        //     //return "M" + d.source.x + "," + d.source.y + ","+ d.target.x + "," + d.target.y;
                        //     //return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
                        // })

                        .attr('marker-end', 'url(#arrowhead)');


                    var gnodes = svg2.selectAll('g.gnode')
                        .data(nodes).enter().append('g')
                        .attr("transform", function (d) {
                            return "translate(" + d.x + "," + d.y + ")"
                        })
                        .classed('gnode', true);


                    // node.append("circle")
                    //     .attr("r", function (d) { return xScale(d.weight); })
                    //     .style("fill", function(d) { return colNodeScale(d.group); });

                    var node = gnodes.append("circle")
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        .style("fill", function (d) {
                            if (d.group == 0) {
                                return colorScale(d.value);
                            }
                            else {

                                return colNodeScaleSeparate(d.group);
                            }
                            //return colNodeScaleSeparate(d.group);
                        })
                        .style("stroke", "#333")
                        .style("stroke-width", "2px")
                        //.attr("class", "node")
                        .on("mouseenter", function (d) {
                            is_connected(d, 0.1)
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            d3.select(this).transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight + 10);
                            })
                        })
                        .on("mouseleave", function (d) {
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            is_connected(d, 1);
                        })
                        .call(force.drag);

                    var labels = gnodes.append("text")
                        .attr("dx", 4)
                        .attr("dy", 4)
                        .style("font", String(fontValue) + "px Arial")
                        //.style("font", "14px Times New Roman")
                        .attr("text-anchor", function (d) {
                            return d.x < w / 2 ? "end" : "start";
                        })
                        .attr("transform", function (d) {
                            return d.x < w / 2 ? "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(-20)" : "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(20)";
                        })
                        //.attr("transform", function(d) { return  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")"})
                        //.attr("transform", function(d) { return (d.x-w/2)/(d.y-w/2) < 0 ?  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")" : "rotate(180)"; })
                        .text(function (d) {
                            return d.full_name
                        })

                    var drag = force.drag()
                        .on("dragstart", dragstart);
                    //.on("dragstart", dragstartAll);


                    //For not moving after drag
                    function dragstart(d) {
                        d3.select(this).classed("fixed", d.fixed = true);

                        for (i = 0; i < nodes.length; i++) {
                            nodes[i].fixed = true;
                        }
                    }

                    var svgText = svg2.append("text");
                    svgText.attr("x",10).attr("y",globalHPlus50-50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);



                    var legend2 = svg2.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());





                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg2.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg2.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg2.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();


                };

               function circosView2(){
                   svg2.remove();

                   xScale.domain(d3.extent(nodes, function (d) {
                       return d.weight;
                   }));
                   colNodeScaleSeparate.domain(d3.extent(nodes, function (d) {
                       return d.group;
                   }));
                   colScale.domain(d3.extent(links, function (d) {
                       return d.weight;
                   }));
                   var margin = 75,
                       w = widthValue - 2 * margin,
                       h = w,
                       radius = w / 2,
                       strokeWidth = 4,
                       hyp2 = Math.pow(radius, 2),
                       nodeBaseRad = 5;

//These variables are global variables
                   globalH = h;
                   globalHPlus50 = h + 50;
                   globalW = w;

                   svg2 = d3.select("#chart2")
                       .append("svg")
                       .attr("style", "outline: thin solid yellow;")
                       .attr("width", w)
                       .attr("height", globalHPlus50);
                   svg2.append("rect")
                       .attr("width", "100%")
                       .attr("height", "100%")
                       .attr("fill", "white");


                   // This is for grouping nodes


                   var force = d3.layout.force()
                       .nodes(nodes)
                       .links(links)
                       .size([w, h]);

// evenly spaces nodes along arc
                   var circleCoord = function (node, index, num_nodes) {
                       var circumference = circle.node().getTotalLength();
                       var pointAtLength = function (l) {
                           return circle.node().getPointAtLength(l)
                       };
                       var sectionLength = (circumference) / num_nodes;
                       var position = sectionLength * index + sectionLength / 2;
                       return pointAtLength(circumference - position)
                   }

                   var is_connected = function (d, opacity) {
                       lines.transition().style("stroke-opacity", function (o) {
                           return o.source === d || o.target === d ? 1 : opacity;
                       });
                   }

                   var dim = w - (widthValue - circleValue);
                   var circle = svg2.append("path")
                       .attr("d", "M " + String((widthValue - circleValue)/2) + ", " + (dim / 2 + (widthValue - circleValue)/2) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                       .style("fill", "white");

                   // var dim = w - 900;
                   // var circle = svg2.append("path")
                   //     .attr("d", "M 450, " + (dim / 2 + 450) + " a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim + ",0 a " + dim / 2 + "," + dim / 2 + " 0 1,0 " + dim * -1 + ",0")
                   //     .style("fill", "white");

                   force.start();

                   nodes.forEach(function (n, i) {
                       var coord = circleCoord(n, i, nodes.length)
                       n.x = coord.x
                       n.y = coord.y
                   });


                   // use this one for straight line links...
                   // var lines = svg.selectAll("line.node-link")
                   //     .data(links).enter().append("line")
                   //     .attr("class", "node-link")
                   //     .attr("x1", function(d) { return d.source.x; })
                   //     .attr("y1", function(d) { return d.source.y; })
                   //     .attr("x2", function(d) { return d.target.x; })
                   //     .attr("y2", function(d) { return d.target.y; });


                   svg2.append('defs').append('marker')
                       .attr({
                           'id': 'arrowhead',
                           'viewBox': '-0 -5 10 10',
                           'refX': 25,
                           'refY': 0,
                           //'markerUnits':'strokeWidth',
                           'orient': 'auto',
                           'markerWidth': 5,
                           'markerHeight': 6,
                           'xoverflow': 'visible'
                       })
                       .append('svg:path')
                       .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
                       .attr('fill', 'black')
                       .attr('stroke', '#ccc');


                   var lines = svg2.selectAll("path.node-link")
                       .data(links).enter().append("path")
                       .style("fill", "none")
                       .style("stroke", "#726363")
                       .attr("class", "node-link")
                       .attr("d", function (d) {

                           var dx = d.target.x - d.source.x,
                               dy = d.target.y - d.source.y,
                               dr = Math.sqrt(dx * dx + dy * dy),
                               a1 = dx,
                               a2 = dy,
                               c1 = w / 2 - d.source.x,
                               c2 = h / 2 - d.source.y,
                               d1 = w / 2 - d.target.x,
                               d2 = h / 2 - d.target.y,

                               drx = dr / 1.5,
                               dry = dr / 1.5,
                               xRotation = 0, // degrees
                               largeArc = 0, // 1 or 0

                               sweep = 1, // 1 or 0
                               x2 = d.target.x,
                               y2 = d.target.y;


                           // if( (a1*c2 - a2*c1) > 0)
                           // {
                           //     sweep = 0
                           // }
                           // else
                           // {sweep = 1}
                           if ((c1 * d2 - c2 * d1) > 0) {
                               sweep = 0
                           }
                           else {
                               sweep = 1
                           }

                           if (d.target.x === d.source.x && d.target.y === d.source.y) {
                               // Fiddle with this angle to get loop oriented.
                               xRotation = -45;

                               // Needs to be 1.
                               largeArc = 1;

                               // Change sweep to change orientation of loop.
                               //sweep = 0;

                               // Make drx and dry different to get an ellipse
                               // instead of a circle.
                               drx = 30;
                               dry = 20;

                               // For whatever reason the arc collapses to a point if the beginning
                               // and ending points of the arc are the same, so kludge it.
                               x2 = d.target.x + 1;
                               y2 = d.target.y + 1;

                           }


                           return "M" + d.source.x + "," + d.source.y + "A" + drx + "," + dry + " " + xRotation + "," + largeArc + "," + sweep + " " + x2 + "," + y2;
                       })




                       // .attr("d", function (d) {
                       //     var dx = d.target.x - d.source.x,
                       //         dy = d.target.y - d.source.y,
                       //         dr = Math.sqrt(dx * dx + dy * dy),
                       //         drx = dr,
                       //         dry = dr,
                       //         xRotation = 0, // degrees
                       //         largeArc = 0, // 1 or 0
                       //         sweep = 1, // 1 or 0
                       //         x2 = d.target.x,
                       //         y2 = d.target.y;
                       //     ////console.log(d.source.x);
                       //     // //console.log(d.target.x);
                       //
                       //     if (d.target.x === d.source.x && d.target.y === d.source.y) {
                       //         // Fiddle with this angle to get loop oriented.
                       //         xRotation = -45;
                       //
                       //         // Needs to be 1.
                       //         largeArc = 1;
                       //
                       //         // Change sweep to change orientation of loop.
                       //         //sweep = 0;
                       //
                       //         // Make drx and dry different to get an ellipse
                       //         // instead of a circle.
                       //         drx = 30;
                       //         dry = 20;
                       //
                       //         // For whatever reason the arc collapses to a point if the beginning
                       //         // and ending points of the arc are the same, so kludge it.
                       //         x2 = d.target.x + 1;
                       //         y2 = d.target.y + 1;
                       //     }
                       //
                       //     return "M" + d.source.x + "," + d.source.y + "A" + drx + "," + dry + " " + xRotation + "," + largeArc + "," + sweep + " " + x2 + "," + y2;
                       //
                       //
                       //     //return "M" + d.source.x + "," + d.source.y + ","+ d.target.x + "," + d.target.y;
                       //     //return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
                       // })

                       .attr('marker-end', 'url(#arrowhead)');


                   var gnodes = svg2.selectAll('g.gnode')
                       .data(nodes).enter().append('g')
                       .attr("transform", function (d) {
                           return "translate(" + d.x + "," + d.y + ")"
                       })
                       .classed('gnode', true);


                   // node.append("circle")
                   //     .attr("r", function (d) { return xScale(d.weight); })
                   //     .style("fill", function(d) { return colNodeScale(d.group); });

                   var node = gnodes.append("circle")
                       .attr("r", function (d) {
                           return xScale(d.weight);
                       })
                       .style("fill", function (d) {
                           if (d.group == 0) {
                               return colorScale(d.value);
                           }
                           else {

                               return colNodeScaleSeparate(d.group);
                           }
                           //return colNodeScaleSeparate(d.group);
                       })
                       .style("stroke", "#333")
                       .style("stroke-width", "2px")
                       //.attr("class", "node")
                       .on("mouseenter", function (d) {
                           is_connected(d, 0.1)
                           node.transition().duration(100).attr("r", function (d) {
                               return xScale(d.weight);
                           })
                           d3.select(this).transition().duration(100).attr("r", function (d) {
                               return xScale(d.weight + 10);
                           })
                       })
                       .on("mouseleave", function (d) {
                           node.transition().duration(100).attr("r", function (d) {
                               return xScale(d.weight);
                           })
                           is_connected(d, 1);
                       })
                       .call(force.drag);

                   var labels = gnodes.append("text")
                       .attr("dx", 4)
                       .attr("dy", 4)
                       .style("font", String(fontValue) + "px Arial")
                       //.style("font", "14px Times New Roman")
                       .attr("text-anchor", function (d) {
                           return d.x < w / 2 ? "end" : "start";
                       })
                       .attr("transform", function (d) {
                           return d.x < w / 2 ? "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(-20)" : "rotate(" + Math.atan((d.y - w / 2) / (d.x - w / 2)) * 180 / Math.PI + ")translate(20)";
                       })
                       //.attr("transform", function(d) { return  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")"})
                       //.attr("transform", function(d) { return (d.x-w/2)/(d.y-w/2) < 0 ?  "rotate(" +Math.atan((d.y-w/2)/(d.x-w/2))*180/Math.PI+ ")" : "rotate(180)"; })
                       .text(function (d) {
                           return d.full_name
                       })

                   var drag = force.drag()
                       .on("dragstart", dragstart);
                   //.on("dragstart", dragstartAll);


                   //For not moving after drag
                   function dragstart(d) {
                       d3.select(this).classed("fixed", d.fixed = true);

                       for (i = 0; i < nodes.length; i++) {
                           nodes[i].fixed = true;
                       }
                   }

                   var svgText = svg2.append("text");
                   svgText.attr("x",10).attr("y",globalHPlus50-50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                   //Added from here for coloring the legend
                   max_data = 1000;
                   min_data = -1000;


                   var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                   var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                   var colorScale2 = d3.scale.threshold()
                       .domain(domain_data)
                       .range(colors);



                   var legend2 = svg2.selectAll(".legend")

                   //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                       .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                           return d;
                       });

                   // //console.log("colorScale.quantiles()");
                   // //console.log(colorScale.quantiles());





                   legend2.enter().append("g")
                       .attr("class", "legend");
                   var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                   var legendElementWidth = gridSize * 2;
                   legend2.append("rect")
                       .attr("x", function (d, i) {
                           return legendElementWidth * i;
                       })
                       .attr("y", globalHPlus50 - 40)
                       .attr("width", legendElementWidth)
                       .attr("height", gridSize / 2)
                       .style("fill", function (d, i) {
                           return colors[i];
                       });

                   legend2.append("text")
                   //.attr("class", "mono")
                       .text(function (d, i) {
                           if (i == 0) {
                               return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                           }
                           else if (i == svg2.selectAll(".legend").data().length - 1) {

                               return parseFloat(Math.round((svg2.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                           }
                           else {

                               return parseFloat(Math.round((svg2.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                           }
                           //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                       })
                       .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                       .attr("x", function (d, i) {
                           return legendElementWidth * i;
                       })
                       .attr("y", globalHPlus50 - 40 + gridSize);

                   legend2.exit().remove();


               };


                function parallelView2() {
                    //d3.select('#parallelView2').on('click', function () {
                    svg2.remove();

                    //xPosition.domain(d3.extent(nodes, function (d) { return d.text; }));
                    xScale.domain(d3.extent(nodes, function (d) {
                        return d.weight;
                    }));
                    colNodeScaleSeparate.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    colScale.domain(d3.extent(links, function (d) {
                        return d.weight;
                    }));
                    textPlacePlusMinus.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));
                    textPlaceStartEnd.domain(d3.extent(nodes, function (d) {
                        return d.group;
                    }));


                    n1 = 0;
                    n2 = 0;
                    n0 = 0;

                    nodes.forEach(function (n, i) {


                        if (n.group == 0) {

                            n0 = n0 + 1;
                        }
                        if (n.group == 1) {

                            n1 = n1 + 1;
                        }
                        if (n.group == 2) {

                            n2 = n2 + 1;
                        }

                    });
                    //console.log(n0);
                    //console.log(n0 * 12);
                    //console.log(n1);
                    //console.log(n1 * 12);
                    //console.log(n2);
                    //console.log(n2 * 12);
                    var parallelH = Math.max(n0 * 12, n1 * 12, n2 * 12, 500);
                    //var parallelH = Math.max(n0 * 12, n1 * 12, n2 * 12);

                    var margin = 75,
                        w = widthValue - 2 * margin,
                        h = parallelH,
                        radius = w / 2,
                        strokeWidth = 4,
                        hyp2 = Math.pow(radius, 2),
                        nodeBaseRad = 5;

                    globalH = h;
                    globalHPlus50 = h + 50;
                    globalW = w;

                    svg2 = d3.select("#chart2")
                        .append("svg")
                        .attr("style", "outline: thin solid yellow;")
                        .attr("width", w)
                        .attr("height", globalHPlus50);

                    svg2.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "white");


                    var force = d3.layout.force()
                        .nodes(nodes)
                        .links(links)
                        .size([w, h]);


                    var parallelCoordx = function (group) {

                        if (group == 0) {
                            return w / 2;
                        }
                        if (group == 1) {
                            return w * 2 / 3;
                        }
                        else {
                            return w / 3;
                        }
                    }

                    var parallelCoordy = function (index, num_nodes) {
                        var dist = h / (num_nodes + 1);

                        return (index + 1) * dist;
                    }

                    var is_connected = function (d, opacity) {
                        lines.transition().style("stroke-opacity", function (o) {
                            return o.source === d || o.target === d ? 1 : opacity;
                        });
                    }

                    //var dim = w-80
                    // var circle = svg.append("path")
                    //     .attr("d", "M 40, "+(dim/2+40)+" a "+dim/2+","+dim/2+" 0 1,0 "+dim+",0 a "+dim/2+","+dim/2+" 0 1,0 "+dim*-1+",0")
                    //     .style("fill", "#f5f5f5");

                    force.start();


                    // //console.log(nodes.length);
                    var groupId = [];
                    var maxId = 0;
                    for (var i = 0; i < nodes.length; i++) {
                        var item = nodes[i];

                        if (!groupId[item.group]) {
                            groupId[item.group] = [];
                        }

                        groupId[item.group].push({name: item.name});
                        // //console.log(item.group);
                        // //console.log(groupId[item.group]);
                        if (maxId < item.group) {
                            maxId = item.group;
                        }
                    }
                    // //console.log(maxId);
                    // //console.log(groupId[1].length);
                    // //console.log(groupId[2].length);


                    n1 = 0;
                    n2 = 0;
                    n0 = 0;
                    nodes.forEach(function (n, i) {
                        var item = nodes[i];

                        if (n.group == 0) {
                            n.x = parallelCoordx(n.group)
                            n.y = parallelCoordy(n0, groupId[0].length)
                            n0 = n0 + 1;
                        }
                        if (n.group == 1) {
                            n.x = parallelCoordx(n.group)
                            n.y = parallelCoordy(n1, groupId[1].length)
                            n1 = n1 + 1;
                        }
                        if (n.group == 2) {
                            n.x = parallelCoordx(n.group)
                            n.y = parallelCoordy(n2, groupId[2].length)
                            n2 = n2 + 1;
                        }

                    });


                    // use this one for straight line links...
                    // var lines = svg.selectAll("line.node-link")
                    //   .data(links).enter().append("line")
                    //     .attr("class", "node-link")
                    //   .attr("x1", function(d) { return d.source.x; })
                    //   .attr("y1", function(d) { return d.source.y; })
                    //   .attr("x2", function(d) { return d.target.x; })
                    //   .attr("y2", function(d) { return d.target.y; });


                    svg2.append('defs').append('marker')
                        .attr({
                            'id': 'arrowhead',
                            'viewBox': '-0 -5 10 10',
                            'refX': 25,
                            'refY': 0,
                            //'markerUnits':'strokeWidth',
                            'orient': 'auto',
                            'markerWidth': 5,
                            'markerHeight': 6,
                            'xoverflow': 'visible'
                        })
                        .append('svg:path')
                        .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
                        .attr('fill', 'black')
                        .attr('stroke', '#ccc');


                    // var path = svg2.append("svg:g").selectAll("path")
                    // //.data(links)
                    //     .data(force.links())
                    //     .enter().append("svg:path")
                    //     .style("fill", "none")
                    //     .style("stroke", "black")
                    //     .style("stroke", function (d) {
                    //         return colScale(d.value);
                    //     })
                    //     //.attr("marker-end", function(d) { return "url(#" + d.type + ")"; })
                    //     .attr("class", function (d) {
                    //         return "link ";
                    //     })
                    //     .attr('marker-end', 'url(#arrowhead)');

                    var lines = svg2.selectAll("path.node-link")
                        .data(links).enter().append("path")
                        .style("fill", "none")
                        .style("stroke", "#726363")
                        .attr("class", "node-link")
                        .attr("d", function (d) {
                            var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,
                                dr = Math.sqrt(dx * dx + dy * dy),
                                drx = dr,
                                dry = dr,
                                xRotation = 0, // degrees
                                largeArc = 0, // 1 or 0
                                sweep = 1, // 1 or 0
                                x2 = d.target.x,
                                y2 = d.target.y;
                            // console.log(d);
                            // console.log(d.target.x);

                            // if (d.target.x === d.source.x && d.target.y === d.source.y) {
                            //     // Fiddle with this angle to get loop oriented.
                            //     xRotation = -45;
                            //
                            //     // Needs to be 1.
                            //     largeArc = 1;
                            //
                            //     // Change sweep to change orientation of loop.
                            //     //sweep = 0;
                            //
                            //     // Make drx and dry different to get an ellipse
                            //     // instead of a circle.
                            //     drx = 3;
                            //     dry = 2;
                            //
                            //     // For whatever reason the arc collapses to a point if the beginning
                            //     // and ending points of the arc are the same, so kludge it.
                            //     x2 = d.target.x + 1;
                            //     y2 = d.target.y + 1;
                            // }
                            if (d.target.x === d.source.x && d.target.y === d.source.y) {
                                // Fiddle with this angle to get loop oriented.
                                xRotation = -45;

                                // Needs to be 1.
                                largeArc = 1;

                                // Change sweep to change orientation of loop.
                                //sweep = 0;

                                // Make drx and dry different to get an ellipse
                                // instead of a circle.
                                drx = 30;
                                dry = 20;

                                // For whatever reason the arc collapses to a point if the beginning
                                // and ending points of the arc are the same, so kludge it.
                                x2 = d.target.x + 1;
                                y2 = d.target.y + 1;
                                return "M" + d.source.x + "," + d.source.y + "A" + drx + "," + dry + " " + xRotation + "," + largeArc + "," + sweep + " " + x2 + "," + y2;

                            }
                            else if (d.target.x === d.source.x ) {
                                    drx = 30;
                                    dry = 20;
                                    return "M" + d.source.x + "," + d.source.y + "A" + drx + "," + dry + " " + xRotation + "," + largeArc + "," + sweep + " " + x2 + "," + y2;

                            }
                            else{
                                return "M" +
                                    d.source.x + "," +
                                    d.source.y + "," +
                                    d.target.x + "," +
                                    d.target.y;
                            }


                            //
                            // else{
                            //     drx = 3000;
                            //     dry = 2000;
                            //     return "M" + d.source.x + "," + d.source.y + "A" + drx + "," + dry + " " + xRotation + "," + largeArc + "," + sweep + " " + x2 + "," + y2;
                            //
                            // }


                            //return "M" + d.source.x + "," + d.source.y + ","+ d.target.x + "," + d.target.y;
                            //return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
                        })

                        .attr('marker-end', 'url(#arrowhead)');

                    // var lines = svg.selectAll("path.node-link")
                    //     .data(links).enter().append("path")
                    //     .style("fill", "none")
                    //     .style("stroke", "black")
                    //     .attr("class", "node-link")
                    //     .attr("d", function(d) {
                    //         var dx = d.target.x - d.source.x,
                    //             dy = d.target.y - d.source.y,
                    //             dr = Math.sqrt(dx * dx + dy * dy);
                    //         return "M" +
                    //             d.source.x + "," +
                    //             d.source.y + "A" +
                    //             dr + "," + dr + " 0 0,1 " +
                    //             d.target.x + "," +
                    //             d.target.y;
                    //     });

                    var gnodes = svg2.selectAll('g.gnode')
                        .data(nodes).enter().append('g')
                        .attr("transform", function (d) {
                            return "translate(" + d.x + "," + d.y + ")"
                        })
                        .classed('gnode', true);

                    var node = gnodes.append("circle")
                        .attr("r", function (d) {
                            return xScale(d.weight);
                        })
                        .style("fill", function (d) {
                            if (d.group == 0) {
                                return colorScale(d.value);
                            }
                            else {

                                return colNodeScaleSeparate(d.group);
                            }
                            //return colNodeScaleSeparate(d.group);
                        })
                        .style("stroke", "#333")
                        .style("stroke-width", "2px")
                        //.attr("class", "node")
                        .on("mouseenter", function (d) {
                            is_connected(d, 0.1)
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            d3.select(this).transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight + 10);
                            })
                        })
                        .on("mouseleave", function (d) {
                            node.transition().duration(100).attr("r", function (d) {
                                return xScale(d.weight);
                            })
                            is_connected(d, 1);
                        })
                        .call(force.drag);
                    // var bbox = textElement.getBBox();
                    // var width = bbox.width;
                    // var height = bbox.height;
                    var labels = gnodes.append("text")
                        .style("font", String(fontValue) + "px Arial")
                        //.style("font", "14px Times New Roman")
                        .attr("dx", function (d) {
                            return textPlacePlusMinus(d.group);
                        })
                        .attr("dy", 4)
                        .attr("text-anchor", function (d) {
                            return textPlaceStartEnd(d.group);
                        })
                        .text(function (d) {
                            return d.full_name
                        });


                    var svgText = svg2.append("text");
                    svgText.attr("x",10).attr("y",globalHPlus50-50).text("PiNET-server @ www.pinet-server.org").style("font", "14px Times New Roman");

                    //Added from here for coloring the legend
                    max_data = 1000;
                    min_data = -1000;


                    var colors = ["#00A6FF", "#1097E0", "#2885B7", "#35799E", "#4C7991", "#6D828D", "#8C8C8C", "#8E8E5C", "#92923C", "#A5A52E", "#BDBD24", "#DDDD15", "#FFFF00"];
                    var domain_data = [-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 1000];


                    var colorScale2 = d3.scale.threshold()
                        .domain(domain_data)
                        .range(colors);



                    var legend2 = svg2.selectAll(".legend")

                    //.data([min_data, min_data + (max_data - min_data) / 7, min_data + 2 * (max_data - min_data) / 7, min_data + 3 * (max_data - min_data) / 7, min_data + 4 * (max_data - min_data) / 7, min_data + 5 * (max_data - min_data) / 7, min_data + 6 * (max_data - min_data) / 7], function (d) {
                        .data([-2.0, -1.6, -1.2, -0.8, -0.4, -0.01, 0.01, 0.4, 0.8, 1.2, 1.6, 2.0, 10.0], function (d) {

                            return d;
                        });

                    // //console.log("colorScale.quantiles()");
                    // //console.log(colorScale.quantiles());

                    legend2.enter().append("g")
                        .attr("class", "legend");
                    var gridSize = Math.floor(Math.min(1500, globalW) / 40);
                    var legendElementWidth = gridSize * 2;
                    legend2.append("rect")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40)
                        .attr("width", legendElementWidth)
                        .attr("height", gridSize / 2)
                        .style("fill", function (d, i) {
                            return colors[i];
                        });

                    legend2.append("text")
                    //.attr("class", "mono")
                        .text(function (d, i) {
                            if (i == 0) {
                                return "-∞ ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            else if (i == svg2.selectAll(".legend").data().length - 1) {

                                return parseFloat(Math.round((svg2.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a ≤ ∞";
                            }
                            else {

                                return parseFloat(Math.round((svg2.selectAll(".legend").data()[i - 1]) * 100) / 100).toFixed(1) + " ≤ a < " + parseFloat(Math.round(d * 100) / 100).toFixed(1);
                            }
                            //return  parseFloat(Math.round(d * 100) / 100).toFixed(2) + "≥ a";
                        })
                        .style("font", String(Math.trunc(11*Math.min(1500, globalW) /1500)) + "px Times New Roman")
                        .attr("x", function (d, i) {
                            return legendElementWidth * i;
                        })
                        .attr("y", globalHPlus50 - 40 + gridSize);

                    legend2.exit().remove();


                };


                d3.select('#force2').on('click', function () {
                    defaultView2();
                    $scope.graphType4kinase = 0;
                });
                d3.select('#parallelView2').on('click', function () {
                    parallelView2();
                    $scope.graphType4kinase = 1;
                });
                d3.select('#circosView2').on('click', function (){
                    circosView2();
                    $scope.graphType4kinase = 2;
                });
                d3.select('#circularView2').on('click', function (){
                    circularView2();
                    $scope.graphType4kinase = 3;
                });


                if(graphType == 0){
                    defaultView2();
                }
                else if(graphType == 1){
                    parallelView2();
                }
                else if(graphType == 2){
                    circosView2();
                }
                else if(graphType == 3){
                    circularView2();
                }



                d3.select("#download-svg2").on("click", function ()  {
                    var name = 'Pinet-Gene-Kinase-Graph.svg';
                    var svgEl = svg2.node();
                    svgEl.setAttribute("xmlns", "http://www.w3.org/2000/svg");
                    var svgData = svgEl.outerHTML;
                    var preface = '<?xml version="1.0" standalone="no"?>\r\n';
                    var svgBlob = new Blob([preface, svgData], {type:"image/svg+xml;charset=utf-8"});
                    var svgUrl = URL.createObjectURL(svgBlob);
                    var downloadLink = document.createElement("a");
                    downloadLink.href = svgUrl;
                    downloadLink.download = name;
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                })


                // Set-up the export button
                d3.select('#download-png2').on('click', function () {
                    var svgString = getSVGString(svg2.node());

                    svgString2Image(svgString, 4 * globalW, 4 * globalHPlus50, 'png', save); // passes Blob and filesize String to the callback

                    function save(dataBlob, filesize) {
                        saveAs(dataBlob, 'Pinet-Gene-Kinase-Graph.png'); // FileSaver.js function
                    }
                });
                // d3.select('#saveButton').on('click', function () {
                //     var svgString = getSVGString(svg.node());
                //
                //     svgString2Image(svgString, 4 * 1550, 4 * 1550, 'png', save); // passes Blob and filesize String to the callback
                //
                //     function save(dataBlob, filesize) {
                //         saveAs(dataBlob, 'PiNET-grapg.png'); // FileSaver.js function
                //     }
                // });
                //^^^^^^^^^^^^^^^^
                //^^^^^^^^^^^^^^^^
                //^^^^^^^^^^^^^^^^
                //^^^^^^^^^^^^^^^^
                //^^^^^^^^^^^^^^^^
                //^^^^^^^^^^^^^^^^
                //^^^^^^^^^^^^^^^^
                //^^^^^^^^^^^^^^^^
                //^^^^^^^^^^^^^^^^
                //^^^^^^^^^^^^^^^^
                //^^^^^^^^^^^^^^^^
// Below are the functions that handle actual exporting:
// getSVGString ( svgNode ) and svgString2Image( svgString, width, height, format, callback )
                function getSVGString(svgNode) {
                    svgNode.setAttribute('xlink', 'http://www.w3.org/1999/xlink');
                    var cssStyleText = getCSSStyles(svgNode);
                    appendCSS(cssStyleText, svgNode);

                    var serializer = new XMLSerializer();
                    var svgString = serializer.serializeToString(svgNode);
                    svgString = svgString.replace(/(\w+)?:?xlink=/g, 'xmlns:xlink='); // Fix root xlink without namespace
                    svgString = svgString.replace(/NS\d+:href/g, 'xlink:href'); // Safari NS namespace fix

                    return svgString;

                    function getCSSStyles(parentElement) {
                        var selectorTextArr = [];

                        // Add Parent element Id and Classes to the list
                        selectorTextArr.push('#' + parentElement.id);
                        for (var c = 0; c < parentElement.classList.length; c++)
                            if (!contains('.' + parentElement.classList[c], selectorTextArr))
                                selectorTextArr.push('.' + parentElement.classList[c]);

                        // Add Children element Ids and Classes to the list
                        var nodes = parentElement.getElementsByTagName("*");
                        for (var i = 0; i < nodes.length; i++) {
                            var id = nodes[i].id;
                            if (!contains('#' + id, selectorTextArr))
                                selectorTextArr.push('#' + id);

                            var classes = nodes[i].classList;
                            for (var c = 0; c < classes.length; c++)
                                if (!contains('.' + classes[c], selectorTextArr))
                                    selectorTextArr.push('.' + classes[c]);
                        }

                        // Extract CSS Rules
                        var extractedCSSText = "";
                        for (var i = 0; i < document.styleSheets.length; i++) {
                            var s = document.styleSheets[i];

                            try {
                                if (!s.cssRules) continue;
                            } catch (e) {
                                if (e.name !== 'SecurityError') throw e; // for Firefox
                                continue;
                            }

                            var cssRules = s.cssRules;
                            for (var r = 0; r < cssRules.length; r++) {
                                if (contains(cssRules[r].selectorText, selectorTextArr))
                                    extractedCSSText += cssRules[r].cssText;
                            }
                        }


                        return extractedCSSText;

                        function contains(str, arr) {
                            return arr.indexOf(str) === -1 ? false : true;
                        }

                    }

                    function appendCSS(cssText, element) {
                        var styleElement = document.createElement("style");
                        styleElement.setAttribute("type", "text/css");
                        styleElement.innerHTML = cssText;
                        var refNode = element.hasChildNodes() ? element.children[0] : null;
                        element.insertBefore(styleElement, refNode);
                    }
                }


                function svgString2Image(svgString, width, height, format, callback) {
                    var format = format ? format : 'png';

                    var imgsrc = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgString))); // Convert SVG string to data URL

                    var canvas = document.createElement("canvas");
                    var context = canvas.getContext("2d");

                    canvas.width = width;
                    canvas.height = height;

                    var image = new Image();
                    image.onload = function () {
                        context.clearRect(0, 0, width, height);
                        context.drawImage(image, 0, 0, width, height);

                        canvas.toBlob(function (blob) {
                            var filesize = Math.round(blob.length / 1024) + ' KB';
                            if (callback) callback(blob, filesize);
                        });


                    };

                    image.src = imgsrc;
                }


                //^^^^^^^^^^^^^^^^
                //^^^^^^^^^^^^^^^^
                //^^^^^^^^^^^^^^^^
                //^^^^^^^^^^^^^^^^
                //^^^^^^^^^^^^^^^^
                //^^^^^^^^^^^^^^^^
                //^^^^^^^^^^^^^^^^
                //^^^^^^^^^^^^^^^^
                //^^^^^^^^^^^^^^^^
                //^^^^^^^^^^^^^^^^
                //^^^^^^^^^^^^^^^^


                // d3.select("#download").on("click", function(){
                //     var html = d3.select("svg")
                //         .attr("version", 1.1)
                //         .attr("xmlns", "http://www.w3.org/2000/svg")
                //         .node().parentNode.innerHTML;
                //
                //     ////console.log(html);
                //     var imgsrc = 'data:image/svg+xml;base64,'+ btoa(html);
                //     var img = '<img src="'+imgsrc+'">';
                //     d3.select("#svgdataurl").html(img);
                //
                //
                //     var canvas = document.querySelector("canvas"),
                //         context = canvas.getContext("2d");
                //
                //     var image = new Image;
                //     image.src = imgsrc;
                //     image.onload = function() {
                //         context.drawImage(image, 0, 0);
                //
                //         var canvasdata = canvas.toDataURL("image/png");
                //
                //         var pngimg = '<img src="'+canvasdata+'">';
                //         d3.select("#pngdataurl").html(pngimg);
                //
                //         var a = document.createElement("a");
                //         a.download = "sample.png";
                //         a.href = canvasdata;
                //         a.click();
                //     };
                //
                // });


            }
if(self.computeWeightForUpdateKinase) {
    for (var iterNetNode = 0; iterNetNode < inputNetwork.edges.length; iterNetNode++) {
        //var iterNetNodeKey = network.nodes[iterNetNode]["name"];
        var idx1 = inputNetwork.edges[iterNetNode]["source"];
        var idx2 = inputNetwork.edges[iterNetNode]["target"];
        inputNetwork.nodes[idx1]["weight"] += 1;
        inputNetwork.nodes[idx2]["weight"] += 1;

    }
    self.computeWeightForUpdateKinase = false;
    SharedService.setVar('computeWeightForUpdateKinase',self.computeWeightForUpdateKinase);
}

            for (var iterNetNode = 0; iterNetNode < inputNetwork.nodes.length; iterNetNode++)
            {
                var iterNetNodeKey = inputNetwork.nodes[iterNetNode]["name"]
                if (iterNetNodeKey in geneToAbundance)
                {
                    if (geneToAbundance[iterNetNodeKey] == "NA")
                    {
                        inputNetwork.nodes[iterNetNode]["value"] = 0.0;
                    }
                    else {
                        inputNetwork.nodes[iterNetNode]["value"] = geneToAbundance[iterNetNodeKey];
                    }
                }
            }
            updateKinase(inputNetwork.nodes, inputNetwork.edges, graphType, circleSliderValue, nodeSliderValue, fontSliderValue, widthSliderValue);
            self.showKinaseGraph = true;
        }

    }






    self.changeToP100Genes = function () {
        self.genes = "DYRK1A 0.461099\n\
RPS6KA3 1.24165\n\
HN1 0.39179\n\
ZC3HC1 -0.81353\n\
NCOR2 -0.061737\n\
OCIAD1 -0.09643\n\
PDPK1 0.097759\n\
ABI1 0.588017\n\
WDR20 -0.15000\n\
MAP4 -2.95647\n\
FAM129B 0.019645\n\
TMSB4X 0.88214\n\
TMSB4X 0.9800\n\
AP1GBP1 -1.149179\n\
ZC3H14 0.93623\n\
LARP5 0.5108248\n\
MAP3K7 0.105289\n\
BRD4 0.7733867\n\
KIF4A -3.384948\n\
C22orf9 -2.96875\n\
FOSL2 0.408887\n\
JUND 0.2169463\n\
RPL12 -0.98894\n\
NUP214 -0.59864\n\
TMPO -2.223487\n\
BAT2 -0.011437\n\
FASN 0.768389\n\
FASN 0.518356\n\
FAM76B -0.20854\n\
AHNAK -0.15571\n\
PAK2 1.08313\n\
RPS6KA1 -1.064138\n\
RPS6KA1 -3.20086\n\
NUFIP2 0.428257\n\
RBBP6 0.079337\n\
CASC3 0.53475\n\
KIAA1704 0.75655\n\
CCNYL1 0.193549\n\
RNF169 -0.041419\n\
ZNF740 0.81348\n\
DDX54 0.913738\n\
ATRIP -0.05033\n\
DPF2 0.82016\n\
SMARCC1 -0.07167\n\
KHSRP 0.593808\n\
SH3KBP1 -1.831307\n\
C13orf8 -0.235423\n\
PPP1R10 0.52387\n\
TPX2 -1.28708\n\
RSF1 0.558409\n\
WAC 0.498148\n\
UBE2O -1.19459\n\
WDR26 0.29473\n\
ANLN 0.296644\n\
NANS 0.51163\n\
TERF2IP 0.184049\n\
LRWD1 0.630525\n\
LIMA1 0.316775\n\
LIMA1 0.649939\n\
GPATCH8 0.769031\n\
MAP3K2 0.2409052\n\
THRAP3 -0.33558\n\
BAT2D1 1.081598\n\
BAT2D1 0.54329\n\
CDC2 0.57929\n\
TMPO 1.024626\n\
PLEC1 -1.3094\n\
SRRT 0.417544\n\
SRRM2 0.17558\n\
RBM17 0.51067\n\
PFKP 0.632339\n\
SRRM1 1.47925\n\
ULK1 -1.06842\n\
BRAF 0.286164\n\
FOSL2 0.47064\n\
EIF4A3 -0.82673\n\
C17orf85 0.6774\n\
ATAD2 -0.324736\n\
ATXN2L 0.69807\n\
VPRBP 0.13999\n\
MARK2 -0.578569\n\
EIF4A3 -1.601547\n\
UHRF1BP1L -0.6075\n\
IQGAP3 -1.13349\n\
ZNF672 0.410076\n\
NFATC2IP 0.40125\n\
CLTA -0.1596\n\
HAT1 0.271686\n\
DHX16 0.44265\n\
RPS6 -0.4977\n\
RBM14 -0.79107\n\
ALS2 0.329239\n\
NOC2L 0.131214\n\
SLC38A1 0.2219\n\
NOLC1 -0.3440\n\
PLEC1 -0.309069";

        SharedService.setVar('genes',self.genes);
    }


    self.changeToP100PTMs = function () {
        self.inputMassPtmProteins = "Q13627{[Y+79.966]@321} 0.4611\n\
P51812{[pS]@369} 1.24165\n\
Q9UK76{[pS]@87} 0.3918\n\
Q86WB0{[pS]@321} -0.8135\n\
Q9Y618{[pS]@956} -0.0617\n\
Q9NX40{[pS]@108} -0.09643\n\
O15530{[pS]@241} 0.09776\n\
Q8IZP0{[pS]@183} 0.5880\n\
Q8TBZ3{[pS]@434} -0.15000\n\
P27816{[pS]@1073} -2.95647\n\
Q96TA1{[pS]@691} 0.01964\n\
P62328{[S+122]@2}{[M+16]@7} 0.8821\n\
P62328{[S+122]@2} 0.9800\n\
Q9UMZ2{[pS]@1075} -1.14918\n\
Q6PJT7{[pS]@515} 0.93623\n\
Q92615{[pS]@601} 0.51082\n\
O43318{[pS]@439} 0.105289\n\
O60885{[pS]@1117} 0.77338\n\
O95239{[pS]@801} -3.38494\n\
Q6ICG6{[pS]@362} -2.96875\n\
P15408{[pS]@200} 0.40888\n\
P17535{[pS]@100} 0.216946\n\
P30050{[pS]@38} -0.988941\n\
P35658{[pS]@1023} -0.59863\n\
P42167{[pS]@306} -2.22348\n\
P48634{[pS]@1219} -0.011437\n\
P49327{[pS]@207}{[M+16]@205}{[C+57]@212} 0.768389\n\
P49327{[pS]@207}{[C+57]@212} 0.51835\n\
Q5HYJ3{[pS]@193} -0.20854\n\
Q09666{[pS]@3426} -0.15571\n\
Q13177{[S+122]@2} 1.083130\n\
Q15418{[pS]@221}{[M+16]@229}{[C+57]@223} -1.0641\n\
Q15418{[pS]@221}{[C+57]@223} -3.2008\n\
Q7Z417{[pS]@652} 0.428257\n\
Q7Z6E9{[pS]@1179} 0.079337\n\
O15234{[pS]@265} 0.53475\n\
Q8IXQ4{[pS]@105} 0.75655\n\
Q8N7R7{[pS]@344} 0.1935\n\
Q8NCN4{[pS]@403} -0.041419\n\
Q8NDX6{[pS]@44} 0.81348\n\
Q8TDD1{[pS]@75}{[C+57]@73} 0.91374\n\
Q8WXE1{[pS]@224} -0.05033\n\
Q92785{[pS]@142} 0.82016\n\
Q92922{[pS]@310} -0.07167\n\
Q92945{[pS]@480} 0.593808\n\
Q96B97{[pS]@230} -1.8313\n\
Q96JM3{[pS]@405} -0.23542\n\
Q96QC0{[pS]@313} 0.523876\n\
Q9ULW0{[pS]@738} -1.287086\n\
Q96T23{[pS]@473} 0.558409\n\
Q9BTA9{[pS]@64} 0.4981\n\
Q9C0C9{[pS]@515} -1.19459\n\
Q9H7D7{[pS]@121} 0.29472\n\
Q9NQW6{[pS]@295} 0.29664\n\
Q9NR45{[pS]@275}{[C+57]@283}{[C+57]@287} 0.51163\n\
Q9NYB0{[pS]@203} 0.184049\n\
Q9UFC0{[pS]@212} 0.63052\n\
Q9UHB6{[pS]@362} 0.31677\n\
Q9UHB6{[pS]@490} 0.64994\n\
Q9UKJ3{[pS]@1035} 0.769032\n\
Q9Y2U5{[pS]@163} 0.2409052\n\
Q9Y2W1{[pS]@253} -0.33558\n\
Q9Y520{[pT]@2673} 1.081598\n\
Q9Y520{[pS]@1544} 0.54329\n\
P06493{[pT]@161} 0.57929\n\
P42167{[pT]@160} 1.0246259\n\
Q15149{[pT]@4030} -1.30946\n\
Q9BXP5{[pT]@544} 0.4175439\n\
Q9UQ35{[pT]@1492} 0.17558\n\
Q96I25{[pS]@222} 0.510677\n\
Q01813{[pS]@386} 0.63234\n\
Q8IYB3{[pS]@402} 1.479257\n\
O75385{[pS]@556} -1.06842\n\
P15056{[pS]@446} 0.286164\n\
P15408{[pS]@200}{[M+16]@209} 0.4706487\n\
P38919{[pS]@12}{[M+16]@7}{[A+42.010]@2} -0.826734\n\
Q53F19{[pS]@500} 0.6774\n\
Q6PL18{[pS]@327} -0.3247365\n\
Q8WWM7{[pS]@339} 0.69807\n\
Q9Y4B6{[pS]@1000} 0.13999\n\
Q7KZI7{[pT]@596} -0.578569\n\
P38919{[pS]@12}{[A+42.010]@2} -1.601547\n\
A0JNW5{[pS]@935} -0.60759\n\
Q86VI3{[pS]@1424} -1.133499\n\
Q499Z4{[pS]@189} 0.4100764\n\
Q8NCF5{[pS]@204} 0.4012565\n\
P09496{[pS]@105} -0.159615\n\
O14929{[pS]@361} 0.2716867\n\
O60231{[pS]@103} 0.442654\n\
P62753{[pS]@235} -0.497748\n\
Q96PK6{[pS]@618} -0.791066\n\
Q96Q42{[pS]@483} 0.3292391\n\
Q9Y3T9{[pS]@56} 0.131213\n\
Q9H2H9{[pS]@52} 0.22196\n\
Q14978{[pT]@610} -0.34400\n\
Q15149{M+16@4031}{[pT]@4030} -0.30907";

        // "Q9Y463[Y+79.966@273],Q13627[Y+79.966@321],P51812[pS@369],Q9UK76[pS@87],Q86WB0[pS@321],Q9Y618[pS@956],A0JNW5[pS@935],Q9NX40[pS@108],Q6A1A2[pS@214],O15530[pS@241],Q8IZP0[pS@183],Q8TBZ3[pS@434],P27816[pS@1073],Q96I25[pS@222],Q86VI3[pS@1424],Q96TA1[pS@691],P62328[S+122@2],P62328[S+122@2][M+16@7],P09496[pS@105],Q9UMZ2[pS@1075],Q6PJT7[pS@515],Q01813[pS@386],Q92615[pS@601],O14929[pS@361],O43318[pS@439],Q8IYB3[pS@402],O60885[pS@1117],O75385[pS@556],O95239[pS@801],Q6ICG6[pS@362],O60231[pS@103],P15056[pS@446],P15408[pS@200],P15408[pS@200][M+16@209],P05412[pS@73],P17535[pS@100],P30050[pS@38],P35658[pS@1023],P38919[pS@12][A+42@2],P38919[pS@12][M+16@7][A+42@2],P42167[pS@306],P48634[pS@1219],P49327[pS@207][C+57@212],P49327[pS@207][M+16@205][C+57@212],Q5HYJ3[pS@193],P62753[pS@235],Q09666[pS@3426],Q13177[S+122@2],P51812[pS@227][C+57@229],Q15418[pS@221][C+57@223],Q9UK32[pS@232][C+57@234],P51812[pS@227][M+16@235][C+57@229],Q15418[pS@221][M+16@229][C+57@223],Q9UK32[pS@232][M+16@240][C+57@234],Q499Z4[pS@189],Q53F19[pS@500],Q6PL18[pS@327],Q7Z417[pS@652],Q7Z6E9[pS@1179],O15234[pS@265],Q8IXQ4[pS@105],Q8N7R7[pS@344],Q8NCF5[pS@204],Q8NCN4[pS@403],Q8NDX6[pS@44],Q8TDD1[pS@75][C+57@73],Q8WWM7[pS@339],Q8WXE1[pS@224],Q92785[pS@142],Q92922[pS@310],Q92945[pS@480],Q96B97[pS@230],Q96JM3[pS@405],Q96PK6[pS@618],Q96Q42[pS@483],Q96QC0[pS@313],Q9ULW0[pS@738],Q96T23[pS@473],Q9BTA9[pS@64],Q92560[pS@460],Q9C0C9[pS@515],Q9H7D7[pS@121],Q9NQW6[pS@295],Q9NR45[pS@275][C+57@283],Q9NYB0[pS@203],Q9UFC0[pS@212],Q9UHB6[pS@362],Q9UHB6[pS@490],Q9UKJ3[pS@1035],Q9BXP5[pT@544],Q9Y2U5[pS@163],Q9Y2W1[pS@253],Q9Y3T9[pS@56],Q9Y4B6[pS@1000],Q9Y520[pT@2673],Q7KZI7[pT@596],Q9H2H9[pS@52],Q9Y520[pS@1544],P06493[pT@161],P42167[pT@160],P42166[pT@160],Q14978[pT@610],Q15149[pT@4030],Q15149[M+16@4031][pT@4030],Q9UQ35[pT@1492]";

        SharedService.setVar('inputMassPtmProteins',self.inputMassPtmProteins);
    }

}]);
